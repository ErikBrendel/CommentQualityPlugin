# id;timestamp;commentText;codeText;commentWords;codeWords
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1489770896;FLINK-5985__This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1490724328;FLINK-5985__This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1493195810;FLINK-5985__This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1495484544;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1495650059;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1502801814;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1503041372;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1503598628;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1504707091;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1506348255;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1507212387;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1507212387;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1509118643;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1511180335;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1513094474;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1513102156;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1515177485;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1515177486;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1515213012;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1515519059;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1516295283;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1516626377;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		_		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocationOnMock) throws Throwable {_				SubtaskState subtaskState = invocationOnMock.getArgumentAt(2, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,on,mock,throws,throwable,subtask,state,subtask,state,invocation,on,mock,get,argument,at,2,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1516626397;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1517489695;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1517489695;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)___		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)___		Environment mockEnvironment = mock(Environment.class)___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1519039284;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironment())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotResult statelessOperatorSnapshotResult = new OperatorSnapshotResult()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,result,stateless,operator,snapshot,result,new,operator,snapshot,result,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1519567828;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironment())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1519568061;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironment())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1525267086;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironment())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1526978549;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1527753190;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1530275453;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgumentAt(4, SubtaskState.class)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,at,4,subtask,state,class,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1538998760;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgument(4)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			nullable(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,4,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,nullable,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1539073077;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgument(4)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			nullable(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,4,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,nullable,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1539073077;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgument(4)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			nullable(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,4,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,nullable,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1539939663;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgument(4)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			nullable(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,4,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,nullable,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1540207709;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgument(4)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			nullable(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,4,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,nullable,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1545300278;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgument(4)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			nullable(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,4,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,nullable,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1550366933;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgument(4)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			nullable(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,4,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,nullable,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception;1550681446;FLINK-5985__<p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This_happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.;@Test_	public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		_		final OneShotLatch checkpointCompletedLatch = new OneShotLatch()__		final List<SubtaskState> checkpointResult = new ArrayList<>(1)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				SubtaskState subtaskState = invocation.getArgument(4)__				checkpointResult.add(subtaskState)__				checkpointCompletedLatch.trigger()__				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			nullable(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> statelessOperator =_				mock(StreamOperator.class)___		final OperatorID operatorID = new OperatorID()__		when(statelessOperator.getOperatorID()).thenReturn(operatorID)___		_		OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures()__		when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class)))_				.thenReturn(statelessOperatorSnapshotResult)___		_		StreamOperator<?>[] streamOperators = {statelessOperator}__		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool())__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())__		checkpointCompletedLatch.await(30, TimeUnit.SECONDS)__		streamTask.cancel()___		_		Assert.assertNull(checkpointResult.get(0))__	};flink,5985,p,this,test,ensures,that,empty,snapshots,no,op,keyed,stated,whatsoever,will,be,reported,as,stateless,tasks,this,happens,by,translating,an,empty,link,subtask,state,into,reporting,null,to,acknowledge,checkpoint;test,public,void,test,empty,subtask,state,leads,to,stateless,acknowledgment,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,environment,mock,environment,spy,new,mock,environment,builder,build,final,one,shot,latch,checkpoint,completed,latch,new,one,shot,latch,final,list,subtask,state,checkpoint,result,new,array,list,1,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,subtask,state,subtask,state,invocation,get,argument,4,checkpoint,result,add,subtask,state,checkpoint,completed,latch,trigger,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,nullable,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stateless,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stateless,operator,get,operator,id,then,return,operator,id,operator,snapshot,futures,stateless,operator,snapshot,result,new,operator,snapshot,futures,when,stateless,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,stateless,operator,snapshot,result,stream,operator,stream,operators,stateless,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,cached,thread,pool,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,checkpoint,completed,latch,await,30,time,unit,seconds,stream,task,cancel,assert,assert,null,checkpoint,result,get,0
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1485189169;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream1 = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)__		CheckpointStreamFactory.CheckpointStateOutputStream outStream2 = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)__		CheckpointStreamFactory.CheckpointStateOutputStream outStream3 = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream1.closeAndGetHandle()).thenReturn(streamStateHandle1)__		when(outStream2.closeAndGetHandle()).thenReturn(streamStateHandle2)__		when(outStream3.closeAndGetHandle()).thenReturn(streamStateHandle3)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(_			outStream1, outStream2, outStream3)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream1,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream2,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream3,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream1,close,and,get,handle,then,return,stream,state,handle1,when,out,stream2,close,and,get,handle,then,return,stream,state,handle2,when,out,stream3,close,and,get,handle,then,return,stream,state,handle3,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream1,out,stream2,out,stream3,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1485544241;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream1 = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)__		CheckpointStreamFactory.CheckpointStateOutputStream outStream2 = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)__		CheckpointStreamFactory.CheckpointStateOutputStream outStream3 = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream1.closeAndGetHandle()).thenReturn(streamStateHandle1)__		when(outStream2.closeAndGetHandle()).thenReturn(streamStateHandle2)__		when(outStream3.closeAndGetHandle()).thenReturn(streamStateHandle3)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(_			outStream1, outStream2, outStream3)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream1,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream2,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream3,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream1,close,and,get,handle,then,return,stream,state,handle1,when,out,stream2,close,and,get,handle,then,return,stream,state,handle2,when,out,stream3,close,and,get,handle,then,return,stream,state,handle3,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream1,out,stream2,out,stream3,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1487167701;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData)___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1487622556;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData)___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1487762095;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData)___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1487783998;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong())).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData)___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1487871589;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1488304933;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1489770896;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1490724328;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1493195810;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1495484544;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1495650059;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1502801814;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1503041372;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator1 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		__		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		_		StreamStateHandle streamStateHandle1 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle2 = mock(StreamStateHandle.class)__		StreamStateHandle streamStateHandle3 = mock(StreamStateHandle.class)___		when(streamOperator1.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle1)__		when(streamOperator2.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle2)__		when(streamOperator3.snapshotLegacyOperatorState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(streamStateHandle3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()___		verify(streamStateHandle1).discardState()__		verify(streamStateHandle2).discardState()__		verify(streamStateHandle3).discardState()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,stream,state,handle,stream,state,handle1,mock,stream,state,handle,class,stream,state,handle,stream,state,handle2,mock,stream,state,handle,class,stream,state,handle,stream,state,handle3,mock,stream,state,handle,class,when,stream,operator1,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle1,when,stream,operator2,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle2,when,stream,operator3,snapshot,legacy,operator,state,any,long,any,long,any,checkpoint,options,class,then,return,stream,state,handle3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel,verify,stream,state,handle1,discard,state,verify,stream,state,handle2,discard,state,verify,stream,state,handle3,discard,state
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1503598628;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1504707091;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1506348255;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1507212387;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1507212387;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1509118643;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1511180335;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1513094474;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1513102156;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1515177485;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1515177486;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1515213012;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1515519059;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1516295283;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1516626377;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1516626397;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1517489695;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1517489695;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1519039284;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironment()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotResult operatorSnapshotResult1 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult2 = mock(OperatorSnapshotResult.class)__		OperatorSnapshotResult operatorSnapshotResult3 = mock(OperatorSnapshotResult.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,result,operator,snapshot,result1,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result2,mock,operator,snapshot,result,class,operator,snapshot,result,operator,snapshot,result3,mock,operator,snapshot,result,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1519567828;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironment()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<OperatorStateHandle> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1519568061;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironment()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1525267086;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironment()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1526978549;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1527753190;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1530275453;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1538998760;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1539073077;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1539073077;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1539939663;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1540207709;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", new DirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1545300278;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", newDirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1550366933;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", newDirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testFailingAsyncCheckpointRunnable() throws Exception;1550681446;Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are_cancelled and all non partitioned state handles are discarded.;@Test_	public void testFailingAsyncCheckpointRunnable() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build()__		StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment))__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		_		StreamOperator<?> streamOperator1 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator2 = mock(StreamOperator.class)__		StreamOperator<?> streamOperator3 = mock(StreamOperator.class)___		_		OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class)__		OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class)___		RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class)__		when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")))___		when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture)___		when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1)__		when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2)__		when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3)___		OperatorID operatorID1 = new OperatorID()__		OperatorID operatorID2 = new OperatorID()__		OperatorID operatorID3 = new OperatorID()__		when(streamOperator1.getOperatorID()).thenReturn(operatorID1)__		when(streamOperator2.getOperatorID()).thenReturn(operatorID2)__		when(streamOperator3.getOperatorID()).thenReturn(operatorID3)___		StreamOperator<?>[] streamOperators = {streamOperator1, streamOperator2, streamOperator3}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", newDirectExecutorService())__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE))___		CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory()__		CheckpointExceptionHandler checkpointExceptionHandler =_			checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment)__		Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler)___		StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler =_			new StreamTask.AsyncCheckpointExceptionHandler(streamTask)__		Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler)___		mockEnvironment.setExpectedExternalFailureCause(Throwable.class)__		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(streamTask).handleAsyncException(anyString(), any(Throwable.class))___		verify(operatorSnapshotResult1).cancel()__		verify(operatorSnapshotResult2).cancel()__		verify(operatorSnapshotResult3).cancel()__	};tests,that,in,case,of,a,failing,async,checkpoint,runnable,all,operator,snapshot,results,are,cancelled,and,all,non,partitioned,state,handles,are,discarded;test,public,void,test,failing,async,checkpoint,runnable,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,mock,environment,mock,environment,new,mock,environment,builder,build,stream,task,stream,task,spy,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator1,mock,stream,operator,class,stream,operator,stream,operator2,mock,stream,operator,class,stream,operator,stream,operator3,mock,stream,operator,class,operator,snapshot,futures,operator,snapshot,result1,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result2,mock,operator,snapshot,futures,class,operator,snapshot,futures,operator,snapshot,result3,mock,operator,snapshot,futures,class,runnable,future,snapshot,result,operator,state,handle,failing,future,mock,runnable,future,class,when,failing,future,get,then,throw,new,execution,exception,new,exception,test,exception,when,operator,snapshot,result3,get,operator,state,raw,future,then,return,failing,future,when,stream,operator1,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result1,when,stream,operator2,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result2,when,stream,operator3,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result3,operator,id,operator,id1,new,operator,id,operator,id,operator,id2,new,operator,id,operator,id,operator,id3,new,operator,id,when,stream,operator1,get,operator,id,then,return,operator,id1,when,stream,operator2,get,operator,id,then,return,operator,id2,when,stream,operator3,get,operator,id,then,return,operator,id3,stream,operator,stream,operators,stream,operator1,stream,operator2,stream,operator3,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,new,direct,executor,service,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,checkpoint,exception,handler,factory,checkpoint,exception,handler,factory,new,checkpoint,exception,handler,factory,checkpoint,exception,handler,checkpoint,exception,handler,checkpoint,exception,handler,factory,create,checkpoint,exception,handler,true,mock,environment,whitebox,set,internal,state,stream,task,synchronous,checkpoint,exception,handler,checkpoint,exception,handler,stream,task,async,checkpoint,exception,handler,async,checkpoint,exception,handler,new,stream,task,async,checkpoint,exception,handler,stream,task,whitebox,set,internal,state,stream,task,asynchronous,checkpoint,exception,handler,async,checkpoint,exception,handler,mock,environment,set,expected,external,failure,cause,throwable,class,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,verify,stream,task,handle,async,exception,any,string,any,throwable,class,verify,operator,snapshot,result1,cancel,verify,operator,snapshot,result2,cancel,verify,operator,snapshot,result3,cancel
StreamTaskTest -> @Test 	public void testEarlyCanceling();1454429510;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling();1455549456;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling();1455716764;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling();1457737669;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling();1463155298;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling();1463939897;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling();1464290120;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling();1467726586;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling();1469529015;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling();1470753725;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() {_		try {_			StreamConfig cfg = new StreamConfig(new Configuration())__			cfg.setStreamOperator(new SlowlyDeserializingOperator())__			_			Task task = createTask(SourceStreamTask.class, cfg)__			task.startTaskThread()__			_			_			while (task.getExecutionState() == ExecutionState.CREATED ||_					task.getExecutionState() == ExecutionState.DEPLOYING)_			{_				Thread.sleep(5)__			}_			_			_			if (task.getExecutionState() != ExecutionState.RUNNING) {_				fail("Task entered state " + task.getExecutionState() + " with error "_						+ ExceptionUtils.stringifyException(task.getFailureCause()))__			}_			_			_			_			task.cancelExecution()__			_			_			assertTrue(task.getExecutionState() == ExecutionState.CANCELING ||_					task.getExecutionState() == ExecutionState.CANCELED)__			_			task.getExecutingThread().join(60000)__			_			assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__			assertEquals(ExecutionState.CANCELED, task.getExecutionState())__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,try,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,task,task,create,task,source,stream,task,class,cfg,task,start,task,thread,while,task,get,execution,state,execution,state,created,task,get,execution,state,execution,state,deploying,thread,sleep,5,if,task,get,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,assert,true,task,get,execution,state,execution,state,canceling,task,get,execution,state,execution,state,canceled,task,get,executing,thread,join,60000,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state,catch,exception,e,e,print,stack,trace,fail,e,get,message
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1472663071;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg)___		ExecutionStateListener executionStateListener = new ExecutionStateListener()___		task.registerExecutionListener(executionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = executionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = executionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,execution,state,listener,execution,state,listener,new,execution,state,listener,task,register,execution,listener,execution,state,listener,task,start,task,thread,future,execution,state,running,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1472663401;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg)___		ExecutionStateListener executionStateListener = new ExecutionStateListener()___		task.registerExecutionListener(executionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = executionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = executionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,execution,state,listener,execution,state,listener,new,execution,state,listener,task,register,execution,listener,execution,state,listener,task,start,task,thread,future,execution,state,running,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1472821521;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg)___		ExecutionStateListener executionStateListener = new ExecutionStateListener()___		task.registerExecutionListener(executionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = executionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = executionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,execution,state,listener,execution,state,listener,new,execution,state,listener,task,register,execution,listener,execution,state,listener,task,start,task,thread,future,execution,state,running,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1473348008;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg)___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1475219249;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg)___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1476122553;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1476972861;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1478534658;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1478707475;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1478800024;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1481560756;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1481730537;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1482522862;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1482522862;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1485189169;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1485544241;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1487167701;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1487622556;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1487762095;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1487783998;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1487871589;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1488304933;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1489770896;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1490724328;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1493195810;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1495484544;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1495650059;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1502801814;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1503041372;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1503598628;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1504707091;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1506348255;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1507212387;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1507212387;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1509118643;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1511180335;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1513094474;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1513102156;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1515177485;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1515177486;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1515213012;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1515519059;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1516295283;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1516626377;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1516626397;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1517489695;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1517489695;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1519039284;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1519567828;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1519568061;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = Await.result(running, deadline.timeLeft())___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = Await.result(canceling, deadline.timeLeft())___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,await,result,running,deadline,time,left,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,await,result,canceling,deadline,time,left,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1525267086;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = Deadline.fromNow(Duration.ofMinutes(2))__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = running.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = canceling.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,deadline,from,now,duration,of,minutes,2,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,running,get,deadline,time,left,to,millis,time,unit,milliseconds,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,canceling,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1526978549;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = Deadline.fromNow(Duration.ofMinutes(2))__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = running.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = canceling.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,deadline,from,now,duration,of,minutes,2,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,running,get,deadline,time,left,to,millis,time,unit,milliseconds,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,canceling,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1527753190;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = Deadline.fromNow(Duration.ofMinutes(2))__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = running.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = canceling.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,deadline,from,now,duration,of,minutes,2,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,running,get,deadline,time,left,to,millis,time,unit,milliseconds,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,canceling,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1530275453;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = Deadline.fromNow(Duration.ofMinutes(2))__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = running.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = canceling.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,deadline,from,now,duration,of,minutes,2,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,running,get,deadline,time,left,to,millis,time,unit,milliseconds,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,canceling,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1538998760;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		Deadline deadline = Deadline.fromNow(Duration.ofMinutes(2))__		StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		Task task = createTask(SourceStreamTask.class, cfg, new Configuration())___		TestingExecutionStateListener testingExecutionStateListener = new TestingExecutionStateListener()___		task.registerExecutionListener(testingExecutionStateListener)__		task.startTaskThread()___		Future<ExecutionState> running = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING)___		_		ExecutionState executionState = running.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		if (executionState != ExecutionState.RUNNING) {_			fail("Task entered state " + task.getExecutionState() + " with error "_					+ ExceptionUtils.stringifyException(task.getFailureCause()))__		}__		_		_		task.cancelExecution()___		Future<ExecutionState> canceling = testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING)___		executionState = canceling.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		assertTrue(executionState == ExecutionState.CANCELING ||_				executionState == ExecutionState.CANCELED)___		task.getExecutingThread().join(deadline.timeLeft().toMillis())___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,deadline,deadline,deadline,from,now,duration,of,minutes,2,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,task,task,create,task,source,stream,task,class,cfg,new,configuration,testing,execution,state,listener,testing,execution,state,listener,new,testing,execution,state,listener,task,register,execution,listener,testing,execution,state,listener,task,start,task,thread,future,execution,state,running,testing,execution,state,listener,notify,when,execution,state,execution,state,running,execution,state,execution,state,running,get,deadline,time,left,to,millis,time,unit,milliseconds,if,execution,state,execution,state,running,fail,task,entered,state,task,get,execution,state,with,error,exception,utils,stringify,exception,task,get,failure,cause,task,cancel,execution,future,execution,state,canceling,testing,execution,state,listener,notify,when,execution,state,execution,state,canceling,execution,state,canceling,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,true,execution,state,execution,state,canceling,execution,state,execution,state,canceled,task,get,executing,thread,join,deadline,time,left,to,millis,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1539073077;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		final StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		final TaskManagerActions taskManagerActions = spy(new NoOpTaskManagerActions())__		final Task task = createTask(SourceStreamTask.class, cfg, new Configuration(), taskManagerActions)___		final TaskExecutionState state = new TaskExecutionState(_			task.getJobID(), task.getExecutionId(), ExecutionState.RUNNING)___		task.startTaskThread()___		verify(taskManagerActions, timeout(2000L)).updateTaskExecutionState(eq(state))___		_		_		task.cancelExecution()___		task.getExecutingThread().join()___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,final,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,final,task,manager,actions,task,manager,actions,spy,new,no,op,task,manager,actions,final,task,task,create,task,source,stream,task,class,cfg,new,configuration,task,manager,actions,final,task,execution,state,state,new,task,execution,state,task,get,job,id,task,get,execution,id,execution,state,running,task,start,task,thread,verify,task,manager,actions,timeout,2000l,update,task,execution,state,eq,state,task,cancel,execution,task,get,executing,thread,join,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1539073077;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		final StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		final TaskManagerActions taskManagerActions = spy(new NoOpTaskManagerActions())__		final Task task = createTask(SourceStreamTask.class, cfg, new Configuration(), taskManagerActions)___		final TaskExecutionState state = new TaskExecutionState(_			task.getJobID(), task.getExecutionId(), ExecutionState.RUNNING)___		task.startTaskThread()___		verify(taskManagerActions, timeout(2000L)).updateTaskExecutionState(eq(state))___		_		_		task.cancelExecution()___		task.getExecutingThread().join()___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,final,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,final,task,manager,actions,task,manager,actions,spy,new,no,op,task,manager,actions,final,task,task,create,task,source,stream,task,class,cfg,new,configuration,task,manager,actions,final,task,execution,state,state,new,task,execution,state,task,get,job,id,task,get,execution,id,execution,state,running,task,start,task,thread,verify,task,manager,actions,timeout,2000l,update,task,execution,state,eq,state,task,cancel,execution,task,get,executing,thread,join,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1539939663;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		final StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		final TaskManagerActions taskManagerActions = spy(new NoOpTaskManagerActions())__		final Task task = createTask(SourceStreamTask.class, cfg, new Configuration(), taskManagerActions)___		final TaskExecutionState state = new TaskExecutionState(_			task.getJobID(), task.getExecutionId(), ExecutionState.RUNNING)___		task.startTaskThread()___		verify(taskManagerActions, timeout(2000L)).updateTaskExecutionState(eq(state))___		_		_		task.cancelExecution()___		task.getExecutingThread().join()___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,final,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,final,task,manager,actions,task,manager,actions,spy,new,no,op,task,manager,actions,final,task,task,create,task,source,stream,task,class,cfg,new,configuration,task,manager,actions,final,task,execution,state,state,new,task,execution,state,task,get,job,id,task,get,execution,id,execution,state,running,task,start,task,thread,verify,task,manager,actions,timeout,2000l,update,task,execution,state,eq,state,task,cancel,execution,task,get,executing,thread,join,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1540207709;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		final StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		final TaskManagerActions taskManagerActions = spy(new NoOpTaskManagerActions())__		final Task task = createTask(SourceStreamTask.class, cfg, new Configuration(), taskManagerActions)___		final TaskExecutionState state = new TaskExecutionState(_			task.getJobID(), task.getExecutionId(), ExecutionState.RUNNING)___		task.startTaskThread()___		verify(taskManagerActions, timeout(2000L)).updateTaskExecutionState(eq(state))___		_		_		task.cancelExecution()___		task.getExecutingThread().join()___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,final,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,final,task,manager,actions,task,manager,actions,spy,new,no,op,task,manager,actions,final,task,task,create,task,source,stream,task,class,cfg,new,configuration,task,manager,actions,final,task,execution,state,state,new,task,execution,state,task,get,job,id,task,get,execution,id,execution,state,running,task,start,task,thread,verify,task,manager,actions,timeout,2000l,update,task,execution,state,eq,state,task,cancel,execution,task,get,executing,thread,join,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1545300278;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		final StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		final TaskManagerActions taskManagerActions = spy(new NoOpTaskManagerActions())__		final Task task = createTask(SourceStreamTask.class, cfg, new Configuration(), taskManagerActions)___		final TaskExecutionState state = new TaskExecutionState(_			task.getJobID(), task.getExecutionId(), ExecutionState.RUNNING)___		task.startTaskThread()___		verify(taskManagerActions, timeout(2000L)).updateTaskExecutionState(eq(state))___		_		_		task.cancelExecution()___		task.getExecutingThread().join()___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,final,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,final,task,manager,actions,task,manager,actions,spy,new,no,op,task,manager,actions,final,task,task,create,task,source,stream,task,class,cfg,new,configuration,task,manager,actions,final,task,execution,state,state,new,task,execution,state,task,get,job,id,task,get,execution,id,execution,state,running,task,start,task,thread,verify,task,manager,actions,timeout,2000l,update,task,execution,state,eq,state,task,cancel,execution,task,get,executing,thread,join,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1550366933;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		final StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		final TaskManagerActions taskManagerActions = spy(new NoOpTaskManagerActions())__		final Task task = createTask(SourceStreamTask.class, cfg, new Configuration(), taskManagerActions)___		final TaskExecutionState state = new TaskExecutionState(_			task.getJobID(), task.getExecutionId(), ExecutionState.RUNNING)___		task.startTaskThread()___		verify(taskManagerActions, timeout(2000L)).updateTaskExecutionState(eq(state))___		_		_		task.cancelExecution()___		task.getExecutingThread().join()___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,final,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,final,task,manager,actions,task,manager,actions,spy,new,no,op,task,manager,actions,final,task,task,create,task,source,stream,task,class,cfg,new,configuration,task,manager,actions,final,task,execution,state,state,new,task,execution,state,task,get,job,id,task,get,execution,id,execution,state,running,task,start,task,thread,verify,task,manager,actions,timeout,2000l,update,task,execution,state,eq,state,task,cancel,execution,task,get,executing,thread,join,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testEarlyCanceling() throws Exception;1550681446;This test checks that cancel calls that are issued before the operator is_instantiated still lead to proper canceling.;@Test_	public void testEarlyCanceling() throws Exception {_		final StreamConfig cfg = new StreamConfig(new Configuration())__		cfg.setOperatorID(new OperatorID(4711L, 42L))__		cfg.setStreamOperator(new SlowlyDeserializingOperator())__		cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime)___		final TaskManagerActions taskManagerActions = spy(new NoOpTaskManagerActions())__		final Task task = createTask(SourceStreamTask.class, cfg, new Configuration(), taskManagerActions)___		final TaskExecutionState state = new TaskExecutionState(_			task.getJobID(), task.getExecutionId(), ExecutionState.RUNNING)___		task.startTaskThread()___		verify(taskManagerActions, timeout(2000L)).updateTaskExecutionState(eq(state))___		_		_		task.cancelExecution()___		task.getExecutingThread().join()___		assertFalse("Task did not cancel", task.getExecutingThread().isAlive())__		assertEquals(ExecutionState.CANCELED, task.getExecutionState())__	};this,test,checks,that,cancel,calls,that,are,issued,before,the,operator,is,instantiated,still,lead,to,proper,canceling;test,public,void,test,early,canceling,throws,exception,final,stream,config,cfg,new,stream,config,new,configuration,cfg,set,operator,id,new,operator,id,4711l,42l,cfg,set,stream,operator,new,slowly,deserializing,operator,cfg,set,time,characteristic,time,characteristic,processing,time,final,task,manager,actions,task,manager,actions,spy,new,no,op,task,manager,actions,final,task,task,create,task,source,stream,task,class,cfg,new,configuration,task,manager,actions,final,task,execution,state,state,new,task,execution,state,task,get,job,id,task,get,execution,id,execution,state,running,task,start,task,thread,verify,task,manager,actions,timeout,2000l,update,task,execution,state,eq,state,task,cancel,execution,task,get,executing,thread,join,assert,false,task,did,not,cancel,task,get,executing,thread,is,alive,assert,equals,execution,state,canceled,task,get,execution,state
StreamTaskTest -> @Test 	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable;1530275453;Test set user code ClassLoader before calling ProcessingTimeCallback.;@Test_	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {_		syncLatch = new OneShotLatch()___		try (MockEnvironment mockEnvironment =_			new MockEnvironmentBuilder()_				.setUserCodeClassLoader(new TestUserCodeClassLoader())_				.build()) {_			TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						timerServiceTask.invoke()__					} catch (Exception e) {_						throw new CompletionException(e)__					}_				},_				TestingUtils.defaultExecutor())___			invokeFuture.get()___			assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1)))__			assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class)))__		}_	};test,set,user,code,class,loader,before,calling,processing,time,callback;test,public,void,test,sets,user,code,class,loader,for,timer,thread,factory,throws,throwable,sync,latch,new,one,shot,latch,try,mock,environment,mock,environment,new,mock,environment,builder,set,user,code,class,loader,new,test,user,code,class,loader,build,time,service,task,timer,service,task,new,time,service,task,mock,environment,completable,future,void,invoke,future,completable,future,run,async,try,timer,service,task,invoke,catch,exception,e,throw,new,completion,exception,e,testing,utils,default,executor,invoke,future,get,assert,that,timer,service,task,get,class,loaders,has,size,greater,than,or,equal,to,1,assert,that,timer,service,task,get,class,loaders,every,item,instance,of,test,user,code,class,loader,class
StreamTaskTest -> @Test 	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable;1538998760;Test set user code ClassLoader before calling ProcessingTimeCallback.;@Test_	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {_		syncLatch = new OneShotLatch()___		try (MockEnvironment mockEnvironment =_			new MockEnvironmentBuilder()_				.setUserCodeClassLoader(new TestUserCodeClassLoader())_				.build()) {_			TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						timerServiceTask.invoke()__					} catch (Exception e) {_						throw new CompletionException(e)__					}_				},_				TestingUtils.defaultExecutor())___			invokeFuture.get()___			assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1)))__			assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class)))__		}_	};test,set,user,code,class,loader,before,calling,processing,time,callback;test,public,void,test,sets,user,code,class,loader,for,timer,thread,factory,throws,throwable,sync,latch,new,one,shot,latch,try,mock,environment,mock,environment,new,mock,environment,builder,set,user,code,class,loader,new,test,user,code,class,loader,build,time,service,task,timer,service,task,new,time,service,task,mock,environment,completable,future,void,invoke,future,completable,future,run,async,try,timer,service,task,invoke,catch,exception,e,throw,new,completion,exception,e,testing,utils,default,executor,invoke,future,get,assert,that,timer,service,task,get,class,loaders,has,size,greater,than,or,equal,to,1,assert,that,timer,service,task,get,class,loaders,every,item,instance,of,test,user,code,class,loader,class
StreamTaskTest -> @Test 	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable;1539073077;Test set user code ClassLoader before calling ProcessingTimeCallback.;@Test_	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {_		syncLatch = new OneShotLatch()___		try (MockEnvironment mockEnvironment =_			new MockEnvironmentBuilder()_				.setUserCodeClassLoader(new TestUserCodeClassLoader())_				.build()) {_			TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						timerServiceTask.invoke()__					} catch (Exception e) {_						throw new CompletionException(e)__					}_				},_				TestingUtils.defaultExecutor())___			invokeFuture.get()___			assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1)))__			assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class)))__		}_	};test,set,user,code,class,loader,before,calling,processing,time,callback;test,public,void,test,sets,user,code,class,loader,for,timer,thread,factory,throws,throwable,sync,latch,new,one,shot,latch,try,mock,environment,mock,environment,new,mock,environment,builder,set,user,code,class,loader,new,test,user,code,class,loader,build,time,service,task,timer,service,task,new,time,service,task,mock,environment,completable,future,void,invoke,future,completable,future,run,async,try,timer,service,task,invoke,catch,exception,e,throw,new,completion,exception,e,testing,utils,default,executor,invoke,future,get,assert,that,timer,service,task,get,class,loaders,has,size,greater,than,or,equal,to,1,assert,that,timer,service,task,get,class,loaders,every,item,instance,of,test,user,code,class,loader,class
StreamTaskTest -> @Test 	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable;1539073077;Test set user code ClassLoader before calling ProcessingTimeCallback.;@Test_	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {_		syncLatch = new OneShotLatch()___		try (MockEnvironment mockEnvironment =_			new MockEnvironmentBuilder()_				.setUserCodeClassLoader(new TestUserCodeClassLoader())_				.build()) {_			TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						timerServiceTask.invoke()__					} catch (Exception e) {_						throw new CompletionException(e)__					}_				},_				TestingUtils.defaultExecutor())___			invokeFuture.get()___			assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1)))__			assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class)))__		}_	};test,set,user,code,class,loader,before,calling,processing,time,callback;test,public,void,test,sets,user,code,class,loader,for,timer,thread,factory,throws,throwable,sync,latch,new,one,shot,latch,try,mock,environment,mock,environment,new,mock,environment,builder,set,user,code,class,loader,new,test,user,code,class,loader,build,time,service,task,timer,service,task,new,time,service,task,mock,environment,completable,future,void,invoke,future,completable,future,run,async,try,timer,service,task,invoke,catch,exception,e,throw,new,completion,exception,e,testing,utils,default,executor,invoke,future,get,assert,that,timer,service,task,get,class,loaders,has,size,greater,than,or,equal,to,1,assert,that,timer,service,task,get,class,loaders,every,item,instance,of,test,user,code,class,loader,class
StreamTaskTest -> @Test 	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable;1539939663;Test set user code ClassLoader before calling ProcessingTimeCallback.;@Test_	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {_		syncLatch = new OneShotLatch()___		try (MockEnvironment mockEnvironment =_			new MockEnvironmentBuilder()_				.setUserCodeClassLoader(new TestUserCodeClassLoader())_				.build()) {_			TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						timerServiceTask.invoke()__					} catch (Exception e) {_						throw new CompletionException(e)__					}_				},_				TestingUtils.defaultExecutor())___			invokeFuture.get()___			assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1)))__			assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class)))__		}_	};test,set,user,code,class,loader,before,calling,processing,time,callback;test,public,void,test,sets,user,code,class,loader,for,timer,thread,factory,throws,throwable,sync,latch,new,one,shot,latch,try,mock,environment,mock,environment,new,mock,environment,builder,set,user,code,class,loader,new,test,user,code,class,loader,build,time,service,task,timer,service,task,new,time,service,task,mock,environment,completable,future,void,invoke,future,completable,future,run,async,try,timer,service,task,invoke,catch,exception,e,throw,new,completion,exception,e,testing,utils,default,executor,invoke,future,get,assert,that,timer,service,task,get,class,loaders,has,size,greater,than,or,equal,to,1,assert,that,timer,service,task,get,class,loaders,every,item,instance,of,test,user,code,class,loader,class
StreamTaskTest -> @Test 	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable;1540207709;Test set user code ClassLoader before calling ProcessingTimeCallback.;@Test_	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {_		syncLatch = new OneShotLatch()___		try (MockEnvironment mockEnvironment =_			new MockEnvironmentBuilder()_				.setUserCodeClassLoader(new TestUserCodeClassLoader())_				.build()) {_			TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						timerServiceTask.invoke()__					} catch (Exception e) {_						throw new CompletionException(e)__					}_				},_				TestingUtils.defaultExecutor())___			invokeFuture.get()___			assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1)))__			assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class)))__		}_	};test,set,user,code,class,loader,before,calling,processing,time,callback;test,public,void,test,sets,user,code,class,loader,for,timer,thread,factory,throws,throwable,sync,latch,new,one,shot,latch,try,mock,environment,mock,environment,new,mock,environment,builder,set,user,code,class,loader,new,test,user,code,class,loader,build,time,service,task,timer,service,task,new,time,service,task,mock,environment,completable,future,void,invoke,future,completable,future,run,async,try,timer,service,task,invoke,catch,exception,e,throw,new,completion,exception,e,testing,utils,default,executor,invoke,future,get,assert,that,timer,service,task,get,class,loaders,has,size,greater,than,or,equal,to,1,assert,that,timer,service,task,get,class,loaders,every,item,instance,of,test,user,code,class,loader,class
StreamTaskTest -> @Test 	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable;1545300278;Test set user code ClassLoader before calling ProcessingTimeCallback.;@Test_	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {_		syncLatch = new OneShotLatch()___		try (MockEnvironment mockEnvironment =_			new MockEnvironmentBuilder()_				.setUserCodeClassLoader(new TestUserCodeClassLoader())_				.build()) {_			TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						timerServiceTask.invoke()__					} catch (Exception e) {_						throw new CompletionException(e)__					}_				},_				TestingUtils.defaultExecutor())___			invokeFuture.get()___			assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1)))__			assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class)))__		}_	};test,set,user,code,class,loader,before,calling,processing,time,callback;test,public,void,test,sets,user,code,class,loader,for,timer,thread,factory,throws,throwable,sync,latch,new,one,shot,latch,try,mock,environment,mock,environment,new,mock,environment,builder,set,user,code,class,loader,new,test,user,code,class,loader,build,time,service,task,timer,service,task,new,time,service,task,mock,environment,completable,future,void,invoke,future,completable,future,run,async,try,timer,service,task,invoke,catch,exception,e,throw,new,completion,exception,e,testing,utils,default,executor,invoke,future,get,assert,that,timer,service,task,get,class,loaders,has,size,greater,than,or,equal,to,1,assert,that,timer,service,task,get,class,loaders,every,item,instance,of,test,user,code,class,loader,class
StreamTaskTest -> @Test 	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable;1550366933;Test set user code ClassLoader before calling ProcessingTimeCallback.;@Test_	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {_		syncLatch = new OneShotLatch()___		try (MockEnvironment mockEnvironment =_			new MockEnvironmentBuilder()_				.setUserCodeClassLoader(new TestUserCodeClassLoader())_				.build()) {_			TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						timerServiceTask.invoke()__					} catch (Exception e) {_						throw new CompletionException(e)__					}_				},_				TestingUtils.defaultExecutor())___			invokeFuture.get()___			assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1)))__			assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class)))__		}_	};test,set,user,code,class,loader,before,calling,processing,time,callback;test,public,void,test,sets,user,code,class,loader,for,timer,thread,factory,throws,throwable,sync,latch,new,one,shot,latch,try,mock,environment,mock,environment,new,mock,environment,builder,set,user,code,class,loader,new,test,user,code,class,loader,build,time,service,task,timer,service,task,new,time,service,task,mock,environment,completable,future,void,invoke,future,completable,future,run,async,try,timer,service,task,invoke,catch,exception,e,throw,new,completion,exception,e,testing,utils,default,executor,invoke,future,get,assert,that,timer,service,task,get,class,loaders,has,size,greater,than,or,equal,to,1,assert,that,timer,service,task,get,class,loaders,every,item,instance,of,test,user,code,class,loader,class
StreamTaskTest -> @Test 	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable;1550681446;Test set user code ClassLoader before calling ProcessingTimeCallback.;@Test_	public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {_		syncLatch = new OneShotLatch()___		try (MockEnvironment mockEnvironment =_			new MockEnvironmentBuilder()_				.setUserCodeClassLoader(new TestUserCodeClassLoader())_				.build()) {_			TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						timerServiceTask.invoke()__					} catch (Exception e) {_						throw new CompletionException(e)__					}_				},_				TestingUtils.defaultExecutor())___			invokeFuture.get()___			assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1)))__			assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class)))__		}_	};test,set,user,code,class,loader,before,calling,processing,time,callback;test,public,void,test,sets,user,code,class,loader,for,timer,thread,factory,throws,throwable,sync,latch,new,one,shot,latch,try,mock,environment,mock,environment,new,mock,environment,builder,set,user,code,class,loader,new,test,user,code,class,loader,build,time,service,task,timer,service,task,new,time,service,task,mock,environment,completable,future,void,invoke,future,completable,future,run,async,try,timer,service,task,invoke,catch,exception,e,throw,new,completion,exception,e,testing,utils,default,executor,invoke,future,get,assert,that,timer,service,task,get,class,loaders,has,size,greater,than,or,equal,to,1,assert,that,timer,service,task,get,class,loaders,every,item,instance,of,test,user,code,class,loader,class
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1485544241;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(any(CheckpointMetaData.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointMetaData), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,checkpoint,meta,data,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,meta,data,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1487167701;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(any(CheckpointMetaData.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointMetaData), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,checkpoint,meta,data,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,meta,data,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1487622556;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(any(CheckpointMetaData.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointMetaData), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,checkpoint,meta,data,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,meta,data,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1487762095;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1487783998;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1487871589;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1488304933;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1489770896;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1490724328;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1493195810;FLINK-5667__Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1495484544;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1495650059;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(SubtaskState.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<SubtaskState> subtaskStateCaptor = ArgumentCaptor.forClass(SubtaskState.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		SubtaskState subtaskState = subtaskStateCaptor.getValue()___		_		assertEquals(managedKeyedStateHandle, subtaskState.getManagedKeyedState())__		assertEquals(rawKeyedStateHandle, subtaskState.getRawKeyedState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(managedOperatorStateHandle)), subtaskState.getManagedOperatorState())__		assertEquals(new ChainedStateHandle<>(Collections.singletonList(rawOperatorStateHandle)), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,subtask,state,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,subtask,state,subtask,state,captor,argument,captor,for,class,subtask,state,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,subtask,state,subtask,state,subtask,state,captor,get,value,assert,equals,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,new,chained,state,handle,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,new,chained,state,handle,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1502801814;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1503041372;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1503598628;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1504707091;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1506348255;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1507212387;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1507212387;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1509118643;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1511180335;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1513094474;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1513102156;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1515177485;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1515177486;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1515213012;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1515519059;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1516295283;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1516626377;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(mockEnvironment).acknowledgeCheckpoint(anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(mockEnvironment).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,mock,environment,acknowledge,checkpoint,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,mock,environment,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1516626397;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1517489695;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1517489695;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,when,mock,environment,get,task,state,manager,then,return,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1519039284;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironment(_			"mock-task",_			1024 * MemoryManager.DEFAULT_PAGE_SIZE,_			null,_			16,_			taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,mock,task,1024,memory,manager,null,16,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1519567828;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStore.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironment(_			"mock-task",_			1024 * MemoryManager.DEFAULT_PAGE_SIZE,_			null,_			16,_			taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(Collections.singletonList(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(Collections.singletonList(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(Collections.singletonList(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(Collections.singletonList(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,mock,task,1024,memory,manager,null,16,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,collections,singleton,list,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,collections,singleton,list,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,collections,singleton,list,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,collections,singleton,list,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1519568061;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironment(_			"mock-task",_			1024 * MemoryManager.DEFAULT_PAGE_SIZE,_			null,_			16,_			taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,mock,task,1024,memory,manager,null,16,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1525267086;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironment(_			"mock-task",_			1024 * MemoryManager.DEFAULT_PAGE_SIZE,_			null,_			16,_			taskStateManager)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,mock,task,1024,memory,manager,null,16,task,state,manager,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1526978549;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1527753190;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1530275453;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1538998760;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1539073077;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1539073077;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1539939663;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1540207709;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1545300278;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1550366933;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception;1550681446;FLINK-5667__<p>Tests that a concurrent cancel operation does not discard the state handles of an_acknowledged checkpoint. The situation can only happen if the cancel call is executed_after Environment.acknowledgeCheckpoint() and before the_CloseableRegistry.unregisterClosable() call.;@Test_	public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch()__		final OneShotLatch completeAcknowledge = new OneShotLatch()___		CheckpointResponder checkpointResponder = mock(CheckpointResponder.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				acknowledgeCheckpointLatch.trigger()___				_				completeAcknowledge.await()___				return null__			}_		}).when(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			anyLong(),_			any(CheckpointMetrics.class),_			any(TaskStateSnapshot.class))___		TaskStateManager taskStateManager = new TaskStateManagerImpl(_			new JobID(1L, 2L),_			new ExecutionAttemptID(1L, 2L),_			mock(TaskLocalStateStoreImpl.class),_			null,_			checkpointResponder)___		MockEnvironment mockEnvironment = new MockEnvironmentBuilder()_			.setTaskName("mock-task")_			.setTaskStateManager(taskStateManager)_			.build()___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		StreamOperator<?> streamOperator = mock(StreamOperator.class)__		when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1))__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		acknowledgeCheckpointLatch.await()___		ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class)___		_		verify(checkpointResponder).acknowledgeCheckpoint(_			any(JobID.class),_			any(ExecutionAttemptID.class),_			eq(checkpointId),_			any(CheckpointMetrics.class),_			subtaskStateCaptor.capture())___		TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue()__		OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue()___		_		assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState())__		assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState())__		assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState())__		assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState())___		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()___		streamTask.cancel()___		completeAcknowledge.trigger()___		_		_		verify(managedKeyedStateHandle, never()).discardState()__		verify(rawKeyedStateHandle, never()).discardState()__		verify(managedOperatorStateHandle, never()).discardState()__		verify(rawOperatorStateHandle, never()).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,does,not,discard,the,state,handles,of,an,acknowledged,checkpoint,the,situation,can,only,happen,if,the,cancel,call,is,executed,after,environment,acknowledge,checkpoint,and,before,the,closeable,registry,unregister,closable,call;test,public,void,test,async,checkpointing,concurrent,close,after,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,acknowledge,checkpoint,latch,new,one,shot,latch,final,one,shot,latch,complete,acknowledge,new,one,shot,latch,checkpoint,responder,checkpoint,responder,mock,checkpoint,responder,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,acknowledge,checkpoint,latch,trigger,complete,acknowledge,await,return,null,when,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,any,long,any,checkpoint,metrics,class,any,task,state,snapshot,class,task,state,manager,task,state,manager,new,task,state,manager,impl,new,job,id,1l,2l,new,execution,attempt,id,1l,2l,mock,task,local,state,store,impl,class,null,checkpoint,responder,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,mock,task,set,task,state,manager,task,state,manager,build,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,operator,stream,operator,mock,stream,operator,class,when,stream,operator,get,operator,id,then,return,new,operator,id,42,42,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,acknowledge,checkpoint,latch,await,argument,captor,task,state,snapshot,subtask,state,captor,argument,captor,for,class,task,state,snapshot,class,verify,checkpoint,responder,acknowledge,checkpoint,any,job,id,class,any,execution,attempt,id,class,eq,checkpoint,id,any,checkpoint,metrics,class,subtask,state,captor,capture,task,state,snapshot,subtask,states,subtask,state,captor,get,value,operator,subtask,state,subtask,state,subtask,states,get,subtask,state,mappings,iterator,next,get,value,assert,equals,state,object,collection,singleton,managed,keyed,state,handle,subtask,state,get,managed,keyed,state,assert,equals,state,object,collection,singleton,raw,keyed,state,handle,subtask,state,get,raw,keyed,state,assert,equals,state,object,collection,singleton,managed,operator,state,handle,subtask,state,get,managed,operator,state,assert,equals,state,object,collection,singleton,raw,operator,state,handle,subtask,state,get,raw,operator,state,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state,stream,task,cancel,complete,acknowledge,trigger,verify,managed,keyed,state,handle,never,discard,state,verify,raw,keyed,state,handle,never,discard,state,verify,managed,operator,state,handle,never,discard,state,verify,raw,operator,state,handle,never,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1485544241;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyGroupsStateHandle)invocation.getArguments()[3],_					(KeyGroupsStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(any(CheckpointMetaData.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,key,groups,state,handle,invocation,get,arguments,3,key,groups,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,any,checkpoint,meta,data,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1487167701;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyGroupsStateHandle)invocation.getArguments()[3],_					(KeyGroupsStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(any(CheckpointMetaData.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,key,groups,state,handle,invocation,get,arguments,3,key,groups,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,any,checkpoint,meta,data,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1487622556;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyGroupsStateHandle)invocation.getArguments()[3],_					(KeyGroupsStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(any(CheckpointMetaData.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,key,groups,state,handle,invocation,get,arguments,3,key,groups,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,any,checkpoint,meta,data,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1487762095;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyGroupsStateHandle)invocation.getArguments()[3],_					(KeyGroupsStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,key,groups,state,handle,invocation,get,arguments,3,key,groups,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1487783998;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyGroupsStateHandle)invocation.getArguments()[3],_					(KeyGroupsStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong())).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData)___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,key,groups,state,handle,invocation,get,arguments,3,key,groups,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1487871589;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyGroupsStateHandle)invocation.getArguments()[3],_					(KeyGroupsStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,key,groups,state,handle,invocation,get,arguments,3,key,groups,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1488304933;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyGroupsStateHandle)invocation.getArguments()[3],_					(KeyGroupsStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,key,groups,state,handle,invocation,get,arguments,3,key,groups,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1489770896;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyGroupsStateHandle)invocation.getArguments()[3],_					(KeyGroupsStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyGroupsStateHandle managedKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		KeyGroupsStateHandle rawKeyedStateHandle = mock(KeyGroupsStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,key,groups,state,handle,invocation,get,arguments,3,key,groups,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,key,groups,state,handle,managed,keyed,state,handle,mock,key,groups,state,handle,class,key,groups,state,handle,raw,keyed,state,handle,mock,key,groups,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1490724328;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyedStateHandle)invocation.getArguments()[3],_					(KeyedStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,keyed,state,handle,invocation,get,arguments,3,keyed,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1493195810;FLINK-5667__Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>)invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>)invocation.getArguments()[2],_					(KeyedStateHandle)invocation.getArguments()[3],_					(KeyedStateHandle)invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,keyed,state,handle,invocation,get,arguments,3,keyed,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1495484544;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>) invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>) invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>) invocation.getArguments()[2],_					(KeyedStateHandle) invocation.getArguments()[3],_					(KeyedStateHandle) invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,keyed,state,handle,invocation,get,arguments,3,keyed,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1495650059;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(SubtaskState.class).withAnyArguments().thenAnswer(new Answer<SubtaskState>() {_			@Override_			public SubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()___				return new SubtaskState(_					(ChainedStateHandle<StreamStateHandle>) invocation.getArguments()[0],_					(ChainedStateHandle<OperatorStateHandle>) invocation.getArguments()[1],_					(ChainedStateHandle<OperatorStateHandle>) invocation.getArguments()[2],_					(KeyedStateHandle) invocation.getArguments()[3],_					(KeyedStateHandle) invocation.getArguments()[4])__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(SubtaskState.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,subtask,state,class,with,any,arguments,then,answer,new,answer,subtask,state,override,public,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,return,new,subtask,state,chained,state,handle,stream,state,handle,invocation,get,arguments,0,chained,state,handle,operator,state,handle,invocation,get,arguments,1,chained,state,handle,operator,state,handle,invocation,get,arguments,2,keyed,state,handle,invocation,get,arguments,3,keyed,state,handle,invocation,get,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,subtask,state,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1502801814;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				any(StreamStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(StreamStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(OperatorStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3],_					(KeyedStateHandle) arguments[4]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,stream,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,stream,state,handle,arguments,0,operator,state,handle,arguments,1,operator,state,handle,arguments,2,keyed,state,handle,arguments,3,keyed,state,handle,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1503041372;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				any(StreamStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(StreamStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(OperatorStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3],_					(KeyedStateHandle) arguments[4]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class, withSettings().extraInterfaces(StreamCheckpointedOperator.class))__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,stream,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,stream,state,handle,arguments,0,operator,state,handle,arguments,1,operator,state,handle,arguments,2,keyed,state,handle,arguments,3,keyed,state,handle,arguments,4,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,with,settings,extra,interfaces,stream,checkpointed,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1503598628;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1504707091;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1506348255;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1507212387;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1507212387;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1509118643;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1511180335;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1513094474;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1513102156;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1515177485;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1515177486;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1515213012;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, AbstractStreamOperator<?>> streamTask = mock(StreamTask.class, Mockito.CALLS_REAL_METHODS)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)__		streamTask.setEnvironment(mockEnvironment)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,abstract,stream,operator,stream,task,mock,stream,task,class,mockito,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,stream,task,set,environment,mock,environment,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1515519059;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1516295283;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1516626377;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1516626397;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1517489695;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		StreamStateHandle streamStateHandle = mock(StreamStateHandle.class)___		CheckpointStreamFactory.CheckpointStateOutputStream outStream = mock(CheckpointStreamFactory.CheckpointStateOutputStream.class)___		when(outStream.closeAndGetHandle()).thenReturn(streamStateHandle)___		CheckpointStreamFactory mockStreamFactory = mock(CheckpointStreamFactory.class)__		when(mockStreamFactory.createCheckpointStateOutputStream(anyLong(), anyLong())).thenReturn(outStream)___		AbstractStateBackend mockStateBackend = mock(AbstractStateBackend.class)__		when(mockStateBackend.createStreamFactory(any(JobID.class), anyString())).thenReturn(mockStreamFactory)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "stateBackend", mockStateBackend)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,stream,state,handle,stream,state,handle,mock,stream,state,handle,class,checkpoint,stream,factory,checkpoint,state,output,stream,out,stream,mock,checkpoint,stream,factory,checkpoint,state,output,stream,class,when,out,stream,close,and,get,handle,then,return,stream,state,handle,checkpoint,stream,factory,mock,stream,factory,mock,checkpoint,stream,factory,class,when,mock,stream,factory,create,checkpoint,state,output,stream,any,long,any,long,then,return,out,stream,abstract,state,backend,mock,state,backend,mock,abstract,state,backend,class,when,mock,state,backend,create,stream,factory,any,job,id,class,any,string,then,return,mock,stream,factory,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,state,backend,mock,state,backend,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1517489695;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		TaskInfo mockTaskInfo = mock(TaskInfo.class)__		when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar")__		when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0)__		Environment mockEnvironment = mock(Environment.class)__		when(mockEnvironment.getTaskInfo()).thenReturn(mockTaskInfo)___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,task,info,mock,task,info,mock,task,info,class,when,mock,task,info,get,task,name,with,subtasks,then,return,foobar,when,mock,task,info,get,index,of,this,subtask,then,return,0,environment,mock,environment,mock,environment,class,when,mock,environment,get,task,info,then,return,mock,task,info,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1519039284;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironment())___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotResult operatorSnapshotResult = new OperatorSnapshotResult(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,result,operator,snapshot,result,new,operator,snapshot,result,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1519567828;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironment())___		whenNew(OperatorSubtaskState.class)._			withArguments(_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(OperatorStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class),_				anyCollectionOf(KeyedStateHandle.class))._			thenAnswer(new Answer<OperatorSubtaskState>() {_				@Override_			public OperatorSubtaskState answer(InvocationOnMock invocation) throws Throwable {_				createSubtask.trigger()__				completeSubtask.await()__				Object[] arguments = invocation.getArguments()__				return new OperatorSubtaskState(_					(OperatorStateHandle) arguments[0],_					(OperatorStateHandle) arguments[1],_					(KeyedStateHandle) arguments[2],_					(KeyedStateHandle) arguments[3]_				)__			}_		})___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			new DoneFuture<>(managedKeyedStateHandle),_			new DoneFuture<>(rawKeyedStateHandle),_			new DoneFuture<>(managedOperatorStateHandle),_			new DoneFuture<>(rawOperatorStateHandle))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,when,new,operator,subtask,state,class,with,arguments,any,collection,of,operator,state,handle,class,any,collection,of,operator,state,handle,class,any,collection,of,keyed,state,handle,class,any,collection,of,keyed,state,handle,class,then,answer,new,answer,operator,subtask,state,override,public,operator,subtask,state,answer,invocation,on,mock,invocation,throws,throwable,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,subtask,state,operator,state,handle,arguments,0,operator,state,handle,arguments,1,keyed,state,handle,arguments,2,keyed,state,handle,arguments,3,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,new,done,future,managed,keyed,state,handle,new,done,future,raw,keyed,state,handle,new,done,future,managed,operator,state,handle,new,done,future,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1519568061;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironment())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1525267086;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironment())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1526978549;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1527753190;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1530275453;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1538998760;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1539073077;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1539073077;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1539939663;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1540207709;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1545300278;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1550366933;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception;1550681446;FLINK-5667__<p>Tests that a concurrent cancel operation discards the state handles of a not yet_acknowledged checkpoint and prevents sending an acknowledge message to the_CheckpointCoordinator. The situation can only happen if the cancel call is executed_before Environment.acknowledgeCheckpoint().;@Test_	public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final OneShotLatch createSubtask = new OneShotLatch()__		final OneShotLatch completeSubtask = new OneShotLatch()___		Environment mockEnvironment = spy(new MockEnvironmentBuilder().build())___		whenNew(OperatorSnapshotFinalizer.class)._			withAnyArguments()._			thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {_					createSubtask.trigger()__					completeSubtask.await()__					Object[] arguments = invocation.getArguments()__					return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0])__				}_			)___		StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment)__		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp)___		final StreamOperator<?> streamOperator = mock(StreamOperator.class)__		final OperatorID operatorID = new OperatorID()__		when(streamOperator.getOperatorID()).thenReturn(operatorID)___		KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class)__		KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class)__		OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class)__		OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class)___		OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(_			DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),_			DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),_			DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)))___		when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult)___		StreamOperator<?>[] streamOperators = {streamOperator}___		OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class)__		when(operatorChain.getAllOperators()).thenReturn(streamOperators)___		CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)___		ExecutorService executor = Executors.newFixedThreadPool(1)___		Whitebox.setInternalState(streamTask, "isRunning", true)__		Whitebox.setInternalState(streamTask, "lock", new Object())__		Whitebox.setInternalState(streamTask, "operatorChain", operatorChain)__		Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry())__		Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor)__		Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration()))__		Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage)___		streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())___		createSubtask.await()___		streamTask.cancel()___		completeSubtask.trigger()___		_		executor.shutdown()___		if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {_			fail("Executor did not shut down within the given timeout. This indicates that the " +_				"checkpointing did not resume.")__		}__		_		verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class))___		_		verify(managedKeyedStateHandle).discardState()__		verify(rawKeyedStateHandle).discardState()__		verify(managedOperatorStateHandle).discardState()__		verify(rawOperatorStateHandle).discardState()__	};flink,5667,p,tests,that,a,concurrent,cancel,operation,discards,the,state,handles,of,a,not,yet,acknowledged,checkpoint,and,prevents,sending,an,acknowledge,message,to,the,checkpoint,coordinator,the,situation,can,only,happen,if,the,cancel,call,is,executed,before,environment,acknowledge,checkpoint;test,public,void,test,async,checkpointing,concurrent,close,before,acknowledge,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,one,shot,latch,create,subtask,new,one,shot,latch,final,one,shot,latch,complete,subtask,new,one,shot,latch,environment,mock,environment,spy,new,mock,environment,builder,build,when,new,operator,snapshot,finalizer,class,with,any,arguments,then,answer,answer,operator,snapshot,finalizer,invocation,create,subtask,trigger,complete,subtask,await,object,arguments,invocation,get,arguments,return,new,operator,snapshot,finalizer,operator,snapshot,futures,arguments,0,stream,task,stream,task,new,empty,stream,task,mock,environment,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,timestamp,final,stream,operator,stream,operator,mock,stream,operator,class,final,operator,id,operator,id,new,operator,id,when,stream,operator,get,operator,id,then,return,operator,id,keyed,state,handle,managed,keyed,state,handle,mock,keyed,state,handle,class,keyed,state,handle,raw,keyed,state,handle,mock,keyed,state,handle,class,operator,state,handle,managed,operator,state,handle,mock,operator,stream,state,handle,class,operator,state,handle,raw,operator,state,handle,mock,operator,stream,state,handle,class,operator,snapshot,futures,operator,snapshot,result,new,operator,snapshot,futures,done,future,of,snapshot,result,of,managed,keyed,state,handle,done,future,of,snapshot,result,of,raw,keyed,state,handle,done,future,of,snapshot,result,of,managed,operator,state,handle,done,future,of,snapshot,result,of,raw,operator,state,handle,when,stream,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,return,operator,snapshot,result,stream,operator,stream,operators,stream,operator,operator,chain,void,abstract,stream,operator,void,operator,chain,mock,operator,chain,class,when,operator,chain,get,all,operators,then,return,stream,operators,checkpoint,storage,checkpoint,storage,new,memory,backend,checkpoint,storage,new,job,id,null,null,integer,executor,service,executor,executors,new,fixed,thread,pool,1,whitebox,set,internal,state,stream,task,is,running,true,whitebox,set,internal,state,stream,task,lock,new,object,whitebox,set,internal,state,stream,task,operator,chain,operator,chain,whitebox,set,internal,state,stream,task,cancelables,new,closeable,registry,whitebox,set,internal,state,stream,task,async,operations,thread,pool,executor,whitebox,set,internal,state,stream,task,configuration,new,stream,config,new,configuration,whitebox,set,internal,state,stream,task,checkpoint,storage,checkpoint,storage,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,create,subtask,await,stream,task,cancel,complete,subtask,trigger,executor,shutdown,if,executor,await,termination,10000l,time,unit,milliseconds,fail,executor,did,not,shut,down,within,the,given,timeout,this,indicates,that,the,checkpointing,did,not,resume,verify,mock,environment,never,acknowledge,checkpoint,eq,checkpoint,id,any,checkpoint,metrics,class,any,task,state,snapshot,class,verify,managed,keyed,state,handle,discard,state,verify,raw,keyed,state,handle,discard,state,verify,managed,operator,state,handle,discard,state,verify,raw,operator,state,handle,discard,state
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1504707091;Tests that the StreamTask first closes alls its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,alls,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1506348255;Tests that the StreamTask first closes alls its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,alls,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1507212387;Tests that the StreamTask first closes alls its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,alls,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1507212387;Tests that the StreamTask first closes alls its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,alls,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1509118643;Tests that the StreamTask first closes alls its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,alls,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1511180335;Tests that the StreamTask first closes alls its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,alls,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1513094474;Tests that the StreamTask first closes alls its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,alls,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1513102156;Tests that the StreamTask first closes alls its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,alls,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1515177485;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1515177486;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		MockEnvironment mockEnvironment = new MockEnvironment(_			"Test Task",_			32L * 1024L,_			new MockInputSplitProvider(),_			1,_			taskConfiguration,_			new ExecutionConfig())__		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_			() -> {_				try {_					streamTask.invoke()__				} catch (Exception e) {_					atomicThrowable.set(e)__				}_			},_			TestingUtils.defaultExecutor())___		BlockingCloseStreamOperator.IN_CLOSE.await()___		_		assertTrue(streamTask.isRunning())___		_		BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___		_		invokeFuture.get()___		_		assertFalse(streamTask.isRunning())___		_		if (atomicThrowable.get() != null) {_			throw atomicThrowable.get()__		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1515213012;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1515519059;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1516295283;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1516626377;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1516626397;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig(),_				new TestTaskStateManager())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,new,test,task,state,manager,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1517489695;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig(),_				new TestTaskStateManager())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,new,test,task,state,manager,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1517489695;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig(),_				new TestTaskStateManager())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,new,test,task,state,manager,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1519039284;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig(),_				new TestTaskStateManager())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,new,test,task,state,manager,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1519567828;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig(),_				new TestTaskStateManager())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,new,test,task,state,manager,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1519568061;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig(),_				new TestTaskStateManager())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,new,test,task,state,manager,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1525267086;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment = new MockEnvironment(_				"Test Task",_				32L * 1024L,_				new MockInputSplitProvider(),_				1,_				taskConfiguration,_				new ExecutionConfig(),_				new TestTaskStateManager())) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,test,task,32l,1024l,new,mock,input,split,provider,1,task,configuration,new,execution,config,new,test,task,state,manager,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1526978549;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1527753190;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1530275453;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1538998760;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1539073077;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1539073077;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1539939663;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1540207709;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1545300278;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1550366933;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
StreamTaskTest -> @Test 	public void testOperatorClosingBeforeStopRunning() throws Throwable;1550681446;Tests that the StreamTask first closes all of its operators before setting its_state to not running (isRunning == false)__<p>See FLINK-7430.;@Test_	public void testOperatorClosingBeforeStopRunning() throws Throwable {_		Configuration taskConfiguration = new Configuration()__		StreamConfig streamConfig = new StreamConfig(taskConfiguration)__		streamConfig.setStreamOperator(new BlockingCloseStreamOperator())__		streamConfig.setOperatorID(new OperatorID())___		try (MockEnvironment mockEnvironment =_				new MockEnvironmentBuilder()_					.setTaskName("Test Task")_					.setMemorySize(32L * 1024L)_					.setInputSplitProvider(new MockInputSplitProvider())_					.setBufferSize(1)_					.setTaskConfiguration(taskConfiguration)_					.build()) {_			StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment)__			final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___			CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(_				() -> {_					try {_						streamTask.invoke()__					} catch (Exception e) {_						atomicThrowable.set(e)__					}_				},_				TestingUtils.defaultExecutor())___			BlockingCloseStreamOperator.IN_CLOSE.await()___			_			assertTrue(streamTask.isRunning())___			_			BlockingCloseStreamOperator.FINISH_CLOSE.trigger()___			_			invokeFuture.get()___			_			assertFalse(streamTask.isRunning())___			_			if (atomicThrowable.get() != null) {_				throw atomicThrowable.get()__			}_		}_	};tests,that,the,stream,task,first,closes,all,of,its,operators,before,setting,its,state,to,not,running,is,running,false,p,see,flink,7430;test,public,void,test,operator,closing,before,stop,running,throws,throwable,configuration,task,configuration,new,configuration,stream,config,stream,config,new,stream,config,task,configuration,stream,config,set,stream,operator,new,blocking,close,stream,operator,stream,config,set,operator,id,new,operator,id,try,mock,environment,mock,environment,new,mock,environment,builder,set,task,name,test,task,set,memory,size,32l,1024l,set,input,split,provider,new,mock,input,split,provider,set,buffer,size,1,set,task,configuration,task,configuration,build,stream,task,void,blocking,close,stream,operator,stream,task,new,no,op,stream,task,mock,environment,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,void,invoke,future,completable,future,run,async,try,stream,task,invoke,catch,exception,e,atomic,throwable,set,e,testing,utils,default,executor,blocking,close,stream,operator,await,assert,true,stream,task,is,running,blocking,close,stream,operator,trigger,invoke,future,get,assert,false,stream,task,is,running,if,atomic,throwable,get,null,throw,atomic,throwable,get
