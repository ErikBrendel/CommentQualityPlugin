commented;modifiers;parameterAmount;loc;comment;code
true;public;0;26;/**  * This test checks that cancel calls that are issued before the operator is  * instantiated still lead to proper canceling.  */ ;/**  * This test checks that cancel calls that are issued before the operator is  * instantiated still lead to proper canceling.  */ @Test public void testEarlyCanceling() throws Exception {     final StreamConfig cfg = new StreamConfig(new Configuration()).     cfg.setOperatorID(new OperatorID(4711L, 42L)).     cfg.setStreamOperator(new SlowlyDeserializingOperator()).     cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime).     final TaskManagerActions taskManagerActions = spy(new NoOpTaskManagerActions()).     final Task task = createTask(SourceStreamTask.class, cfg, new Configuration(), taskManagerActions).     final TaskExecutionState state = new TaskExecutionState(task.getJobID(), task.getExecutionId(), ExecutionState.RUNNING).     task.startTaskThread().     verify(taskManagerActions, timeout(2000L)).updateTaskExecutionState(eq(state)).     // send a cancel. because the operator takes a long time to deserialize, this should     // hit the task before the operator is deserialized     task.cancelExecution().     task.getExecutingThread().join().     assertFalse("Task did not cancel", task.getExecutingThread().isAlive()).     assertEquals(ExecutionState.CANCELED, task.getExecutionState()). }
false;public;0;31;;@Test public void testStateBackendLoadingAndClosing() throws Exception {     Configuration taskManagerConfig = new Configuration().     taskManagerConfig.setString(CheckpointingOptions.STATE_BACKEND, TestMemoryStateBackendFactory.class.getName()).     StreamConfig cfg = new StreamConfig(new Configuration()).     cfg.setStateKeySerializer(mock(TypeSerializer.class)).     cfg.setOperatorID(new OperatorID(4711L, 42L)).     TestStreamSource<Long, MockSourceFunction> streamSource = new TestStreamSource<>(new MockSourceFunction()).     cfg.setStreamOperator(streamSource).     cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime).     Task task = createTask(StateBackendTestSource.class, cfg, taskManagerConfig).     StateBackendTestSource.fail = false.     task.startTaskThread().     // wait for clean termination     task.getExecutingThread().join().     // ensure that the state backends and stream iterables are closed ...     verify(TestStreamSource.operatorStateBackend).close().     verify(TestStreamSource.keyedStateBackend).close().     verify(TestStreamSource.rawOperatorStateInputs).close().     verify(TestStreamSource.rawKeyedStateInputs).close().     // ... and disposed     verify(TestStreamSource.operatorStateBackend).dispose().     verify(TestStreamSource.keyedStateBackend).dispose().     assertEquals(ExecutionState.FINISHED, task.getExecutionState()). }
false;public;0;31;;@Test public void testStateBackendClosingOnFailure() throws Exception {     Configuration taskManagerConfig = new Configuration().     taskManagerConfig.setString(CheckpointingOptions.STATE_BACKEND, TestMemoryStateBackendFactory.class.getName()).     StreamConfig cfg = new StreamConfig(new Configuration()).     cfg.setStateKeySerializer(mock(TypeSerializer.class)).     cfg.setOperatorID(new OperatorID(4711L, 42L)).     TestStreamSource<Long, MockSourceFunction> streamSource = new TestStreamSource<>(new MockSourceFunction()).     cfg.setStreamOperator(streamSource).     cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime).     Task task = createTask(StateBackendTestSource.class, cfg, taskManagerConfig).     StateBackendTestSource.fail = true.     task.startTaskThread().     // wait for clean termination     task.getExecutingThread().join().     // ensure that the state backends and stream iterables are closed ...     verify(TestStreamSource.operatorStateBackend).close().     verify(TestStreamSource.keyedStateBackend).close().     verify(TestStreamSource.rawOperatorStateInputs).close().     verify(TestStreamSource.rawKeyedStateInputs).close().     // ... and disposed     verify(TestStreamSource.operatorStateBackend).dispose().     verify(TestStreamSource.keyedStateBackend).dispose().     assertEquals(ExecutionState.FAILED, task.getExecutionState()). }
false;public;0;19;;@Test public void testCancellationNotBlockedOnLock() throws Exception {     syncLatch = new OneShotLatch().     StreamConfig cfg = new StreamConfig(new Configuration()).     Task task = createTask(CancelLockingTask.class, cfg, new Configuration()).     // start the task and wait until it runs     // execution state RUNNING is not enough, we need to wait until the stream task's run() method     // is entered     task.startTaskThread().     syncLatch.await().     // cancel the execution - this should lead to smooth shutdown     task.cancelExecution().     task.getExecutingThread().join().     assertEquals(ExecutionState.CANCELED, task.getExecutionState()). }
false;public;0;19;;@Test public void testCancellationFailsWithBlockingLock() throws Exception {     syncLatch = new OneShotLatch().     StreamConfig cfg = new StreamConfig(new Configuration()).     Task task = createTask(CancelFailingTask.class, cfg, new Configuration()).     // start the task and wait until it runs     // execution state RUNNING is not enough, we need to wait until the stream task's run() method     // is entered     task.startTaskThread().     syncLatch.await().     // cancel the execution - this should lead to smooth shutdown     task.cancelExecution().     task.getExecutingThread().join().     assertEquals(ExecutionState.CANCELED, task.getExecutionState()). }
false;public;0;68;;@Test public void testFailingCheckpointStreamOperator() throws Exception {     final long checkpointId = 42L.     final long timestamp = 1L.     TaskInfo mockTaskInfo = mock(TaskInfo.class).     when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar").     when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0).     Environment mockEnvironment = new MockEnvironmentBuilder().build().     StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment).     CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp).     // mock the operators     StreamOperator<?> streamOperator1 = mock(StreamOperator.class).     StreamOperator<?> streamOperator2 = mock(StreamOperator.class).     StreamOperator<?> streamOperator3 = mock(StreamOperator.class).     // mock the returned snapshots     OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class).     OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class).     final Exception testException = new Exception("Test exception").     when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1).     when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2).     when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenThrow(testException).     OperatorID operatorID1 = new OperatorID().     OperatorID operatorID2 = new OperatorID().     OperatorID operatorID3 = new OperatorID().     when(streamOperator1.getOperatorID()).thenReturn(operatorID1).     when(streamOperator2.getOperatorID()).thenReturn(operatorID2).     when(streamOperator3.getOperatorID()).thenReturn(operatorID3).     // set up the task     StreamOperator<?>[] streamOperators = { streamOperator1, streamOperator2, streamOperator3 }.     OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class).     when(operatorChain.getAllOperators()).thenReturn(streamOperators).     Whitebox.setInternalState(streamTask, "isRunning", true).     Whitebox.setInternalState(streamTask, "lock", new Object()).     Whitebox.setInternalState(streamTask, "operatorChain", operatorChain).     Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry()).     Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration())).     Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)).     CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory().     CheckpointExceptionHandler checkpointExceptionHandler = checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment).     Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler).     StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler = new StreamTask.AsyncCheckpointExceptionHandler(streamTask).     Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler).     try {         streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation()).         fail("Expected test exception here.").     } catch (Exception e) {         assertEquals(testException, e.getCause()).     }     verify(operatorSnapshotResult1).cancel().     verify(operatorSnapshotResult2).cancel(). }
true;public;0;66;/**  * Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are  * cancelled and all non partitioned state handles are discarded.  */ ;/**  * Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are  * cancelled and all non partitioned state handles are discarded.  */ @Test public void testFailingAsyncCheckpointRunnable() throws Exception {     final long checkpointId = 42L.     final long timestamp = 1L.     MockEnvironment mockEnvironment = new MockEnvironmentBuilder().build().     StreamTask<?, ?> streamTask = spy(new EmptyStreamTask(mockEnvironment)).     CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp).     // mock the operators     StreamOperator<?> streamOperator1 = mock(StreamOperator.class).     StreamOperator<?> streamOperator2 = mock(StreamOperator.class).     StreamOperator<?> streamOperator3 = mock(StreamOperator.class).     // mock the new state operator snapshots     OperatorSnapshotFutures operatorSnapshotResult1 = mock(OperatorSnapshotFutures.class).     OperatorSnapshotFutures operatorSnapshotResult2 = mock(OperatorSnapshotFutures.class).     OperatorSnapshotFutures operatorSnapshotResult3 = mock(OperatorSnapshotFutures.class).     RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture = mock(RunnableFuture.class).     when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception"))).     when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture).     when(streamOperator1.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1).     when(streamOperator2.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2).     when(streamOperator3.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3).     OperatorID operatorID1 = new OperatorID().     OperatorID operatorID2 = new OperatorID().     OperatorID operatorID3 = new OperatorID().     when(streamOperator1.getOperatorID()).thenReturn(operatorID1).     when(streamOperator2.getOperatorID()).thenReturn(operatorID2).     when(streamOperator3.getOperatorID()).thenReturn(operatorID3).     StreamOperator<?>[] streamOperators = { streamOperator1, streamOperator2, streamOperator3 }.     OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class).     when(operatorChain.getAllOperators()).thenReturn(streamOperators).     Whitebox.setInternalState(streamTask, "isRunning", true).     Whitebox.setInternalState(streamTask, "lock", new Object()).     Whitebox.setInternalState(streamTask, "operatorChain", operatorChain).     Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry()).     Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", newDirectExecutorService()).     Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration())).     Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)).     CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory = new CheckpointExceptionHandlerFactory().     CheckpointExceptionHandler checkpointExceptionHandler = checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true, mockEnvironment).     Whitebox.setInternalState(streamTask, "synchronousCheckpointExceptionHandler", checkpointExceptionHandler).     StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler = new StreamTask.AsyncCheckpointExceptionHandler(streamTask).     Whitebox.setInternalState(streamTask, "asynchronousCheckpointExceptionHandler", asyncCheckpointExceptionHandler).     mockEnvironment.setExpectedExternalFailureCause(Throwable.class).     streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation()).     verify(streamTask).handleAsyncException(anyString(), any(Throwable.class)).     verify(operatorSnapshotResult1).cancel().     verify(operatorSnapshotResult2).cancel().     verify(operatorSnapshotResult3).cancel(). }
false;public;1;9;;@Override public Object answer(InvocationOnMock invocation) throws Throwable {     acknowledgeCheckpointLatch.trigger().     // block here so that we can issue the concurrent cancel call     completeAcknowledge.await().     return null. }
true;public;0;112;/**  * FLINK-5667  *  * <p>Tests that a concurrent cancel operation does not discard the state handles of an  * acknowledged checkpoint. The situation can only happen if the cancel call is executed  * after Environment.acknowledgeCheckpoint() and before the  * CloseableRegistry.unregisterClosable() call.  */ ;/**  * FLINK-5667  *  * <p>Tests that a concurrent cancel operation does not discard the state handles of an  * acknowledged checkpoint. The situation can only happen if the cancel call is executed  * after Environment.acknowledgeCheckpoint() and before the  * CloseableRegistry.unregisterClosable() call.  */ @Test public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {     final long checkpointId = 42L.     final long timestamp = 1L.     final OneShotLatch acknowledgeCheckpointLatch = new OneShotLatch().     final OneShotLatch completeAcknowledge = new OneShotLatch().     CheckpointResponder checkpointResponder = mock(CheckpointResponder.class).     doAnswer(new Answer() {          @Override         public Object answer(InvocationOnMock invocation) throws Throwable {             acknowledgeCheckpointLatch.trigger().             // block here so that we can issue the concurrent cancel call             completeAcknowledge.await().             return null.         }     }).when(checkpointResponder).acknowledgeCheckpoint(any(JobID.class), any(ExecutionAttemptID.class), anyLong(), any(CheckpointMetrics.class), any(TaskStateSnapshot.class)).     TaskStateManager taskStateManager = new TaskStateManagerImpl(new JobID(1L, 2L), new ExecutionAttemptID(1L, 2L), mock(TaskLocalStateStoreImpl.class), null, checkpointResponder).     MockEnvironment mockEnvironment = new MockEnvironmentBuilder().setTaskName("mock-task").setTaskStateManager(taskStateManager).build().     StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment).     CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp).     StreamOperator<?> streamOperator = mock(StreamOperator.class).     when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42, 42)).     KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class).     KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class).     OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class).     OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class).     OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)), DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)), DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)), DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle))).     when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult).     StreamOperator<?>[] streamOperators = { streamOperator }.     OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class).     when(operatorChain.getAllOperators()).thenReturn(streamOperators).     CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE).     Whitebox.setInternalState(streamTask, "isRunning", true).     Whitebox.setInternalState(streamTask, "lock", new Object()).     Whitebox.setInternalState(streamTask, "operatorChain", operatorChain).     Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry()).     Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newFixedThreadPool(1)).     Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration())).     Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage).     streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation()).     acknowledgeCheckpointLatch.await().     ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor = ArgumentCaptor.forClass(TaskStateSnapshot.class).     // check that the checkpoint has been completed     verify(checkpointResponder).acknowledgeCheckpoint(any(JobID.class), any(ExecutionAttemptID.class), eq(checkpointId), any(CheckpointMetrics.class), subtaskStateCaptor.capture()).     TaskStateSnapshot subtaskStates = subtaskStateCaptor.getValue().     OperatorSubtaskState subtaskState = subtaskStates.getSubtaskStateMappings().iterator().next().getValue().     // check that the subtask state contains the expected state handles     assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle), subtaskState.getManagedKeyedState()).     assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle), subtaskState.getRawKeyedState()).     assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle), subtaskState.getManagedOperatorState()).     assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle), subtaskState.getRawOperatorState()).     // check that the state handles have not been discarded     verify(managedKeyedStateHandle, never()).discardState().     verify(rawKeyedStateHandle, never()).discardState().     verify(managedOperatorStateHandle, never()).discardState().     verify(rawOperatorStateHandle, never()).discardState().     streamTask.cancel().     completeAcknowledge.trigger().     // canceling the stream task after it has acknowledged the checkpoint should not discard     // the state handles     verify(managedKeyedStateHandle, never()).discardState().     verify(rawKeyedStateHandle, never()).discardState().     verify(managedOperatorStateHandle, never()).discardState().     verify(rawOperatorStateHandle, never()).discardState(). }
true;public;0;82;/**  * FLINK-5667  *  * <p>Tests that a concurrent cancel operation discards the state handles of a not yet  * acknowledged checkpoint and prevents sending an acknowledge message to the  * CheckpointCoordinator. The situation can only happen if the cancel call is executed  * before Environment.acknowledgeCheckpoint().  */ ;/**  * FLINK-5667  *  * <p>Tests that a concurrent cancel operation discards the state handles of a not yet  * acknowledged checkpoint and prevents sending an acknowledge message to the  * CheckpointCoordinator. The situation can only happen if the cancel call is executed  * before Environment.acknowledgeCheckpoint().  */ @Test public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {     final long checkpointId = 42L.     final long timestamp = 1L.     final OneShotLatch createSubtask = new OneShotLatch().     final OneShotLatch completeSubtask = new OneShotLatch().     Environment mockEnvironment = spy(new MockEnvironmentBuilder().build()).     whenNew(OperatorSnapshotFinalizer.class).withAnyArguments().thenAnswer((Answer<OperatorSnapshotFinalizer>) invocation -> {         createSubtask.trigger().         completeSubtask.await().         Object[] arguments = invocation.getArguments().         return new OperatorSnapshotFinalizer((OperatorSnapshotFutures) arguments[0]).     }).     StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment).     CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp).     final StreamOperator<?> streamOperator = mock(StreamOperator.class).     final OperatorID operatorID = new OperatorID().     when(streamOperator.getOperatorID()).thenReturn(operatorID).     KeyedStateHandle managedKeyedStateHandle = mock(KeyedStateHandle.class).     KeyedStateHandle rawKeyedStateHandle = mock(KeyedStateHandle.class).     OperatorStateHandle managedOperatorStateHandle = mock(OperatorStreamStateHandle.class).     OperatorStateHandle rawOperatorStateHandle = mock(OperatorStreamStateHandle.class).     OperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)), DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)), DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)), DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle))).     when(streamOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult).     StreamOperator<?>[] streamOperators = { streamOperator }.     OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class).     when(operatorChain.getAllOperators()).thenReturn(streamOperators).     CheckpointStorage checkpointStorage = new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE).     ExecutorService executor = Executors.newFixedThreadPool(1).     Whitebox.setInternalState(streamTask, "isRunning", true).     Whitebox.setInternalState(streamTask, "lock", new Object()).     Whitebox.setInternalState(streamTask, "operatorChain", operatorChain).     Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry()).     Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", executor).     Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration())).     Whitebox.setInternalState(streamTask, "checkpointStorage", checkpointStorage).     streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation()).     createSubtask.await().     streamTask.cancel().     completeSubtask.trigger().     // wait for the completion of the async task     executor.shutdown().     if (!executor.awaitTermination(10000L, TimeUnit.MILLISECONDS)) {         fail("Executor did not shut down within the given timeout. This indicates that the " + "checkpointing did not resume.").     }     // check that the checkpoint has not been acknowledged     verify(mockEnvironment, never()).acknowledgeCheckpoint(eq(checkpointId), any(CheckpointMetrics.class), any(TaskStateSnapshot.class)).     // check that the state handles have been discarded     verify(managedKeyedStateHandle).discardState().     verify(rawKeyedStateHandle).discardState().     verify(managedOperatorStateHandle).discardState().     verify(rawOperatorStateHandle).discardState(). }
false;public;1;7;;@Override public Object answer(InvocationOnMock invocation) throws Throwable {     SubtaskState subtaskState = invocation.getArgument(4).     checkpointResult.add(subtaskState).     checkpointCompletedLatch.trigger().     return null. }
true;public;0;71;/**  * FLINK-5985  *  * <p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This  * happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.  */ ;/**  * FLINK-5985  *  * <p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This  * happens by translating an empty {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.  */ @Test public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {     final long checkpointId = 42L.     final long timestamp = 1L.     Environment mockEnvironment = spy(new MockEnvironmentBuilder().build()).     // latch blocks until the async checkpoint thread acknowledges     final OneShotLatch checkpointCompletedLatch = new OneShotLatch().     final List<SubtaskState> checkpointResult = new ArrayList<>(1).     CheckpointResponder checkpointResponder = mock(CheckpointResponder.class).     doAnswer(new Answer() {          @Override         public Object answer(InvocationOnMock invocation) throws Throwable {             SubtaskState subtaskState = invocation.getArgument(4).             checkpointResult.add(subtaskState).             checkpointCompletedLatch.trigger().             return null.         }     }).when(checkpointResponder).acknowledgeCheckpoint(any(JobID.class), any(ExecutionAttemptID.class), anyLong(), any(CheckpointMetrics.class), nullable(TaskStateSnapshot.class)).     TaskStateManager taskStateManager = new TaskStateManagerImpl(new JobID(1L, 2L), new ExecutionAttemptID(1L, 2L), mock(TaskLocalStateStoreImpl.class), null, checkpointResponder).     when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager).     StreamTask<?, ?> streamTask = new EmptyStreamTask(mockEnvironment).     CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp).     // mock the operators     StreamOperator<?> statelessOperator = mock(StreamOperator.class).     final OperatorID operatorID = new OperatorID().     when(statelessOperator.getOperatorID()).thenReturn(operatorID).     // mock the returned empty snapshot result (all state handles are null)     OperatorSnapshotFutures statelessOperatorSnapshotResult = new OperatorSnapshotFutures().     when(statelessOperator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenReturn(statelessOperatorSnapshotResult).     // set up the task     StreamOperator<?>[] streamOperators = { statelessOperator }.     OperatorChain<Void, AbstractStreamOperator<Void>> operatorChain = mock(OperatorChain.class).     when(operatorChain.getAllOperators()).thenReturn(streamOperators).     Whitebox.setInternalState(streamTask, "isRunning", true).     Whitebox.setInternalState(streamTask, "lock", new Object()).     Whitebox.setInternalState(streamTask, "operatorChain", operatorChain).     Whitebox.setInternalState(streamTask, "cancelables", new CloseableRegistry()).     Whitebox.setInternalState(streamTask, "configuration", new StreamConfig(new Configuration())).     Whitebox.setInternalState(streamTask, "asyncOperationsThreadPool", Executors.newCachedThreadPool()).     Whitebox.setInternalState(streamTask, "checkpointStorage", new MemoryBackendCheckpointStorage(new JobID(), null, null, Integer.MAX_VALUE)).     streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation()).     checkpointCompletedLatch.await(30, TimeUnit.SECONDS).     streamTask.cancel().     // ensure that 'null' was acknowledged as subtask state     Assert.assertNull(checkpointResult.get(0)). }
true;public;0;48;/**  * Tests that the StreamTask first closes all of its operators before setting its  * state to not running (isRunning == false)  *  * <p>See FLINK-7430.  */ ;/**  * Tests that the StreamTask first closes all of its operators before setting its  * state to not running (isRunning == false)  *  * <p>See FLINK-7430.  */ @Test public void testOperatorClosingBeforeStopRunning() throws Throwable {     Configuration taskConfiguration = new Configuration().     StreamConfig streamConfig = new StreamConfig(taskConfiguration).     streamConfig.setStreamOperator(new BlockingCloseStreamOperator()).     streamConfig.setOperatorID(new OperatorID()).     try (MockEnvironment mockEnvironment = new MockEnvironmentBuilder().setTaskName("Test Task").setMemorySize(32L * 1024L).setInputSplitProvider(new MockInputSplitProvider()).setBufferSize(1).setTaskConfiguration(taskConfiguration).build()) {         StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment).         final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null).         CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(() -> {             try {                 streamTask.invoke().             } catch (Exception e) {                 atomicThrowable.set(e).             }         }, TestingUtils.defaultExecutor()).         BlockingCloseStreamOperator.IN_CLOSE.await().         // check that the StreamTask is not yet in isRunning == false         assertTrue(streamTask.isRunning()).         // let the operator finish its close operation         BlockingCloseStreamOperator.FINISH_CLOSE.trigger().         // wait until the invoke is complete         invokeFuture.get().         // now the StreamTask should no longer be running         assertFalse(streamTask.isRunning()).         // check if an exception occurred         if (atomicThrowable.get() != null) {             throw atomicThrowable.get().         }     } }
true;public;0;26;/**  * Test set user code ClassLoader before calling ProcessingTimeCallback.  */ ;/**  * Test set user code ClassLoader before calling ProcessingTimeCallback.  */ @Test public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {     syncLatch = new OneShotLatch().     try (MockEnvironment mockEnvironment = new MockEnvironmentBuilder().setUserCodeClassLoader(new TestUserCodeClassLoader()).build()) {         TimeServiceTask timerServiceTask = new TimeServiceTask(mockEnvironment).         CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(() -> {             try {                 timerServiceTask.invoke().             } catch (Exception e) {                 throw new CompletionException(e).             }         }, TestingUtils.defaultExecutor()).         invokeFuture.get().         assertThat(timerServiceTask.getClassLoaders(), hasSize(greaterThanOrEqualTo(1))).         assertThat(timerServiceTask.getClassLoaders(), everyItem(instanceOf(TestUserCodeClassLoader.class))).     } }
false;protected;0;2;;@Override protected void init() throws Exception { }
false;protected;0;2;;@Override protected void run() throws Exception { }
false;protected;0;2;;@Override protected void cleanup() throws Exception { }
false;protected;0;2;;@Override protected void cancelTask() throws Exception { }
false;public;0;6;;@Override public void close() throws Exception {     IN_CLOSE.trigger().     FINISH_CLOSE.await().     super.close(). }
false;public,static;3;6;;public static Task createTask(Class<? extends AbstractInvokable> invokable, StreamConfig taskConfig, Configuration taskManagerConfig) throws Exception {     return createTask(invokable, taskConfig, taskManagerConfig, new TestTaskStateManager(), mock(TaskManagerActions.class)). }
false;public,static;4;7;;public static Task createTask(Class<? extends AbstractInvokable> invokable, StreamConfig taskConfig, Configuration taskManagerConfig, TaskManagerActions taskManagerActions) throws Exception {     return createTask(invokable, taskConfig, taskManagerConfig, new TestTaskStateManager(), taskManagerActions). }
false;public,static;5;70;;public static Task createTask(Class<? extends AbstractInvokable> invokable, StreamConfig taskConfig, Configuration taskManagerConfig, TestTaskStateManager taskStateManager, TaskManagerActions taskManagerActions) throws Exception {     BlobCacheService blobService = new BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class)).     LibraryCacheManager libCache = mock(LibraryCacheManager.class).     when(libCache.getClassLoader(any(JobID.class))).thenReturn(StreamTaskTest.class.getClassLoader()).     ResultPartitionManager partitionManager = mock(ResultPartitionManager.class).     ResultPartitionConsumableNotifier consumableNotifier = new NoOpResultPartitionConsumableNotifier().     PartitionProducerStateChecker partitionProducerStateChecker = mock(PartitionProducerStateChecker.class).     Executor executor = mock(Executor.class).     TaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher().     NetworkEnvironment network = mock(NetworkEnvironment.class).     when(network.getResultPartitionManager()).thenReturn(partitionManager).     when(network.getDefaultIOMode()).thenReturn(IOManager.IOMode.SYNC).     when(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class)).     when(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher).     JobInformation jobInformation = new JobInformation(new JobID(), "Job Name", new SerializedValue<>(new ExecutionConfig()), new Configuration(), Collections.emptyList(), Collections.emptyList()).     TaskInformation taskInformation = new TaskInformation(new JobVertexID(), "Test Task", 1, 1, invokable.getName(), taskConfig.getConfiguration()).     return new Task(jobInformation, taskInformation, new ExecutionAttemptID(), new AllocationID(), 0, 0, Collections.<ResultPartitionDeploymentDescriptor>emptyList(), Collections.<InputGateDeploymentDescriptor>emptyList(), 0, mock(MemoryManager.class), mock(IOManager.class), network, mock(BroadcastVariableManager.class), taskStateManager, taskManagerActions, mock(InputSplitProvider.class), mock(CheckpointResponder.class), new TestGlobalAggregateManager(), blobService, libCache, mock(FileCache.class), new TestingTaskManagerRuntimeInfo(taskManagerConfig, new String[] { System.getProperty("java.io.tmpdir") }), UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(), consumableNotifier, partitionProducerStateChecker, executor). }
false;public;3;10;;@Override public void run(Object lockingObject, StreamStatusMaintainer streamStatusMaintainer, Output<StreamRecord<Long>> collector) throws Exception {     while (!canceled) {         try {             Thread.sleep(500).         } catch (InterruptedException ignored) {         }     } }
false;public;0;4;;@Override public void cancel() {     canceled = true. }
true;private;1;11;// slow deserialization ;// slow deserialization private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {     in.defaultReadObject().     long delay = 500.     long deadline = System.currentTimeMillis() + delay.     do {         try {             Thread.sleep(delay).         } catch (InterruptedException ignored) {         }     } while ((delay = deadline - System.currentTimeMillis()) > 0). }
false;public;1;2;;@Override public void run(SourceContext<Long> ctx) { }
false;public;0;2;;@Override public void cancel() { }
false;public;2;4;;@Override public AbstractStateBackend createFromConfig(Configuration config, ClassLoader classLoader) {     return new TestSpyWrapperStateBackend(createInnerBackend(config)). }
false;protected;1;3;;protected AbstractStateBackend createInnerBackend(Configuration config) {     return new MemoryStateBackend(). }
false;protected;0;2;;@Override protected void init() throws Exception { }
false;protected;0;2;;@Override protected void run() throws Exception { }
false;protected;0;2;;@Override protected void cleanup() throws Exception { }
false;protected;0;2;;@Override protected void cancelTask() throws Exception { }
false;protected;0;4;;@Override protected void init() throws Exception { }
false;protected;0;6;;@Override protected void run() throws Exception {     if (fail) {         throw new RuntimeException().     } }
false;protected;0;2;;@Override protected void cleanup() throws Exception { }
false;protected;0;2;;@Override protected void cancelTask() throws Exception { }
false;public;0;4;;@Override public boolean isRestored() {     return context.isRestored(). }
false;public;0;4;;@Override public OperatorStateBackend operatorStateBackend() {     return context.operatorStateBackend(). }
false;public;0;4;;@Override public AbstractKeyedStateBackend<?> keyedStateBackend() {     return context.keyedStateBackend(). }
false;public;0;5;;@Override public InternalTimeServiceManager<?> internalTimerServiceManager() {     InternalTimeServiceManager<?> timeServiceManager = context.internalTimerServiceManager().     return timeServiceManager != null ? spy(timeServiceManager) : null. }
false;public;0;4;;@Override public CloseableIterable<StatePartitionStreamProvider> rawOperatorStateInputs() {     return replaceWithSpy(context.rawOperatorStateInputs()). }
false;public;0;4;;@Override public CloseableIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStateInputs() {     return replaceWithSpy(context.rawKeyedStateInputs()). }
false;public;1;11;;public <T extends Closeable> T replaceWithSpy(T closeable) {     T spyCloseable = spy(closeable).     if (closeableRegistry.unregisterCloseable(closeable)) {         try {             closeableRegistry.registerCloseable(spyCloseable).         } catch (IOException e) {             throw new RuntimeException(e).         }     }     return spyCloseable. }
false;public;0;59;;@Override public StreamTaskStateInitializer createStreamTaskStateInitializer() {     final StreamTaskStateInitializer streamTaskStateManager = super.createStreamTaskStateInitializer().     return (operatorID, operatorClassName, keyContext, keySerializer, closeableRegistry, metricGroup) -> {         final StreamOperatorStateContext context = streamTaskStateManager.streamOperatorStateContext(operatorID, operatorClassName, keyContext, keySerializer, closeableRegistry, metricGroup).         return new StreamOperatorStateContext() {              @Override             public boolean isRestored() {                 return context.isRestored().             }              @Override             public OperatorStateBackend operatorStateBackend() {                 return context.operatorStateBackend().             }              @Override             public AbstractKeyedStateBackend<?> keyedStateBackend() {                 return context.keyedStateBackend().             }              @Override             public InternalTimeServiceManager<?> internalTimerServiceManager() {                 InternalTimeServiceManager<?> timeServiceManager = context.internalTimerServiceManager().                 return timeServiceManager != null ? spy(timeServiceManager) : null.             }              @Override             public CloseableIterable<StatePartitionStreamProvider> rawOperatorStateInputs() {                 return replaceWithSpy(context.rawOperatorStateInputs()).             }              @Override             public CloseableIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStateInputs() {                 return replaceWithSpy(context.rawKeyedStateInputs()).             }              public <T extends Closeable> T replaceWithSpy(T closeable) {                 T spyCloseable = spy(closeable).                 if (closeableRegistry.unregisterCloseable(closeable)) {                     try {                         closeableRegistry.registerCloseable(spyCloseable).                     } catch (IOException e) {                         throw new RuntimeException(e).                     }                 }                 return spyCloseable.             }         }.     }. }
false;protected;0;2;;@Override protected void init() { }
false;protected;0;17;;@Override protected void run() throws Exception {     holder = new LockHolder(getCheckpointLock(), latch).     holder.start().     latch.await().     // we are at the point where cancelling can happen     syncLatch.trigger().     // just put this to sleep until it is interrupted     try {         Thread.sleep(100000000).     } catch (InterruptedException ignored) {         // restore interruption state         Thread.currentThread().interrupt().     } }
false;protected;0;4;;@Override protected void cleanup() {     holder.close(). }
false;protected;0;6;;@Override protected void cancelTask() {     holder.cancel(). // do not interrupt the lock holder here, to simulate spawned threads that // we cannot properly interrupt on cancellation }
false;protected;0;2;;@Override protected void init() { }
false;protected;0;29;;@Override protected void run() throws Exception {     final OneShotLatch latch = new OneShotLatch().     final Object lock = new Object().     LockHolder holder = new LockHolder(lock, latch).     holder.start().     try {         // cancellation should try and cancel this         getCancelables().registerCloseable(holder).         // wait till the lock holder has the lock         latch.await().         // we are at the point where cancelling can happen         syncLatch.trigger().         // noinspection SynchronizationOnLocalVariableOrMethodParameter         synchronized (lock) {         // nothing         }     } finally {         holder.close().     } }
false;protected;0;2;;@Override protected void cleanup() { }
false;protected;0;4;;@Override protected void cancelTask() throws Exception {     throw new Exception("test exception"). }
false;public;0;3;;public List<ClassLoader> getClassLoaders() {     return classLoaders. }
false;public;1;5;;@Override public void onProcessingTime(long timestamp) throws Exception {     classLoaders.add(Thread.currentThread().getContextClassLoader()).     syncLatch.trigger(). }
false;protected;0;10;;@Override protected void init() throws Exception {     getProcessingTimeService().registerTimer(0, new ProcessingTimeCallback() {          @Override         public void onProcessingTime(long timestamp) throws Exception {             classLoaders.add(Thread.currentThread().getContextClassLoader()).             syncLatch.trigger().         }     }). }
false;protected;0;4;;@Override protected void run() throws Exception {     syncLatch.await(). }
false;protected;0;4;;@Override protected void cleanup() throws Exception { }
false;protected;0;4;;@Override protected void cancelTask() throws Exception { }
false;public;0;15;;@Override public void run() {     synchronized (lock) {         while (!canceled) {             // signal that we grabbed the lock             trigger.trigger().             // basically freeze this thread             try {                 // noinspection SleepWhileHoldingLock                 Thread.sleep(1000000000).             } catch (InterruptedException ignored) {             }         }     } }
false;public;0;3;;public void cancel() {     canceled = true. }
false;public;0;5;;@Override public void close() {     canceled = true.     interrupt(). }
false;public;1;10;;@Override public void initializeState(StateInitializationContext context) throws Exception {     keyedStateBackend = (AbstractKeyedStateBackend<?>) getKeyedStateBackend().     operatorStateBackend = getOperatorStateBackend().     rawOperatorStateInputs = (CloseableIterable<StatePartitionStreamProvider>) context.getRawOperatorStateInputs().     rawKeyedStateInputs = (CloseableIterable<KeyGroupStatePartitionStreamProvider>) context.getRawKeyedStateInputs().     super.initializeState(context). }
