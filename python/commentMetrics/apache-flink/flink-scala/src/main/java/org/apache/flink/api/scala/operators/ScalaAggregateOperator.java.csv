commented;modifiers;parameterAmount;loc;comment;code
false;public;2;17;;public ScalaAggregateOperator<IN> and(Aggregations function, int field) {     Preconditions.checkNotNull(function).     TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) getType().     if (field < 0 || field >= inType.getArity()) {         throw new IllegalArgumentException("Aggregation field position is out of range.").     }     AggregationFunctionFactory factory = function.getFactory().     AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass()).     this.aggregationFunctions.add(aggFunct).     this.fields.add(field).     return this. }
false;protected;1;87;;@SuppressWarnings("unchecked") @Override protected org.apache.flink.api.common.operators.base.GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>> translateToDataFlow(Operator<IN> input) {     // sanity check     if (this.aggregationFunctions.isEmpty() || this.aggregationFunctions.size() != this.fields.size()) {         throw new IllegalStateException().     }     // construct the aggregation function     AggregationFunction<Object>[] aggFunctions = new AggregationFunction[this.aggregationFunctions.size()].     int[] fields = new int[this.fields.size()].     StringBuilder genName = new StringBuilder().     for (int i = 0. i < fields.length. i++) {         aggFunctions[i] = (AggregationFunction<Object>) this.aggregationFunctions.get(i).         fields[i] = this.fields.get(i).         genName.append(aggFunctions[i].toString()).append('(').append(fields[i]).append(')').append(',').     }     genName.setLength(genName.length() - 1).     @SuppressWarnings("rawtypes")     RichGroupReduceFunction<IN, IN> function = new AggregatingUdf(getInputType(), aggFunctions, fields).     String name = getName() != null ? getName() : genName.toString().     // distinguish between grouped reduce and non-grouped reduce     if (this.grouping == null) {         // non grouped aggregation         UnaryOperatorInformation<IN, IN> operatorInfo = new UnaryOperatorInformation<>(getInputType(), getResultType()).         GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>> po = new GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>>(function, operatorInfo, new int[0], name).         po.setCombinable(true).         // set input         po.setInput(input).         // set parallelism         po.setParallelism(this.getParallelism()).         return po.     }     if (this.grouping.getKeys() instanceof Keys.ExpressionKeys) {         // grouped aggregation         int[] logicalKeyPositions = this.grouping.getKeys().computeLogicalKeyPositions().         UnaryOperatorInformation<IN, IN> operatorInfo = new UnaryOperatorInformation<>(getInputType(), getResultType()).         GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>> po = new GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>>(function, operatorInfo, logicalKeyPositions, name).         po.setCombinable(true).         // set input         po.setInput(input).         // set parallelism         po.setParallelism(this.getParallelism()).         SingleInputSemanticProperties props = new SingleInputSemanticProperties().         for (int keyField : logicalKeyPositions) {             boolean keyFieldUsedInAgg = false.             for (int aggField : fields) {                 if (keyField == aggField) {                     keyFieldUsedInAgg = true.                     break.                 }             }             if (!keyFieldUsedInAgg) {                 props.addForwardedField(keyField, keyField).             }         }         po.setSemanticProperties(props).         po.setCustomPartitioner(grouping.getCustomPartitioner()).         return po.     } else if (this.grouping.getKeys() instanceof Keys.SelectorFunctionKeys) {         throw new UnsupportedOperationException("Aggregate does not support grouping with KeySelector functions, yet.").     } else {         throw new UnsupportedOperationException("Unrecognized key type.").     } }
false;public;1;7;;@Override public void open(Configuration parameters) throws Exception {     for (AggregationFunction<Object> aggFunction : aggFunctions) {         aggFunction.initializeAggregate().     }     this.serializer = (TupleSerializerBase<T>) typeInfo.createSerializer(getRuntimeContext().getExecutionConfig()). }
false;public;2;32;;@Override public void reduce(Iterable<T> records, Collector<T> out) {     final AggregationFunction<Object>[] aggFunctions = this.aggFunctions.     final int[] fieldPositions = this.fieldPositions.     // aggregators are initialized from before     T current = null.     for (T record : records) {         current = record.         for (int i = 0. i < fieldPositions.length. i++) {             Object val = current.productElement(fieldPositions[i]).             aggFunctions[i].aggregate(val).         }     }     Object[] fields = new Object[serializer.getArity()].     int length = serializer.getArity().     // First copy all tuple fields, then overwrite the aggregated ones     for (int i = 0. i < length. i++) {         fields[i] = current.productElement(i).     }     for (int i = 0. i < fieldPositions.length. i++) {         Object aggVal = aggFunctions[i].getAggregate().         fields[fieldPositions[i]] = aggVal.         aggFunctions[i].initializeAggregate().     }     T result = serializer.createInstance(fields).     out.collect(result). }
false;public;2;4;;@Override public void combine(Iterable<T> records, Collector<T> out) {     reduce(records, out). }
