commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;10;;@Parameterized.Parameters(name = "Migration Savepoint / Mod Time: {0}") public static Collection<Tuple2<MigrationVersion, Long>> parameters() {     return Arrays.asList(Tuple2.of(MigrationVersion.v1_2, 1493116191000L), Tuple2.of(MigrationVersion.v1_3, 1496532000000L), Tuple2.of(MigrationVersion.v1_4, 1516897628000L), Tuple2.of(MigrationVersion.v1_5, 1533639934000L), Tuple2.of(MigrationVersion.v1_6, 1534696817000L), Tuple2.of(MigrationVersion.v1_7, 1544024599000L)). }
false;public,static;0;4;;@BeforeClass public static void verifyOS() {     Assume.assumeTrue("HDFS cluster cannot be start on Windows without extensions.", !OperatingSystem.isWindows()). }
true;public;0;47;/**  * Manually run this to write binary snapshot data. Remove @Ignore to run.  */ ;/**  * Manually run this to write binary snapshot data. Remove @Ignore to run.  */ @Ignore @Test public void writeReaderSnapshot() throws Exception {     File testFolder = tempFolder.newFolder().     TimestampedFileInputSplit split1 = new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null).     TimestampedFileInputSplit split2 = new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null).     TimestampedFileInputSplit split3 = new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null).     TimestampedFileInputSplit split4 = new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null).     // this always blocks to ensure that the reader doesn't to any actual processing so that     // we keep the state for the four splits     final OneShotLatch blockingLatch = new OneShotLatch().     BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath())).     TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format).     ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(format).     initReader.setOutputType(typeInfo, new ExecutionConfig()).     OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness = new OneInputStreamOperatorTestHarness<>(initReader).     testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime).     testHarness.open().     // create some state in the reader     testHarness.processElement(new StreamRecord<>(split1)).     testHarness.processElement(new StreamRecord<>(split2)).     testHarness.processElement(new StreamRecord<>(split3)).     testHarness.processElement(new StreamRecord<>(split4)).     // take a snapshot of the operator's state. This will be used     // to initialize another reader and compare the results of the     // two operators.     final OperatorSubtaskState snapshot.     synchronized (testHarness.getCheckpointLock()) {         snapshot = testHarness.snapshot(0L, 0L).     }     OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot"). }
false;public;0;52;;@Test public void testReaderRestore() throws Exception {     File testFolder = tempFolder.newFolder().     final OneShotLatch latch = new OneShotLatch().     BlockingFileInputFormat format = new BlockingFileInputFormat(latch, new Path(testFolder.getAbsolutePath())).     TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format).     ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(format).     initReader.setOutputType(typeInfo, new ExecutionConfig()).     OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness = new OneInputStreamOperatorTestHarness<>(initReader).     testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("reader-migration-test-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     latch.trigger().     synchronized (testHarness.getCheckpointLock()) {         testHarness.close().     }     TimestampedFileInputSplit split1 = new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null).     TimestampedFileInputSplit split2 = new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null).     TimestampedFileInputSplit split3 = new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null).     TimestampedFileInputSplit split4 = new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null).     // compare if the results contain what they should contain and also if     // they are the same, as they should.     Assert.assertTrue(testHarness.getOutput().contains(new StreamRecord<>(split1))).     Assert.assertTrue(testHarness.getOutput().contains(new StreamRecord<>(split2))).     Assert.assertTrue(testHarness.getOutput().contains(new StreamRecord<>(split3))).     Assert.assertTrue(testHarness.getOutput().contains(new StreamRecord<>(split4))). }
false;public;1;4;;@Override public void collect(TimestampedFileInputSplit element) {     latch.trigger(). }
false;public;0;4;;@Override public void markAsTemporarilyIdle() { }
false;public;0;20;;@Override public void run() {     try {         monitoringFunction.run(new DummySourceContext() {              @Override             public void collect(TimestampedFileInputSplit element) {                 latch.trigger().             }              @Override             public void markAsTemporarilyIdle() {             }         }).     } catch (Throwable t) {         t.printStackTrace().         error[0] = t.     } }
true;public;0;72;/**  * Manually run this to write binary snapshot data. Remove @Ignore to run.  */ ;/**  * Manually run this to write binary snapshot data. Remove @Ignore to run.  */ @Ignore @Test public void writeMonitoringSourceSnapshot() throws Exception {     File testFolder = tempFolder.newFolder().     long fileModTime = Long.MIN_VALUE.     for (int i = 0. i < 1. i++) {         Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.").         fileModTime = file.f0.lastModified().     }     TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath())).     final ContinuousFileMonitoringFunction<String> monitoringFunction = new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL).     StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src = new StreamSource<>(monitoringFunction).     final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness = new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0).     testHarness.open().     final Throwable[] error = new Throwable[1].     final OneShotLatch latch = new OneShotLatch().     // run the source asynchronously     Thread runner = new Thread() {          @Override         public void run() {             try {                 monitoringFunction.run(new DummySourceContext() {                      @Override                     public void collect(TimestampedFileInputSplit element) {                         latch.trigger().                     }                      @Override                     public void markAsTemporarilyIdle() {                     }                 }).             } catch (Throwable t) {                 t.printStackTrace().                 error[0] = t.             }         }     }.     runner.start().     if (!latch.isTriggered()) {         latch.await().     }     final OperatorSubtaskState snapshot.     synchronized (testHarness.getCheckpointLock()) {         snapshot = testHarness.snapshot(0L, 0L).     }     OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot").     monitoringFunction.cancel().     runner.join().     testHarness.close(). }
false;public;0;27;;@Test public void testMonitoringSourceRestore() throws Exception {     File testFolder = tempFolder.newFolder().     TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath())).     final ContinuousFileMonitoringFunction<String> monitoringFunction = new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL).     StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src = new StreamSource<>(monitoringFunction).     final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness = new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("monitoring-function-migration-test-" + expectedModTime + "-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     Assert.assertEquals((long) expectedModTime, monitoringFunction.getGlobalModificationTime()). }
false;public;1;5;;@Override public void open(FileInputSplit fileSplit) throws IOException {     this.split = fileSplit.     this.reachedEnd = false. }
false;public;0;11;;@Override public boolean reachedEnd() throws IOException {     if (!latch.isTriggered()) {         try {             latch.await().         } catch (InterruptedException e) {             e.printStackTrace().         }     }     return reachedEnd. }
false;public;1;5;;@Override public FileInputSplit nextRecord(FileInputSplit reuse) throws IOException {     this.reachedEnd = true.     return split. }
false;public;0;4;;@Override public void close() { }
false;public;2;3;;@Override public void collectWithTimestamp(TimestampedFileInputSplit element, long timestamp) { }
false;public;1;3;;@Override public void emitWatermark(Watermark mark) { }
false;public;0;4;;@Override public Object getCheckpointLock() {     return lock. }
false;public;0;3;;@Override public void close() { }
true;private;4;21;/**  * Create a file with pre-determined String format of the form:  * {@code fileIdx +": "+ sampleLine +" "+ lineNo}.  */ ;/**  * Create a file with pre-determined String format of the form:  * {@code fileIdx +": "+ sampleLine +" "+ lineNo}.  */ private Tuple2<File, String> createFileAndFillWithData(File base, String fileName, int fileIdx, String sampleLine) throws IOException {     File file = new File(base, fileName + fileIdx).     Assert.assertFalse(file.exists()).     File tmp = new File(base, "." + fileName + fileIdx).     FileOutputStream stream = new FileOutputStream(tmp).     StringBuilder str = new StringBuilder().     for (int i = 0. i < LINES_PER_FILE. i++) {         String line = fileIdx + ": " + sampleLine + " " + i + "\n".         str.append(line).         stream.write(line.getBytes()).     }     stream.close().     FileUtils.moveFile(tmp, file).     Assert.assertTrue("No result file present", file.exists()).     return new Tuple2<>(file, str.toString()). }
false;private;1;11;;private FileInputSplit createSplitFromTimestampedSplit(TimestampedFileInputSplit split) {     checkNotNull(split).     return new FileInputSplit(split.getSplitNumber(), split.getPath(), split.getStart(), split.getLength(), split.getHostnames()). }
