commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;15;;// ------------------------------------------------------------------------ // startup / shutdown // ------------------------------------------------------------------------ @BeforeClass public static void createHDFS() throws Exception {     Assume.assumeTrue("HDFS cluster cannot be start on Windows without extensions.", !OperatingSystem.isWindows()).     final File tempDir = TEMP_DIR.newFolder().     Configuration hdConf = new Configuration().     hdConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, tempDir.getAbsolutePath()).     MiniDFSCluster.Builder builder = new MiniDFSCluster.Builder(hdConf).     hdfsCluster = builder.build().     hdfsRootPath = new Path("hdfs://" + hdfsCluster.getURI().getHost() + ":" + hdfsCluster.getNameNodePort() + "/"). }
false;public,static;0;8;;@AfterClass public static void destroyHDFS() {     if (hdfsCluster != null) {         hdfsCluster.shutdown().     }     hdfsCluster = null.     hdfsRootPath = null. }
false;public;0;24;;// ------------------------------------------------------------------------ // Tests // ------------------------------------------------------------------------ @Test public void testCreateAndSetFinished() throws Exception {     final Path workDir = new Path(hdfsRootPath, "test-work-dir").     final JobID jid = new JobID().     FsNegativeRunningJobsRegistry registry = new FsNegativeRunningJobsRegistry(workDir).     // another registry should pick this up     FsNegativeRunningJobsRegistry otherRegistry = new FsNegativeRunningJobsRegistry(workDir).     // initially, without any call, the job is pending     assertEquals(JobSchedulingStatus.PENDING, registry.getJobSchedulingStatus(jid)).     assertEquals(JobSchedulingStatus.PENDING, otherRegistry.getJobSchedulingStatus(jid)).     // after set running, the job is running     registry.setJobRunning(jid).     assertEquals(JobSchedulingStatus.RUNNING, registry.getJobSchedulingStatus(jid)).     assertEquals(JobSchedulingStatus.RUNNING, otherRegistry.getJobSchedulingStatus(jid)).     // set the job to finished and validate     registry.setJobFinished(jid).     assertEquals(JobSchedulingStatus.DONE, registry.getJobSchedulingStatus(jid)).     assertEquals(JobSchedulingStatus.DONE, otherRegistry.getJobSchedulingStatus(jid)). }
false;public;0;24;;@Test public void testSetFinishedAndRunning() throws Exception {     final Path workDir = new Path(hdfsRootPath, "änother_wörk_directörü").     final JobID jid = new JobID().     FsNegativeRunningJobsRegistry registry = new FsNegativeRunningJobsRegistry(workDir).     // set the job to finished and validate     registry.setJobFinished(jid).     assertEquals(JobSchedulingStatus.DONE, registry.getJobSchedulingStatus(jid)).     // set the job to running does not overwrite the finished status     registry.setJobRunning(jid).     assertEquals(JobSchedulingStatus.DONE, registry.getJobSchedulingStatus(jid)).     // another registry should pick this up     FsNegativeRunningJobsRegistry otherRegistry = new FsNegativeRunningJobsRegistry(workDir).     assertEquals(JobSchedulingStatus.DONE, otherRegistry.getJobSchedulingStatus(jid)).     // clear the running and finished marker, it will be pending     otherRegistry.clearJob(jid).     assertEquals(JobSchedulingStatus.PENDING, registry.getJobSchedulingStatus(jid)).     assertEquals(JobSchedulingStatus.PENDING, otherRegistry.getJobSchedulingStatus(jid)). }
