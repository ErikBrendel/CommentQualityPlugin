commented;modifiers;parameterAmount;loc;comment;code
false;;1;4;;RocksDBKeyedStateBackendBuilder<K> setEnableIncrementalCheckpointing(boolean enableIncrementalCheckpointing) {     this.enableIncrementalCheckpointing = enableIncrementalCheckpointing.     return this. }
false;;1;4;;RocksDBKeyedStateBackendBuilder<K> setEnableTtlCompactionFilter(boolean enableTtlCompactionFilter) {     this.enableTtlCompactionFilter = enableTtlCompactionFilter.     return this. }
false;;1;4;;RocksDBKeyedStateBackendBuilder<K> setNativeMetricOptions(RocksDBNativeMetricOptions nativeMetricOptions) {     this.nativeMetricOptions = nativeMetricOptions.     return this. }
false;;1;4;;RocksDBKeyedStateBackendBuilder<K> setNumberOfTransferingThreads(int numberOfTransferingThreads) {     this.numberOfTransferingThreads = numberOfTransferingThreads.     return this. }
false;private,static;1;9;;private static void checkAndCreateDirectory(File directory) throws IOException {     if (directory.exists()) {         if (!directory.isDirectory()) {             throw new IOException("Not a directory: " + directory).         }     } else if (!directory.mkdirs()) {         throw new IOException(String.format("Could not create RocksDB data directory at %s.", directory)).     } }
false;public;0;121;;public RocksDBKeyedStateBackend<K> build() throws BackendBuildingException {     RocksDBWriteBatchWrapper writeBatchWrapper = null.     ColumnFamilyHandle defaultColumnFamilyHandle = null.     RocksDBNativeMetricMonitor nativeMetricMonitor = null.     CloseableRegistry cancelStreamRegistry = new CloseableRegistry().     // The write options to use in the states. We disable write ahead logging.     WriteOptions writeOptions = new WriteOptions().setDisableWAL(true).     LinkedHashMap<String, RocksDBKeyedStateBackend.RocksDbKvStateInfo> kvStateInformation = new LinkedHashMap<>().     RocksDB db = null.     AbstractRocksDBRestoreOperation restoreOperation = null.     RocksDbTtlCompactFiltersManager ttlCompactFiltersManager = new RocksDbTtlCompactFiltersManager(enableTtlCompactionFilter).     ResourceGuard rocksDBResourceGuard = new ResourceGuard().     SnapshotStrategy<K> snapshotStrategy.     PriorityQueueSetFactory priorityQueueFactory.     RocksDBSerializedCompositeKeyBuilder<K> sharedRocksKeyBuilder.     // Number of bytes required to prefix the key groups.     int keyGroupPrefixBytes = RocksDBKeySerializationUtils.computeRequiredBytesInKeyGroupPrefix(numberOfKeyGroups).     try {         // Variables for snapshot strategy when incremental checkpoint is enabled         UUID backendUID = UUID.randomUUID().         SortedMap<Long, Set<StateHandleID>> materializedSstFiles = new TreeMap<>().         long lastCompletedCheckpointId = -1L.         if (injectedTestDB != null) {             db = injectedTestDB.             defaultColumnFamilyHandle = injectedDefaultColumnFamilyHandle.             nativeMetricMonitor = nativeMetricOptions.isEnabled() ? new RocksDBNativeMetricMonitor(nativeMetricOptions, metricGroup, db) : null.         } else {             prepareDirectories().             restoreOperation = getRocksDBRestoreOperation(keyGroupPrefixBytes, cancelStreamRegistry, kvStateInformation, ttlCompactFiltersManager).             RocksDBRestoreResult restoreResult = restoreOperation.restore().             db = restoreResult.getDb().             defaultColumnFamilyHandle = restoreResult.getDefaultColumnFamilyHandle().             nativeMetricMonitor = restoreResult.getNativeMetricMonitor().             if (restoreOperation instanceof RocksDBIncrementalRestoreOperation) {                 backendUID = restoreResult.getBackendUID().                 materializedSstFiles = restoreResult.getRestoredSstFiles().                 lastCompletedCheckpointId = restoreResult.getLastCompletedCheckpointId().             }         }         writeBatchWrapper = new RocksDBWriteBatchWrapper(db, writeOptions).         // it is important that we only create the key builder after the restore, and not before.         // restore operations may reconfigure the key serializer, so accessing the key serializer         // only now we can be certain that the key serializer used in the builder is final.         sharedRocksKeyBuilder = new RocksDBSerializedCompositeKeyBuilder<>(keySerializerProvider.currentSchemaSerializer(), keyGroupPrefixBytes, 32).         // init snapshot strategy after db is assured to be initialized         snapshotStrategy = initializeSavepointAndCheckpointStrategies(cancelStreamRegistry, rocksDBResourceGuard, kvStateInformation, keyGroupPrefixBytes, db, backendUID, materializedSstFiles, lastCompletedCheckpointId).         // init priority queue factory         priorityQueueFactory = initPriorityQueueFactory(keyGroupPrefixBytes, kvStateInformation, db, writeBatchWrapper, nativeMetricMonitor).     } catch (Throwable e) {         // Do clean up         List<ColumnFamilyOptions> columnFamilyOptions = new ArrayList<>(kvStateInformation.values().size()).         IOUtils.closeQuietly(cancelStreamRegistry).         IOUtils.closeQuietly(writeBatchWrapper).         RocksDBOperationUtils.addColumnFamilyOptionsToCloseLater(columnFamilyOptions, defaultColumnFamilyHandle).         IOUtils.closeQuietly(defaultColumnFamilyHandle).         IOUtils.closeQuietly(nativeMetricMonitor).         for (RocksDBKeyedStateBackend.RocksDbKvStateInfo kvStateInfo : kvStateInformation.values()) {             RocksDBOperationUtils.addColumnFamilyOptionsToCloseLater(columnFamilyOptions, kvStateInfo.columnFamilyHandle).             IOUtils.closeQuietly(kvStateInfo.columnFamilyHandle).         }         IOUtils.closeQuietly(db).         // it's possible that db has been initialized but later restore steps failed         IOUtils.closeQuietly(restoreOperation).         IOUtils.closeAllQuietly(columnFamilyOptions).         IOUtils.closeQuietly(dbOptions).         IOUtils.closeQuietly(writeOptions).         ttlCompactFiltersManager.disposeAndClearRegisteredCompactionFactories().         kvStateInformation.clear().         try {             FileUtils.deleteDirectory(instanceBasePath).         } catch (Exception ex) {             LOG.warn("Failed to instance base path for RocksDB: " + instanceBasePath, ex).         }         // Log and rethrow         if (e instanceof BackendBuildingException) {             throw (BackendBuildingException) e.         } else {             String errMsg = "Caught unexpected exception.".             LOG.error(errMsg, e).             throw new BackendBuildingException(errMsg, e).         }     }     return new RocksDBKeyedStateBackend<>(this.operatorIdentifier, this.userCodeClassLoader, this.instanceBasePath, this.dbOptions, columnFamilyOptionsFactory, this.kvStateRegistry, this.keySerializerProvider, this.numberOfKeyGroups, this.keyGroupRange, this.executionConfig, this.numberOfTransferingThreads, this.ttlTimeProvider, db, kvStateInformation, keyGroupPrefixBytes, cancelStreamRegistry, this.keyGroupCompressionDecorator, rocksDBResourceGuard, snapshotStrategy.checkpointSnapshotStrategy, snapshotStrategy.savepointSnapshotStrategy, writeBatchWrapper, defaultColumnFamilyHandle, nativeMetricMonitor, sharedRocksKeyBuilder, priorityQueueFactory, ttlCompactFiltersManager). }
false;private;4;64;;private AbstractRocksDBRestoreOperation<K> getRocksDBRestoreOperation(int keyGroupPrefixBytes, CloseableRegistry cancelStreamRegistry, LinkedHashMap<String, RocksDBKeyedStateBackend.RocksDbKvStateInfo> kvStateInformation, RocksDbTtlCompactFiltersManager ttlCompactFiltersManager) {     if (restoreStateHandles.isEmpty()) {         return new RocksDBNoneRestoreOperation<>(keyGroupRange, keyGroupPrefixBytes, numberOfTransferingThreads, cancelStreamRegistry, userCodeClassLoader, kvStateInformation, keySerializerProvider, instanceBasePath, instanceRocksDBPath, dbOptions, columnFamilyOptionsFactory, nativeMetricOptions, metricGroup, restoreStateHandles, ttlCompactFiltersManager, ttlTimeProvider).     }     KeyedStateHandle firstStateHandle = restoreStateHandles.iterator().next().     if (firstStateHandle instanceof IncrementalKeyedStateHandle) {         return new RocksDBIncrementalRestoreOperation<>(operatorIdentifier, keyGroupRange, keyGroupPrefixBytes, numberOfTransferingThreads, cancelStreamRegistry, userCodeClassLoader, kvStateInformation, keySerializerProvider, instanceBasePath, instanceRocksDBPath, dbOptions, columnFamilyOptionsFactory, nativeMetricOptions, metricGroup, restoreStateHandles, ttlCompactFiltersManager, ttlTimeProvider).     } else {         return new RocksDBFullRestoreOperation<>(keyGroupRange, keyGroupPrefixBytes, numberOfTransferingThreads, cancelStreamRegistry, userCodeClassLoader, kvStateInformation, keySerializerProvider, instanceBasePath, instanceRocksDBPath, dbOptions, columnFamilyOptionsFactory, nativeMetricOptions, metricGroup, restoreStateHandles, ttlCompactFiltersManager, ttlTimeProvider).     } }
false;private;8;41;;private SnapshotStrategy<K> initializeSavepointAndCheckpointStrategies(CloseableRegistry cancelStreamRegistry, ResourceGuard rocksDBResourceGuard, LinkedHashMap<String, RocksDBKeyedStateBackend.RocksDbKvStateInfo> kvStateInformation, int keyGroupPrefixBytes, RocksDB db, UUID backendUID, SortedMap<Long, Set<StateHandleID>> materializedSstFiles, long lastCompletedCheckpointId) {     RocksDBSnapshotStrategyBase<K> savepointSnapshotStrategy = new RocksFullSnapshotStrategy<>(db, rocksDBResourceGuard, keySerializer, kvStateInformation, keyGroupRange, keyGroupPrefixBytes, localRecoveryConfig, cancelStreamRegistry, keyGroupCompressionDecorator).     RocksDBSnapshotStrategyBase<K> checkpointSnapshotStrategy.     if (enableIncrementalCheckpointing) {         // TODO eventually we might want to separate savepoint and snapshot strategy, i.e. having 2 strategies.         checkpointSnapshotStrategy = new RocksIncrementalSnapshotStrategy<>(db, rocksDBResourceGuard, keySerializer, kvStateInformation, keyGroupRange, keyGroupPrefixBytes, localRecoveryConfig, cancelStreamRegistry, instanceBasePath, backendUID, materializedSstFiles, lastCompletedCheckpointId, numberOfTransferingThreads).     } else {         checkpointSnapshotStrategy = savepointSnapshotStrategy.     }     return new SnapshotStrategy<>(checkpointSnapshotStrategy, savepointSnapshotStrategy). }
false;private;5;28;;private PriorityQueueSetFactory initPriorityQueueFactory(int keyGroupPrefixBytes, Map<String, RocksDBKeyedStateBackend.RocksDbKvStateInfo> kvStateInformation, RocksDB db, RocksDBWriteBatchWrapper writeBatchWrapper, RocksDBNativeMetricMonitor nativeMetricMonitor) {     PriorityQueueSetFactory priorityQueueFactory.     switch(priorityQueueStateType) {         case HEAP:             priorityQueueFactory = new HeapPriorityQueueSetFactory(keyGroupRange, numberOfKeyGroups, 128).             break.         case ROCKSDB:             priorityQueueFactory = new RocksDBPriorityQueueSetFactory(keyGroupRange, keyGroupPrefixBytes, numberOfKeyGroups, kvStateInformation, db, writeBatchWrapper, nativeMetricMonitor, columnFamilyOptionsFactory).             break.         default:             throw new IllegalArgumentException("Unknown priority queue state type: " + priorityQueueStateType).     }     return priorityQueueFactory. }
false;private;0;8;;private void prepareDirectories() throws IOException {     checkAndCreateDirectory(instanceBasePath).     if (instanceRocksDBPath.exists()) {         // Clear the base directory when the backend is created         // in case something crashed and the backend never reached dispose()         FileUtils.deleteDirectory(instanceBasePath).     } }
