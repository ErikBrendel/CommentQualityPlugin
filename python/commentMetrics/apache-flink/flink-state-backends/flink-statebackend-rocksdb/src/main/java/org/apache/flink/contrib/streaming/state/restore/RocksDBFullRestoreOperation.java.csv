commented;modifiers;parameterAmount;loc;comment;code
true;public;0;19;/**  * Restores all key-groups data that is referenced by the passed state handles.  */ ;/**  * Restores all key-groups data that is referenced by the passed state handles.  */ @Override public RocksDBRestoreResult restore() throws IOException, StateMigrationException, RocksDBException {     openDB().     for (KeyedStateHandle keyedStateHandle : restoreStateHandles) {         if (keyedStateHandle != null) {             if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {                 throw new IllegalStateException("Unexpected state handle type, " + "expected: " + KeyGroupsStateHandle.class + ", but found: " + keyedStateHandle.getClass()).             }             this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle.             restoreKeyGroupsInStateHandle().         }     }     return new RocksDBRestoreResult(this.db, defaultColumnFamilyHandle, nativeMetricMonitor, -1, null, null). }
true;private;0;14;/**  * Restore one key groups state handle.  */ ;/**  * Restore one key groups state handle.  */ private void restoreKeyGroupsInStateHandle() throws IOException, StateMigrationException, RocksDBException {     try {         currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream().         cancelStreamRegistry.registerCloseable(currentStateHandleInStream).         currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream).         restoreKVStateMetaData().         restoreKVStateData().     } finally {         if (cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {             IOUtils.closeQuietly(currentStateHandleInStream).         }     } }
true;private;0;16;/**  * Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.  */ ;/**  * Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.  */ private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {     KeyedBackendSerializationProxy<K> serializationProxy = readMetaData(currentStateHandleInView).     this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ? SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE.     List<StateMetaInfoSnapshot> restoredMetaInfos = serializationProxy.getStateMetaInfoSnapshots().     currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size()).     for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {         RocksDbKvStateInfo registeredStateCFHandle = getOrRegisterStateColumnFamilyHandle(null, restoredMetaInfo).         currentStateHandleKVStateColumnFamilies.add(registeredStateCFHandle.columnFamilyHandle).     } }
true;private;0;45;/**  * Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.  */ ;/**  * Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.  */ private void restoreKVStateData() throws IOException, RocksDBException {     // for all key-groups in the current state handle...     try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(db)) {         for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {             int keyGroup = keyGroupOffset.f0.             // Check that restored key groups all belong to the backend             Preconditions.checkState(keyGroupRange.contains(keyGroup), "The key group must belong to the backend").             long offset = keyGroupOffset.f1.             // not empty key-group?             if (0L != offset) {                 currentStateHandleInStream.seek(offset).                 try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {                     DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn).                     // TODO this could be aware of keyGroupPrefixBytes and write only one byte if possible                     int kvStateId = compressedKgInputView.readShort().                     ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId).                     // insert all k/v pairs into DB                     boolean keyGroupHasMoreKeys = true.                     while (keyGroupHasMoreKeys) {                         byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView).                         byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView).                         if (hasMetaDataFollowsFlag(key)) {                             // clear the signal bit in the key to make it ready for insertion again                             clearMetaDataFollowsFlag(key).                             writeBatchWrapper.put(handle, key, value).                             // TODO this could be aware of keyGroupPrefixBytes and write only one byte if possible                             kvStateId = END_OF_KEY_GROUP_MARK & compressedKgInputView.readShort().                             if (END_OF_KEY_GROUP_MARK == kvStateId) {                                 keyGroupHasMoreKeys = false.                             } else {                                 handle = currentStateHandleKVStateColumnFamilies.get(kvStateId).                             }                         } else {                             writeBatchWrapper.put(handle, key, value).                         }                     }                 }             }         }     } }
