commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public TypeSerializer<K> getKeySerializer() {     return backend.getKeySerializer(). }
false;public;0;4;;@Override public TypeSerializer<N> getNamespaceSerializer() {     return namespaceSerializer. }
false;public;0;4;;@Override public TypeSerializer<ACC> getValueSerializer() {     return valueSerializer. }
false;public;0;8;;@Override public R get() {     ACC accumulator = getInternal().     if (accumulator == null) {         return null.     }     return aggFunction.getResult(accumulator). }
false;public;1;7;;@Override public void add(T value) {     byte[] key = getKeyBytes().     ACC accumulator = getInternal(key).     accumulator = accumulator == null ? aggFunction.createAccumulator() : accumulator.     updateInternal(key, aggFunction.add(value, accumulator)). }
false;public;2;58;;@Override public void mergeNamespaces(N target, Collection<N> sources) {     if (sources == null || sources.isEmpty()) {         return.     }     try {         ACC current = null.         // merge the sources to the target         for (N source : sources) {             if (source != null) {                 setCurrentNamespace(source).                 final byte[] sourceKey = serializeCurrentKeyWithGroupAndNamespace().                 final byte[] valueBytes = backend.db.get(columnFamily, sourceKey).                 backend.db.delete(columnFamily, writeOptions, sourceKey).                 if (valueBytes != null) {                     dataInputView.setBuffer(valueBytes).                     ACC value = valueSerializer.deserialize(dataInputView).                     if (current != null) {                         current = aggFunction.merge(current, value).                     } else {                         current = value.                     }                 }             }         }         // if something came out of merging the sources, merge it or write it to the target         if (current != null) {             setCurrentNamespace(target).             // create the target full-binary-key             final byte[] targetKey = serializeCurrentKeyWithGroupAndNamespace().             final byte[] targetValueBytes = backend.db.get(columnFamily, targetKey).             if (targetValueBytes != null) {                 // target also had a value, merge                 dataInputView.setBuffer(targetValueBytes).                 ACC value = valueSerializer.deserialize(dataInputView).                 current = aggFunction.merge(current, value).             }             // serialize the resulting value             dataOutputView.clear().             valueSerializer.serialize(current, dataOutputView).             // write the resulting value             backend.db.put(columnFamily, writeOptions, targetKey, dataOutputView.getCopyOfBuffer()).         }     } catch (Exception e) {         throw new FlinkRuntimeException("Error while merging state in RocksDB", e).     } }
false;static;3;13;;@SuppressWarnings("unchecked") static <K, N, SV, S extends State, IS extends S> IS create(StateDescriptor<S, SV> stateDesc, Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> registerResult, RocksDBKeyedStateBackend<K> backend) {     return (IS) new RocksDBAggregatingState<>(registerResult.f0, registerResult.f1.getNamespaceSerializer(), registerResult.f1.getStateSerializer(), stateDesc.getDefaultValue(), ((AggregatingStateDescriptor<?, SV, ?>) stateDesc).getAggregateFunction(), backend). }
