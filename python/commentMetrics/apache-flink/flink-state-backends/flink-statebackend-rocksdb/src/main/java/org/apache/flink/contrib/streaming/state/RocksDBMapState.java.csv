commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public TypeSerializer<K> getKeySerializer() {     return backend.getKeySerializer(). }
false;public;0;4;;@Override public TypeSerializer<N> getNamespaceSerializer() {     return namespaceSerializer. }
false;public;0;4;;@Override public TypeSerializer<Map<UK, UV>> getValueSerializer() {     return valueSerializer. }
false;public;1;7;;// ------------------------------------------------------------------------ // MapState Implementation // ------------------------------------------------------------------------ @Override public UV get(UK userKey) throws IOException, RocksDBException {     byte[] rawKeyBytes = serializeCurrentKeyWithGroupAndNamespacePlusUserKey(userKey, userKeySerializer).     byte[] rawValueBytes = backend.db.get(columnFamily, rawKeyBytes).     return (rawValueBytes == null ? null : deserializeUserValue(dataInputView, rawValueBytes, userValueSerializer)). }
false;public;2;8;;@Override public void put(UK userKey, UV userValue) throws IOException, RocksDBException {     byte[] rawKeyBytes = serializeCurrentKeyWithGroupAndNamespacePlusUserKey(userKey, userKeySerializer).     byte[] rawValueBytes = serializeValueNullSensitive(userValue, userValueSerializer).     backend.db.put(columnFamily, writeOptions, rawKeyBytes, rawValueBytes). }
false;public;1;14;;@Override public void putAll(Map<UK, UV> map) throws IOException, RocksDBException {     if (map == null) {         return.     }     try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(backend.db, writeOptions)) {         for (Map.Entry<UK, UV> entry : map.entrySet()) {             byte[] rawKeyBytes = serializeCurrentKeyWithGroupAndNamespacePlusUserKey(entry.getKey(), userKeySerializer).             byte[] rawValueBytes = serializeValueNullSensitive(entry.getValue(), userValueSerializer).             writeBatchWrapper.put(columnFamily, rawKeyBytes, rawValueBytes).         }     } }
false;public;1;6;;@Override public void remove(UK userKey) throws IOException, RocksDBException {     byte[] rawKeyBytes = serializeCurrentKeyWithGroupAndNamespacePlusUserKey(userKey, userKeySerializer).     backend.db.delete(columnFamily, writeOptions, rawKeyBytes). }
false;public;1;7;;@Override public boolean contains(UK userKey) throws IOException, RocksDBException {     byte[] rawKeyBytes = serializeCurrentKeyWithGroupAndNamespacePlusUserKey(userKey, userKeySerializer).     byte[] rawValueBytes = backend.db.get(columnFamily, rawKeyBytes).     return (rawValueBytes != null). }
false;public;0;11;;@Override public Iterable<Map.Entry<UK, UV>> entries() {     final Iterator<Map.Entry<UK, UV>> iterator = iterator().     // Return null to make the behavior consistent with other states.     if (!iterator.hasNext()) {         return null.     } else {         return () -> iterator.     } }
false;public;0;6;;@Nullable @Override public UK next() {     RocksDBMapEntry entry = nextEntry().     return (entry == null ? null : entry.getKey()). }
false;public;0;13;;@Override public Iterable<UK> keys() {     final byte[] prefixBytes = serializeCurrentKeyWithGroupAndNamespace().     return () -> new RocksDBMapIterator<UK>(backend.db, prefixBytes, userKeySerializer, userValueSerializer, dataInputView) {          @Nullable         @Override         public UK next() {             RocksDBMapEntry entry = nextEntry().             return (entry == null ? null : entry.getKey()).         }     }. }
false;public;0;5;;@Override public UV next() {     RocksDBMapEntry entry = nextEntry().     return (entry == null ? null : entry.getValue()). }
false;public;0;12;;@Override public Iterable<UV> values() {     final byte[] prefixBytes = serializeCurrentKeyWithGroupAndNamespace().     return () -> new RocksDBMapIterator<UV>(backend.db, prefixBytes, userKeySerializer, userValueSerializer, dataInputView) {          @Override         public UV next() {             RocksDBMapEntry entry = nextEntry().             return (entry == null ? null : entry.getValue()).         }     }. }
false;public;0;4;;@Override public Map.Entry<UK, UV> next() {     return nextEntry(). }
false;public;0;11;;@Override public Iterator<Map.Entry<UK, UV>> iterator() {     final byte[] prefixBytes = serializeCurrentKeyWithGroupAndNamespace().     return new RocksDBMapIterator<Map.Entry<UK, UV>>(backend.db, prefixBytes, userKeySerializer, userValueSerializer, dataInputView) {          @Override         public Map.Entry<UK, UV> next() {             return nextEntry().         }     }. }
false;public;0;23;;@Override public void clear() {     try {         try (RocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(backend.db, columnFamily).             RocksDBWriteBatchWrapper rocksDBWriteBatchWrapper = new RocksDBWriteBatchWrapper(backend.db, backend.getWriteOptions())) {             final byte[] keyPrefixBytes = serializeCurrentKeyWithGroupAndNamespace().             iterator.seek(keyPrefixBytes).             while (iterator.isValid()) {                 byte[] keyBytes = iterator.key().                 if (startWithKeyPrefix(keyPrefixBytes, keyBytes)) {                     rocksDBWriteBatchWrapper.remove(columnFamily, keyBytes).                 } else {                     break.                 }                 iterator.next().             }         }     } catch (Exception e) {         LOG.warn("Error while cleaning the state.", e).     } }
false;public;0;4;;@Override public Map.Entry<UK, UV> next() {     return nextEntry(). }
false;public;4;55;;@Override public byte[] getSerializedValue(final byte[] serializedKeyAndNamespace, final TypeSerializer<K> safeKeySerializer, final TypeSerializer<N> safeNamespaceSerializer, final TypeSerializer<Map<UK, UV>> safeValueSerializer) throws Exception {     Preconditions.checkNotNull(serializedKeyAndNamespace).     Preconditions.checkNotNull(safeKeySerializer).     Preconditions.checkNotNull(safeNamespaceSerializer).     Preconditions.checkNotNull(safeValueSerializer).     // TODO make KvStateSerializer key-group aware to save this round trip and key-group computation     Tuple2<K, N> keyAndNamespace = KvStateSerializer.deserializeKeyAndNamespace(serializedKeyAndNamespace, safeKeySerializer, safeNamespaceSerializer).     int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(keyAndNamespace.f0, backend.getNumberOfKeyGroups()).     RocksDBSerializedCompositeKeyBuilder<K> keyBuilder = new RocksDBSerializedCompositeKeyBuilder<>(safeKeySerializer, backend.getKeyGroupPrefixBytes(), 32).     keyBuilder.setKeyAndKeyGroup(keyAndNamespace.f0, keyGroup).     final byte[] keyPrefixBytes = keyBuilder.buildCompositeKeyNamespace(keyAndNamespace.f1, namespaceSerializer).     final MapSerializer<UK, UV> serializer = (MapSerializer<UK, UV>) safeValueSerializer.     final TypeSerializer<UK> dupUserKeySerializer = serializer.getKeySerializer().     final TypeSerializer<UV> dupUserValueSerializer = serializer.getValueSerializer().     final DataInputDeserializer inputView = new DataInputDeserializer().     final Iterator<Map.Entry<UK, UV>> iterator = new RocksDBMapIterator<Map.Entry<UK, UV>>(backend.db, keyPrefixBytes, dupUserKeySerializer, dupUserValueSerializer, inputView) {          @Override         public Map.Entry<UK, UV> next() {             return nextEntry().         }     }.     // Return null to make the behavior consistent with other backends     if (!iterator.hasNext()) {         return null.     }     return KvStateSerializer.serializeMap(() -> iterator, dupUserKeySerializer, dupUserValueSerializer). }
false;private,static;4;8;;// ------------------------------------------------------------------------ // Serialization Methods // ------------------------------------------------------------------------ private static <UK> UK deserializeUserKey(DataInputDeserializer dataInputView, int userKeyOffset, byte[] rawKeyBytes, TypeSerializer<UK> keySerializer) throws IOException {     dataInputView.setBuffer(rawKeyBytes, userKeyOffset, rawKeyBytes.length - userKeyOffset).     return keySerializer.deserialize(dataInputView). }
false;private,static;3;11;;private static <UV> UV deserializeUserValue(DataInputDeserializer dataInputView, byte[] rawValueBytes, TypeSerializer<UV> valueSerializer) throws IOException {     dataInputView.setBuffer(rawValueBytes).     boolean isNull = dataInputView.readBoolean().     return isNull ? null : valueSerializer.deserialize(dataInputView). }
false;private;2;13;;private boolean startWithKeyPrefix(byte[] keyPrefixBytes, byte[] rawKeyBytes) {     if (rawKeyBytes.length < keyPrefixBytes.length) {         return false.     }     for (int i = keyPrefixBytes.length. --i >= backend.getKeyGroupPrefixBytes(). ) {         if (rawKeyBytes[i] != keyPrefixBytes[i]) {             return false.         }     }     return true. }
false;public;0;10;;public void remove() {     deleted = true.     rawValueBytes = null.     try {         db.delete(columnFamily, writeOptions, rawKeyBytes).     } catch (RocksDBException e) {         throw new FlinkRuntimeException("Error while removing data from RocksDB.", e).     } }
false;public;0;12;;@Override public UK getKey() {     if (userKey == null) {         try {             userKey = deserializeUserKey(dataInputView, userKeyOffset, rawKeyBytes, keySerializer).         } catch (IOException e) {             throw new FlinkRuntimeException("Error while deserializing the user key.", e).         }     }     return userKey. }
false;public;0;16;;@Override public UV getValue() {     if (deleted) {         return null.     } else {         if (userValue == null) {             try {                 userValue = deserializeUserValue(dataInputView, rawValueBytes, valueSerializer).             } catch (IOException e) {                 throw new FlinkRuntimeException("Error while deserializing the user value.", e).             }         }         return userValue.     } }
false;public;1;19;;@Override public UV setValue(UV value) {     if (deleted) {         throw new IllegalStateException("The value has already been deleted.").     }     UV oldValue = getValue().     try {         userValue = value.         rawValueBytes = serializeValueNullSensitive(value, valueSerializer).         db.put(columnFamily, writeOptions, rawKeyBytes, rawValueBytes).     } catch (IOException | RocksDBException e) {         throw new FlinkRuntimeException("Error while putting data into RocksDB.", e).     }     return oldValue. }
false;public;0;6;;@Override public boolean hasNext() {     loadCache().     return (cacheIndex < cacheEntries.size()). }
false;public;0;8;;@Override public void remove() {     if (currentEntry == null || currentEntry.deleted) {         throw new IllegalStateException("The remove operation must be called after a valid next operation.").     }     currentEntry.remove(). }
false;final;0;16;;final RocksDBMapEntry nextEntry() {     loadCache().     if (cacheIndex == cacheEntries.size()) {         if (!expired) {             throw new IllegalStateException().         }         return null.     }     this.currentEntry = cacheEntries.get(cacheIndex).     cacheIndex++.     return currentEntry. }
false;private;0;59;;private void loadCache() {     if (cacheIndex > cacheEntries.size()) {         throw new IllegalStateException().     }     // Load cache entries only when the cache is empty and there still exist unread entries     if (cacheIndex < cacheEntries.size() || expired) {         return.     }     // occurred in the below code block.     try (RocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(db, columnFamily)) {         /* 				 * The iteration starts from the prefix bytes at the first loading. After #nextEntry() is called, 				 * the currentEntry points to the last returned entry, and at that time, we will start 				 * the iterating from currentEntry if reloading cache is needed. 				 */         byte[] startBytes = (currentEntry == null ? keyPrefixBytes : currentEntry.rawKeyBytes).         cacheEntries.clear().         cacheIndex = 0.         iterator.seek(startBytes).         /* 				 * If the entry pointing to the current position is not removed, it will be the first entry in the 				 * new iterating. Skip it to avoid redundant access in such cases. 				 */         if (currentEntry != null && !currentEntry.deleted) {             iterator.next().         }         while (true) {             if (!iterator.isValid() || !startWithKeyPrefix(keyPrefixBytes, iterator.key())) {                 expired = true.                 break.             }             if (cacheEntries.size() >= CACHE_SIZE_LIMIT) {                 break.             }             RocksDBMapEntry entry = new RocksDBMapEntry(db, keyPrefixBytes.length, iterator.key(), iterator.value(), keySerializer, valueSerializer, dataInputView).             cacheEntries.add(entry).             iterator.next().         }     } }
false;static;3;12;;@SuppressWarnings("unchecked") static <UK, UV, K, N, SV, S extends State, IS extends S> IS create(StateDescriptor<S, SV> stateDesc, Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> registerResult, RocksDBKeyedStateBackend<K> backend) {     return (IS) new RocksDBMapState<>(registerResult.f0, registerResult.f1.getNamespaceSerializer(), (TypeSerializer<Map<UK, UV>>) registerResult.f1.getStateSerializer(), (Map<UK, UV>) stateDesc.getDefaultValue(), backend). }
false;public;1;21;;@Override @Nullable public byte[] filterOrTransform(@Nullable byte[] value) {     if (value == null || isNull(value)) {         return NULL_VALUE.     } else {         // we have to skip the first byte indicating null user value         // TODO: optimization here could be to work with slices and not byte arrays         // and copy slice sub-array only when needed         byte[] woNullByte = Arrays.copyOfRange(value, 1, value.length).         byte[] filteredValue = elementTransformer.filterOrTransform(woNullByte).         if (filteredValue == null) {             filteredValue = NULL_VALUE.         } else if (filteredValue != woNullByte) {             filteredValue = prependWithNonNullByte(filteredValue, value).         } else {             filteredValue = value.         }         return filteredValue.     } }
false;private;1;8;;private boolean isNull(byte[] value) {     try {         div.setBuffer(value, 0, 1).         return div.readBoolean().     } catch (IOException e) {         throw new FlinkRuntimeException("Failed to deserialize boolean flag of map user null value", e).     } }
false;private,static;2;7;;private static byte[] prependWithNonNullByte(byte[] value, byte[] reuse) {     int len = 1 + value.length.     byte[] result = reuse.length == len ? reuse : new byte[len].     result[0] = NON_NULL_VALUE_PREFIX.     System.arraycopy(value, 0, result, 1, value.length).     return result. }
