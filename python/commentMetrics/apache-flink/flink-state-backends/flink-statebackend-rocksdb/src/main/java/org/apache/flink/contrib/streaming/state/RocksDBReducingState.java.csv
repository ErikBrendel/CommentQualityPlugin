commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public TypeSerializer<K> getKeySerializer() {     return backend.getKeySerializer(). }
false;public;0;4;;@Override public TypeSerializer<N> getNamespaceSerializer() {     return namespaceSerializer. }
false;public;0;4;;@Override public TypeSerializer<V> getValueSerializer() {     return valueSerializer. }
false;public;0;4;;@Override public V get() {     return getInternal(). }
false;public;1;7;;@Override public void add(V value) throws Exception {     byte[] key = getKeyBytes().     V oldValue = getInternal(key).     V newValue = oldValue == null ? value : reduceFunction.reduce(oldValue, value).     updateInternal(key, newValue). }
false;public;2;58;;@Override public void mergeNamespaces(N target, Collection<N> sources) {     if (sources == null || sources.isEmpty()) {         return.     }     try {         V current = null.         // merge the sources to the target         for (N source : sources) {             if (source != null) {                 setCurrentNamespace(source).                 final byte[] sourceKey = serializeCurrentKeyWithGroupAndNamespace().                 final byte[] valueBytes = backend.db.get(columnFamily, sourceKey).                 backend.db.delete(columnFamily, writeOptions, sourceKey).                 if (valueBytes != null) {                     dataInputView.setBuffer(valueBytes).                     V value = valueSerializer.deserialize(dataInputView).                     if (current != null) {                         current = reduceFunction.reduce(current, value).                     } else {                         current = value.                     }                 }             }         }         // if something came out of merging the sources, merge it or write it to the target         if (current != null) {             // create the target full-binary-key             setCurrentNamespace(target).             final byte[] targetKey = serializeCurrentKeyWithGroupAndNamespace().             final byte[] targetValueBytes = backend.db.get(columnFamily, targetKey).             if (targetValueBytes != null) {                 dataInputView.setBuffer(targetValueBytes).                 // target also had a value, merge                 V value = valueSerializer.deserialize(dataInputView).                 current = reduceFunction.reduce(current, value).             }             // serialize the resulting value             dataOutputView.clear().             valueSerializer.serialize(current, dataOutputView).             // write the resulting value             backend.db.put(columnFamily, writeOptions, targetKey, dataOutputView.getCopyOfBuffer()).         }     } catch (Exception e) {         throw new FlinkRuntimeException("Error while merging state in RocksDB", e).     } }
false;static;3;13;;@SuppressWarnings("unchecked") static <K, N, SV, S extends State, IS extends S> IS create(StateDescriptor<S, SV> stateDesc, Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> registerResult, RocksDBKeyedStateBackend<K> backend) {     return (IS) new RocksDBReducingState<>(registerResult.f0, registerResult.f1.getNamespaceSerializer(), registerResult.f1.getStateSerializer(), stateDesc.getDefaultValue(), ((ReducingStateDescriptor<SV>) stateDesc).getReduceFunction(), backend). }
