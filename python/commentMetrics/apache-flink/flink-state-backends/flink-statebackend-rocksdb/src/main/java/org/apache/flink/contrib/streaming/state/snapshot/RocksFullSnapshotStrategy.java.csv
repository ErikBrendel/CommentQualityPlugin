commented;modifiers;parameterAmount;loc;comment;code
false;public;4;35;;@Nonnull @Override public RunnableFuture<SnapshotResult<KeyedStateHandle>> doSnapshot(long checkpointId, long timestamp, @Nonnull CheckpointStreamFactory primaryStreamFactory, @Nonnull CheckpointOptions checkpointOptions) throws Exception {     final SupplierWithException<CheckpointStreamWithResultProvider, Exception> checkpointStreamSupplier = createCheckpointStreamSupplier(checkpointId, primaryStreamFactory, checkpointOptions).     final List<StateMetaInfoSnapshot> stateMetaInfoSnapshots = new ArrayList<>(kvStateInformation.size()).     final List<RocksDbKvStateInfo> metaDataCopy = new ArrayList<>(kvStateInformation.size()).     for (RocksDbKvStateInfo stateInfo : kvStateInformation.values()) {         // snapshot meta info         stateMetaInfoSnapshots.add(stateInfo.metaInfo.snapshot()).         metaDataCopy.add(stateInfo).     }     final ResourceGuard.Lease lease = rocksDBResourceGuard.acquireResource().     final Snapshot snapshot = db.getSnapshot().     final SnapshotAsynchronousPartCallable asyncSnapshotCallable = new SnapshotAsynchronousPartCallable(checkpointStreamSupplier, lease, snapshot, stateMetaInfoSnapshots, metaDataCopy, primaryStreamFactory.toString()).     return asyncSnapshotCallable.toAsyncSnapshotFutureTask(cancelStreamRegistry). }
false;public;1;4;;@Override public void notifyCheckpointComplete(long checkpointId) { // nothing to do. }
false;private;3;18;;private SupplierWithException<CheckpointStreamWithResultProvider, Exception> createCheckpointStreamSupplier(long checkpointId, CheckpointStreamFactory primaryStreamFactory, CheckpointOptions checkpointOptions) {     return localRecoveryConfig.isLocalRecoveryEnabled() && (CheckpointType.SAVEPOINT != checkpointOptions.getCheckpointType()) ? () -> CheckpointStreamWithResultProvider.createDuplicatingStream(checkpointId, CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory, localRecoveryConfig.getLocalStateDirectoryProvider()) : () -> CheckpointStreamWithResultProvider.createSimpleStream(CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory). }
false;protected;0;17;;@Override protected SnapshotResult<KeyedStateHandle> callInternal() throws Exception {     final KeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(keyGroupRange).     final CheckpointStreamWithResultProvider checkpointStreamWithResultProvider = checkpointStreamSupplier.get().     snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider).     writeSnapshotToOutputStream(checkpointStreamWithResultProvider, keyGroupRangeOffsets).     if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {         return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult(), keyGroupRangeOffsets).     } else {         throw new IOException("Stream is already unregistered/closed.").     } }
false;protected;0;6;;@Override protected void cleanupProvidedResources() {     db.releaseSnapshot(snapshot).     IOUtils.closeQuietly(snapshot).     IOUtils.closeQuietly(dbLease). }
false;protected;1;4;;@Override protected void logAsyncSnapshotComplete(long startTime) {     logAsyncCompleted(logPathString, startTime). }
false;private;2;22;;private void writeSnapshotToOutputStream(@Nonnull CheckpointStreamWithResultProvider checkpointStreamWithResultProvider, @Nonnull KeyGroupRangeOffsets keyGroupRangeOffsets) throws IOException, InterruptedException {     final List<Tuple2<RocksIteratorWrapper, Integer>> kvStateIterators = new ArrayList<>(metaData.size()).     final DataOutputView outputView = new DataOutputViewStreamWrapper(checkpointStreamWithResultProvider.getCheckpointOutputStream()).     final ReadOptions readOptions = new ReadOptions().     try {         readOptions.setSnapshot(snapshot).         writeKVStateMetaData(kvStateIterators, readOptions, outputView).         writeKVStateData(kvStateIterators, checkpointStreamWithResultProvider, keyGroupRangeOffsets).     } finally {         for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {             IOUtils.closeQuietly(kvStateIterator.f0).         }         IOUtils.closeQuietly(readOptions).     } }
false;private;3;26;;private void writeKVStateMetaData(final List<Tuple2<RocksIteratorWrapper, Integer>> kvStateIterators, final ReadOptions readOptions, final DataOutputView outputView) throws IOException {     int kvStateId = 0.     for (MetaData metaDataEntry : metaData) {         RocksIteratorWrapper rocksIteratorWrapper = getRocksIterator(db, metaDataEntry.rocksDbKvStateInfo.columnFamilyHandle, metaDataEntry.stateSnapshotTransformer, readOptions).         kvStateIterators.add(Tuple2.of(rocksIteratorWrapper, kvStateId)).         ++kvStateId.     }     KeyedBackendSerializationProxy<K> serializationProxy = new KeyedBackendSerializationProxy<>(// get a serialized form already at state registration time in the future     keySerializer, stateMetaInfoSnapshots, !Objects.equals(UncompressedStreamCompressionDecorator.INSTANCE, keyGroupCompressionDecorator)).     serializationProxy.write(outputView). }
false;private;3;94;;private void writeKVStateData(final List<Tuple2<RocksIteratorWrapper, Integer>> kvStateIterators, final CheckpointStreamWithResultProvider checkpointStreamWithResultProvider, final KeyGroupRangeOffsets keyGroupRangeOffsets) throws IOException, InterruptedException {     byte[] previousKey = null.     byte[] previousValue = null.     DataOutputView kgOutView = null.     OutputStream kgOutStream = null.     CheckpointStreamFactory.CheckpointStateOutputStream checkpointOutputStream = checkpointStreamWithResultProvider.getCheckpointOutputStream().     try {         // Here we transfer ownership of RocksIterators to the RocksStatesPerKeyGroupMergeIterator         try (RocksStatesPerKeyGroupMergeIterator mergeIterator = new RocksStatesPerKeyGroupMergeIterator(kvStateIterators, keyGroupPrefixBytes)) {             // preamble: setup with first key-group as our lookahead             if (mergeIterator.isValid()) {                 // begin first key-group by recording the offset                 keyGroupRangeOffsets.setKeyGroupOffset(mergeIterator.keyGroup(), checkpointOutputStream.getPos()).                 // write the k/v-state id as metadata                 kgOutStream = keyGroupCompressionDecorator.decorateWithCompression(checkpointOutputStream).                 kgOutView = new DataOutputViewStreamWrapper(kgOutStream).                 // TODO this could be aware of keyGroupPrefixBytes and write only one byte if possible                 kgOutView.writeShort(mergeIterator.kvStateId()).                 previousKey = mergeIterator.key().                 previousValue = mergeIterator.value().                 mergeIterator.next().             }             // main loop: write k/v pairs ordered by (key-group, kv-state), thereby tracking key-group offsets.             while (mergeIterator.isValid()) {                 assert (!hasMetaDataFollowsFlag(previousKey)).                 // set signal in first key byte that meta data will follow in the stream after this k/v pair                 if (mergeIterator.isNewKeyGroup() || mergeIterator.isNewKeyValueState()) {                     // be cooperative and check for interruption from time to time in the hot loop                     checkInterrupted().                     setMetaDataFollowsFlagInKey(previousKey).                 }                 writeKeyValuePair(previousKey, previousValue, kgOutView).                 // write meta data if we have to                 if (mergeIterator.isNewKeyGroup()) {                     // TODO this could be aware of keyGroupPrefixBytes and write only one byte if possible                     kgOutView.writeShort(END_OF_KEY_GROUP_MARK).                     // this will just close the outer stream                     kgOutStream.close().                     // begin new key-group                     keyGroupRangeOffsets.setKeyGroupOffset(mergeIterator.keyGroup(), checkpointOutputStream.getPos()).                     // write the kev-state                     // TODO this could be aware of keyGroupPrefixBytes and write only one byte if possible                     kgOutStream = keyGroupCompressionDecorator.decorateWithCompression(checkpointOutputStream).                     kgOutView = new DataOutputViewStreamWrapper(kgOutStream).                     kgOutView.writeShort(mergeIterator.kvStateId()).                 } else if (mergeIterator.isNewKeyValueState()) {                     // write the k/v-state                     // TODO this could be aware of keyGroupPrefixBytes and write only one byte if possible                     kgOutView.writeShort(mergeIterator.kvStateId()).                 }                 // request next k/v pair                 previousKey = mergeIterator.key().                 previousValue = mergeIterator.value().                 mergeIterator.next().             }         }         // epilogue: write last key-group         if (previousKey != null) {             assert (!hasMetaDataFollowsFlag(previousKey)).             setMetaDataFollowsFlagInKey(previousKey).             writeKeyValuePair(previousKey, previousValue, kgOutView).             // TODO this could be aware of keyGroupPrefixBytes and write only one byte if possible             kgOutView.writeShort(END_OF_KEY_GROUP_MARK).             // this will just close the outer stream             kgOutStream.close().             kgOutStream = null.         }     } finally {         // this will just close the outer stream         IOUtils.closeQuietly(kgOutStream).     } }
false;private;3;4;;private void writeKeyValuePair(byte[] key, byte[] value, DataOutputView out) throws IOException {     BytePrimitiveArraySerializer.INSTANCE.serialize(key, out).     BytePrimitiveArraySerializer.INSTANCE.serialize(value, out). }
false;private;0;5;;private void checkInterrupted() throws InterruptedException {     if (Thread.currentThread().isInterrupted()) {         throw new InterruptedException("RocksDB snapshot interrupted.").     } }
false;private,static;1;13;;private static List<MetaData> fillMetaData(List<RocksDbKvStateInfo> metaDataCopy) {     List<MetaData> metaData = new ArrayList<>(metaDataCopy.size()).     for (RocksDbKvStateInfo rocksDbKvStateInfo : metaDataCopy) {         StateSnapshotTransformer<byte[]> stateSnapshotTransformer = null.         if (rocksDbKvStateInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo) {             stateSnapshotTransformer = ((RegisteredKeyValueStateBackendMetaInfo<?, ?>) rocksDbKvStateInfo.metaInfo).getStateSnapshotTransformFactory().createForSerializedState().orElse(null).         }         metaData.add(new MetaData(rocksDbKvStateInfo, stateSnapshotTransformer)).     }     return metaData. }
false;private,static;4;11;;@SuppressWarnings("unchecked") private static RocksIteratorWrapper getRocksIterator(RocksDB db, ColumnFamilyHandle columnFamilyHandle, StateSnapshotTransformer<byte[]> stateSnapshotTransformer, ReadOptions readOptions) {     RocksIterator rocksIterator = db.newIterator(columnFamilyHandle, readOptions).     return stateSnapshotTransformer == null ? new RocksIteratorWrapper(rocksIterator) : new RocksTransformingIteratorWrapper(rocksIterator, stateSnapshotTransformer). }
