commented;modifiers;parameterAmount;loc;comment;code
false;public;1;12;;@Override public DBOptions createDBOptions(DBOptions currentOptions) {     if (isOptionConfigured(MAX_BACKGROUND_THREADS)) {         currentOptions.setIncreaseParallelism(getMaxBackgroundThreads()).     }     if (isOptionConfigured(MAX_OPEN_FILES)) {         currentOptions.setMaxOpenFiles(getMaxOpenFiles()).     }     return currentOptions. }
false;public;1;54;;@Override public ColumnFamilyOptions createColumnOptions(ColumnFamilyOptions currentOptions) {     if (isOptionConfigured(COMPACTION_STYLE)) {         currentOptions.setCompactionStyle(getCompactionStyle()).     }     if (isOptionConfigured(USE_DYNAMIC_LEVEL_SIZE)) {         currentOptions.setLevelCompactionDynamicLevelBytes(getUseDynamicLevelSize()).     }     if (isOptionConfigured(TARGET_FILE_SIZE_BASE)) {         currentOptions.setTargetFileSizeBase(getTargetFileSizeBase()).     }     if (isOptionConfigured(MAX_SIZE_LEVEL_BASE)) {         currentOptions.setMaxBytesForLevelBase(getMaxSizeLevelBase()).     }     if (isOptionConfigured(WRITE_BUFFER_SIZE)) {         currentOptions.setWriteBufferSize(getWriteBufferSize()).     }     if (isOptionConfigured(MAX_WRITE_BUFFER_NUMBER)) {         currentOptions.setMaxWriteBufferNumber(getMaxWriteBufferNumber()).     }     if (isOptionConfigured(MIN_WRITE_BUFFER_NUMBER_TO_MERGE)) {         currentOptions.setMinWriteBufferNumberToMerge(getMinWriteBufferNumberToMerge()).     }     TableFormatConfig tableFormatConfig = currentOptions.tableFormatConfig().     BlockBasedTableConfig blockBasedTableConfig.     if (tableFormatConfig == null) {         blockBasedTableConfig = new BlockBasedTableConfig().     } else {         if (tableFormatConfig instanceof PlainTableConfig) {             // if the table format config is PlainTableConfig, we just return current column-family options             return currentOptions.         } else {             blockBasedTableConfig = (BlockBasedTableConfig) tableFormatConfig.         }     }     if (isOptionConfigured(BLOCK_SIZE)) {         blockBasedTableConfig.setBlockSize(getBlockSize()).     }     if (isOptionConfigured(BLOCK_CACHE_SIZE)) {         blockBasedTableConfig.setBlockCacheSize(getBlockCacheSize()).     }     return currentOptions.setTableFormatConfig(blockBasedTableConfig). }
false;public;0;3;;public Map<String, String> getConfiguredOptions() {     return new HashMap<>(configuredOptions). }
false;private;1;3;;private boolean isOptionConfigured(ConfigOption configOption) {     return configuredOptions.containsKey(configOption.key()). }
false;private;0;3;;// -------------------------------------------------------------------------- // Maximum number of concurrent background flush and compaction threads // -------------------------------------------------------------------------- private int getMaxBackgroundThreads() {     return Integer.parseInt(getInternal(MAX_BACKGROUND_THREADS.key())). }
false;public;1;5;;public DefaultConfigurableOptionsFactory setMaxBackgroundThreads(int totalThreadCount) {     Preconditions.checkArgument(totalThreadCount > 0).     configuredOptions.put(MAX_BACKGROUND_THREADS.key(), String.valueOf(totalThreadCount)).     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // Maximum number of open files // -------------------------------------------------------------------------- private int getMaxOpenFiles() {     return Integer.parseInt(getInternal(MAX_OPEN_FILES.key())). }
false;public;1;4;;public DefaultConfigurableOptionsFactory setMaxOpenFiles(int maxOpenFiles) {     configuredOptions.put(MAX_OPEN_FILES.key(), String.valueOf(maxOpenFiles)).     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // The style of compaction for DB. // -------------------------------------------------------------------------- private CompactionStyle getCompactionStyle() {     return CompactionStyle.valueOf(getInternal(COMPACTION_STYLE.key()).toUpperCase()). }
false;public;1;4;;public DefaultConfigurableOptionsFactory setCompactionStyle(CompactionStyle compactionStyle) {     setInternal(COMPACTION_STYLE.key(), compactionStyle.name()).     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // Whether to configure RocksDB to pick target size of each level dynamically. // -------------------------------------------------------------------------- private boolean getUseDynamicLevelSize() {     return getInternal(USE_DYNAMIC_LEVEL_SIZE.key()).compareToIgnoreCase("false") != 0. }
false;public;1;4;;public DefaultConfigurableOptionsFactory setUseDynamicLevelSize(boolean value) {     configuredOptions.put(USE_DYNAMIC_LEVEL_SIZE.key(), value ? "true" : "false").     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // The target file size for compaction, i.e., the per-file size for level-1 // -------------------------------------------------------------------------- private long getTargetFileSizeBase() {     return MemorySize.parseBytes(getInternal(TARGET_FILE_SIZE_BASE.key())). }
false;public;1;6;;public DefaultConfigurableOptionsFactory setTargetFileSizeBase(String targetFileSizeBase) {     Preconditions.checkArgument(MemorySize.parseBytes(targetFileSizeBase) > 0, "Invalid configuration " + targetFileSizeBase + " for target file size base.").     setInternal(TARGET_FILE_SIZE_BASE.key(), targetFileSizeBase).     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // Maximum total data size for a level, i.e., the max total size for level-1 // -------------------------------------------------------------------------- private long getMaxSizeLevelBase() {     return MemorySize.parseBytes(getInternal(MAX_SIZE_LEVEL_BASE.key())). }
false;public;1;6;;public DefaultConfigurableOptionsFactory setMaxSizeLevelBase(String maxSizeLevelBase) {     Preconditions.checkArgument(MemorySize.parseBytes(maxSizeLevelBase) > 0, "Invalid configuration " + maxSizeLevelBase + " for max size of level base.").     setInternal(MAX_SIZE_LEVEL_BASE.key(), maxSizeLevelBase).     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // Amount of data to build up in memory (backed by an unsorted log on disk) // before converting to a sorted on-disk file. Larger values increase // performance, especially during bulk loads. // -------------------------------------------------------------------------- private long getWriteBufferSize() {     return MemorySize.parseBytes(getInternal(WRITE_BUFFER_SIZE.key())). }
false;public;1;7;;public DefaultConfigurableOptionsFactory setWriteBufferSize(String writeBufferSize) {     Preconditions.checkArgument(MemorySize.parseBytes(writeBufferSize) > 0, "Invalid configuration " + writeBufferSize + " for write-buffer size.").     setInternal(WRITE_BUFFER_SIZE.key(), writeBufferSize).     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // The maximum number of write buffers that are built up in memory. // -------------------------------------------------------------------------- private int getMaxWriteBufferNumber() {     return Integer.parseInt(getInternal(MAX_WRITE_BUFFER_NUMBER.key())). }
false;public;1;6;;public DefaultConfigurableOptionsFactory setMaxWriteBufferNumber(int writeBufferNumber) {     Preconditions.checkArgument(writeBufferNumber > 0, "Invalid configuration " + writeBufferNumber + " for max write-buffer number.").     setInternal(MAX_WRITE_BUFFER_NUMBER.key(), Integer.toString(writeBufferNumber)).     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // The minimum number that will be merged together before writing to storage // -------------------------------------------------------------------------- private int getMinWriteBufferNumberToMerge() {     return Integer.parseInt(getInternal(MIN_WRITE_BUFFER_NUMBER_TO_MERGE.key())). }
false;public;1;6;;public DefaultConfigurableOptionsFactory setMinWriteBufferNumberToMerge(int writeBufferNumber) {     Preconditions.checkArgument(writeBufferNumber > 0, "Invalid configuration " + writeBufferNumber + " for min write-buffer number to merge.").     setInternal(MIN_WRITE_BUFFER_NUMBER_TO_MERGE.key(), Integer.toString(writeBufferNumber)).     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // Approximate size of user data packed per block. Note that the block size // specified here corresponds to uncompressed data. The actual size of the // unit read from disk may be smaller if compression is enabled // -------------------------------------------------------------------------- private long getBlockSize() {     return MemorySize.parseBytes(getInternal(BLOCK_SIZE.key())). }
false;public;1;6;;public DefaultConfigurableOptionsFactory setBlockSize(String blockSize) {     Preconditions.checkArgument(MemorySize.parseBytes(blockSize) > 0, "Invalid configuration " + blockSize + " for block size.").     setInternal(BLOCK_SIZE.key(), blockSize).     return this. }
false;private;0;3;;// -------------------------------------------------------------------------- // The amount of the cache for data blocks in RocksDB // -------------------------------------------------------------------------- private long getBlockCacheSize() {     return MemorySize.parseBytes(getInternal(BLOCK_CACHE_SIZE.key())). }
false;public;1;7;;public DefaultConfigurableOptionsFactory setBlockCacheSize(String blockCacheSize) {     Preconditions.checkArgument(MemorySize.parseBytes(blockCacheSize) > 0, "Invalid configuration " + blockCacheSize + " for block cache size.").     setInternal(BLOCK_CACHE_SIZE.key(), blockCacheSize).     return this. }
true;public;1;13;/**  * Creates a {@link DefaultConfigurableOptionsFactory} instance from a {@link Configuration}.  *  * <p>If no options within {@link RocksDBConfigurableOptions} has ever been configured,  * the created OptionsFactory would not override anything defined in {@link PredefinedOptions}.  *  * @param configuration Configuration to be used for the ConfigurableOptionsFactory creation  * @return A ConfigurableOptionsFactory created from the given configuration  */ ;/**  * Creates a {@link DefaultConfigurableOptionsFactory} instance from a {@link Configuration}.  *  * <p>If no options within {@link RocksDBConfigurableOptions} has ever been configured,  * the created OptionsFactory would not override anything defined in {@link PredefinedOptions}.  *  * @param configuration Configuration to be used for the ConfigurableOptionsFactory creation  * @return A ConfigurableOptionsFactory created from the given configuration  */ @Override public DefaultConfigurableOptionsFactory configure(Configuration configuration) {     for (String key : CANDIDATE_CONFIGS) {         String newValue = configuration.getString(key, null).         if (newValue != null) {             if (checkArgumentValid(key, newValue)) {                 this.configuredOptions.put(key, newValue).             }         }     }     return this. }
false;public;0;6;;@Override public String toString() {     return "DefaultConfigurableOptionsFactory{" + "configuredOptions=" + configuredOptions + '}'. }
true;private,static;2;20;/**  * Helper method to check whether the (key,value) is valid through given configuration and returns the formatted value.  *  * @param key The configuration key which is configurable in {@link RocksDBConfigurableOptions}.  * @param value The value within given configuration.  *  * @return whether the given key and value in string format is legal.  */ ;/**  * Helper method to check whether the (key,value) is valid through given configuration and returns the formatted value.  *  * @param key The configuration key which is configurable in {@link RocksDBConfigurableOptions}.  * @param value The value within given configuration.  *  * @return whether the given key and value in string format is legal.  */ private static boolean checkArgumentValid(String key, String value) {     if (POSITIVE_INT_CONFIG_SET.contains(key)) {         Preconditions.checkArgument(Integer.parseInt(value) > 0, "Configured value for key: " + key + " must be larger than 0.").     } else if (SIZE_CONFIG_SET.contains(key)) {         Preconditions.checkArgument(MemorySize.parseBytes(value) > 0, "Configured size for key" + key + " must be larger than 0.").     } else if (BOOLEAN_CONFIG_SET.contains(key)) {         Preconditions.checkArgument("true".equalsIgnoreCase(value) || "false".equalsIgnoreCase(value), "The configured boolean value: " + value + " for key: " + key + " is illegal.").     } else if (key.equals(COMPACTION_STYLE.key())) {         value = value.toLowerCase().         Preconditions.checkArgument(COMPACTION_STYLE_SET.contains(value), "Compression type: " + value + " is not recognized with legal types: " + String.join(", ", COMPACTION_STYLE_SET)).     }     return true. }
true;private;2;6;/**  * Sets the configuration with (key, value) if the key is predefined, otherwise throws IllegalArgumentException.  *  * @param key The configuration key, if key is not predefined, throws IllegalArgumentException out.  * @param value The configuration value.  */ ;/**  * Sets the configuration with (key, value) if the key is predefined, otherwise throws IllegalArgumentException.  *  * @param key The configuration key, if key is not predefined, throws IllegalArgumentException out.  * @param value The configuration value.  */ private void setInternal(String key, String value) {     Preconditions.checkArgument(value != null && !value.isEmpty(), "The configuration value must not be empty.").     configuredOptions.put(key, value). }
true;private;1;6;/**  * Returns the value in string format with the given key.  *  * @param key The configuration-key to query in string format.  */ ;/**  * Returns the value in string format with the given key.  *  * @param key The configuration-key to query in string format.  */ private String getInternal(String key) {     Preconditions.checkArgument(configuredOptions.containsKey(key), "The configuration " + key + " has not been configured.").     return configuredOptions.get(key). }
