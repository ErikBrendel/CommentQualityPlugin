commented;modifiers;parameterAmount;loc;comment;code
true;public;3;28;/**  * Upload all the files to checkpoint fileSystem using specified number of threads.  *  * @param files The files will be uploaded to checkpoint filesystem.  * @param checkpointStreamFactory The checkpoint streamFactory used to create outputstream.  *  * @throws Exception Thrown if can not upload all the files.  */ ;/**  * Upload all the files to checkpoint fileSystem using specified number of threads.  *  * @param files The files will be uploaded to checkpoint filesystem.  * @param checkpointStreamFactory The checkpoint streamFactory used to create outputstream.  *  * @throws Exception Thrown if can not upload all the files.  */ public Map<StateHandleID, StreamStateHandle> uploadFilesToCheckpointFs(@Nonnull Map<StateHandleID, Path> files, CheckpointStreamFactory checkpointStreamFactory, CloseableRegistry closeableRegistry) throws Exception {     Map<StateHandleID, StreamStateHandle> handles = new HashMap<>().     Map<StateHandleID, CompletableFuture<StreamStateHandle>> futures = createUploadFutures(files, checkpointStreamFactory, closeableRegistry).     try {         FutureUtils.waitForAll(futures.values()).get().         for (Map.Entry<StateHandleID, CompletableFuture<StreamStateHandle>> entry : futures.entrySet()) {             handles.put(entry.getKey(), entry.getValue().get()).         }     } catch (ExecutionException e) {         Throwable throwable = ExceptionUtils.stripExecutionException(e).         throwable = ExceptionUtils.stripException(throwable, RuntimeException.class).         if (throwable instanceof IOException) {             throw (IOException) throwable.         } else {             throw new FlinkRuntimeException("Failed to download data for state handles.", e).         }     }     return handles. }
false;private;3;14;;private Map<StateHandleID, CompletableFuture<StreamStateHandle>> createUploadFutures(Map<StateHandleID, Path> files, CheckpointStreamFactory checkpointStreamFactory, CloseableRegistry closeableRegistry) {     Map<StateHandleID, CompletableFuture<StreamStateHandle>> futures = new HashMap<>(files.size()).     for (Map.Entry<StateHandleID, Path> entry : files.entrySet()) {         final Supplier<StreamStateHandle> supplier = CheckedSupplier.unchecked(() -> uploadLocalFileToCheckpointFs(entry.getValue(), checkpointStreamFactory, closeableRegistry)).         futures.put(entry.getKey(), CompletableFuture.supplyAsync(supplier, executorService)).     }     return futures. }
false;private;3;46;;private StreamStateHandle uploadLocalFileToCheckpointFs(Path filePath, CheckpointStreamFactory checkpointStreamFactory, CloseableRegistry closeableRegistry) throws IOException {     FSDataInputStream inputStream = null.     CheckpointStreamFactory.CheckpointStateOutputStream outputStream = null.     try {         final byte[] buffer = new byte[READ_BUFFER_SIZE].         FileSystem backupFileSystem = filePath.getFileSystem().         inputStream = backupFileSystem.open(filePath).         closeableRegistry.registerCloseable(inputStream).         outputStream = checkpointStreamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.SHARED).         closeableRegistry.registerCloseable(outputStream).         while (true) {             int numBytes = inputStream.read(buffer).             if (numBytes == -1) {                 break.             }             outputStream.write(buffer, 0, numBytes).         }         StreamStateHandle result = null.         if (closeableRegistry.unregisterCloseable(outputStream)) {             result = outputStream.closeAndGetHandle().             outputStream = null.         }         return result.     } finally {         if (closeableRegistry.unregisterCloseable(inputStream)) {             IOUtils.closeQuietly(inputStream).         }         if (closeableRegistry.unregisterCloseable(outputStream)) {             IOUtils.closeQuietly(outputStream).         }     } }
