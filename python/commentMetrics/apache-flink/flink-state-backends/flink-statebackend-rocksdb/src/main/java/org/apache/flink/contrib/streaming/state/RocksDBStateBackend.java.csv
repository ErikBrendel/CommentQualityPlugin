commented;modifiers;parameterAmount;loc;comment;code
true;public;2;4;/**  * Creates a copy of this state backend that uses the values defined in the configuration  * for fields where that were not yet specified in this state backend.  *  * @param config The configuration.  * @param classLoader The class loader.  * @return The re-configured variant of the state backend  */ ;// ------------------------------------------------------------------------ // Reconfiguration // ------------------------------------------------------------------------ /**  * Creates a copy of this state backend that uses the values defined in the configuration  * for fields where that were not yet specified in this state backend.  *  * @param config The configuration.  * @param classLoader The class loader.  * @return The re-configured variant of the state backend  */ @Override public RocksDBStateBackend configure(Configuration config, ClassLoader classLoader) {     return new RocksDBStateBackend(this, config, classLoader). }
true;public;0;3;/**  * Gets the state backend that this RocksDB state backend uses to persist  * its bytes to.  *  * <p>This RocksDB state backend only implements the RocksDB specific parts, it  * relies on the 'CheckpointBackend' to persist the checkpoint and savepoint bytes  * streams.  */ ;// ------------------------------------------------------------------------ // State backend methods // ------------------------------------------------------------------------ /**  * Gets the state backend that this RocksDB state backend uses to persist  * its bytes to.  *  * <p>This RocksDB state backend only implements the RocksDB specific parts, it  * relies on the 'CheckpointBackend' to persist the checkpoint and savepoint bytes  * streams.  */ public StateBackend getCheckpointBackend() {     return checkpointStreamBackend. }
false;private;2;44;;private void lazyInitializeForJob(Environment env, @SuppressWarnings("unused") String operatorIdentifier) throws IOException {     if (isInitialized) {         return.     }     this.jobId = env.getJobID().     // initialize the paths where the local RocksDB files should be stored     if (localRocksDbDirectories == null) {         // initialize from the temp directories         initializedDbBasePaths = env.getIOManager().getSpillingDirectories().     } else {         List<File> dirs = new ArrayList<>(localRocksDbDirectories.length).         StringBuilder errorMessage = new StringBuilder().         for (File f : localRocksDbDirectories) {             File testDir = new File(f, UUID.randomUUID().toString()).             if (!testDir.mkdirs()) {                 String msg = "Local DB files directory '" + f + "' does not exist and cannot be created. ".                 LOG.error(msg).                 errorMessage.append(msg).             } else {                 dirs.add(f).             }             // noinspection ResultOfMethodCallIgnored             testDir.delete().         }         if (dirs.isEmpty()) {             throw new IOException("No local storage directories available. " + errorMessage).         } else {             initializedDbBasePaths = dirs.toArray(new File[dirs.size()]).         }     }     nextDirectory = new Random().nextInt(initializedDbBasePaths.length).     isInitialized = true. }
false;private;0;7;;private File getNextStoragePath() {     int ni = nextDirectory + 1.     ni = ni >= initializedDbBasePaths.length ? 0 : ni.     nextDirectory = ni.     return initializedDbBasePaths[ni]. }
false;public;1;4;;// ------------------------------------------------------------------------ // Checkpoint initialization and persistent storage // ------------------------------------------------------------------------ @Override public CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {     return checkpointStreamBackend.resolveCheckpoint(pointer). }
false;public;1;4;;@Override public CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {     return checkpointStreamBackend.createCheckpointStorage(jobId). }
false;public;10;55;;// ------------------------------------------------------------------------ // State holding data structures // ------------------------------------------------------------------------ @Override public <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(Environment env, JobID jobID, String operatorIdentifier, TypeSerializer<K> keySerializer, int numberOfKeyGroups, KeyGroupRange keyGroupRange, TaskKvStateRegistry kvStateRegistry, TtlTimeProvider ttlTimeProvider, MetricGroup metricGroup, @Nonnull Collection<KeyedStateHandle> stateHandles) throws IOException {     // first, make sure that the RocksDB JNI library is loaded     // we do this explicitly here to have better error handling     String tempDir = env.getTaskManagerInfo().getTmpDirectories()[0].     ensureRocksDBIsLoaded(tempDir).     // replace all characters that are not legal for filenames with underscore     String fileCompatibleIdentifier = operatorIdentifier.replaceAll("[^a-zA-Z0-9\\-]", "_").     lazyInitializeForJob(env, fileCompatibleIdentifier).     File instanceBasePath = new File(getNextStoragePath(), "job_" + jobId + "_op_" + fileCompatibleIdentifier + "_uuid_" + UUID.randomUUID()).     LocalRecoveryConfig localRecoveryConfig = env.getTaskStateManager().createLocalRecoveryConfig().     ExecutionConfig executionConfig = env.getExecutionConfig().     StreamCompressionDecorator keyGroupCompressionDecorator = getCompressionDecorator(executionConfig).     RocksDBKeyedStateBackendBuilder<K> builder = new RocksDBKeyedStateBackendBuilder<>(operatorIdentifier, env.getUserClassLoader(), instanceBasePath, getDbOptions(), stateName -> getColumnOptions(), kvStateRegistry, keySerializer, numberOfKeyGroups, keyGroupRange, executionConfig, localRecoveryConfig, priorityQueueStateType, ttlTimeProvider, metricGroup, stateHandles, keyGroupCompressionDecorator).setEnableIncrementalCheckpointing(isIncrementalCheckpointsEnabled()).setEnableTtlCompactionFilter(isTtlCompactionFilterEnabled()).setNumberOfTransferingThreads(getNumberOfTransferingThreads()).setNativeMetricOptions(getMemoryWatcherOptions()).     return builder.build(). }
false;public,static;1;7;;public static StreamCompressionDecorator getCompressionDecorator(ExecutionConfig executionConfig) {     if (executionConfig != null && executionConfig.isUseSnapshotCompression()) {         return SnappyStreamCompressionDecorator.INSTANCE.     } else {         return UncompressedStreamCompressionDecorator.INSTANCE.     } }
false;public;2;12;;@Override public OperatorStateBackend createOperatorStateBackend(Environment env, String operatorIdentifier) throws Exception {     // the default for RocksDB. eventually there can be a operator state backend based on RocksDB, too.     final boolean asyncSnapshots = true.     return new DefaultOperatorStateBackend(env.getUserClassLoader(), env.getExecutionConfig(), asyncSnapshots). }
false;private;4;46;;private OptionsFactory configureOptionsFactory(@Nullable OptionsFactory originalOptionsFactory, String factoryClassName, Configuration config, ClassLoader classLoader) throws DynamicCodeLoadingException {     if (originalOptionsFactory != null) {         if (originalOptionsFactory instanceof ConfigurableOptionsFactory) {             originalOptionsFactory = ((ConfigurableOptionsFactory) originalOptionsFactory).configure(config).         }         LOG.info("Using application-defined options factory: {}.", originalOptionsFactory).         return originalOptionsFactory.     }     // if using DefaultConfigurableOptionsFactory by default, we could avoid reflection to speed up.     if (factoryClassName.equalsIgnoreCase(DefaultConfigurableOptionsFactory.class.getName())) {         DefaultConfigurableOptionsFactory optionsFactory = new DefaultConfigurableOptionsFactory().         optionsFactory.configure(config).         LOG.info("Using default options factory: {}.", optionsFactory).         return optionsFactory.     } else {         try {             @SuppressWarnings("rawtypes")             Class<? extends OptionsFactory> clazz = Class.forName(factoryClassName, false, classLoader).asSubclass(OptionsFactory.class).             OptionsFactory optionsFactory = clazz.newInstance().             if (optionsFactory instanceof ConfigurableOptionsFactory) {                 optionsFactory = ((ConfigurableOptionsFactory) optionsFactory).configure(config).             }             LOG.info("Using configured options factory: {}.", optionsFactory).             return optionsFactory.         } catch (ClassNotFoundException e) {             throw new DynamicCodeLoadingException("Cannot find configured options factory class: " + factoryClassName, e).         } catch (ClassCastException | InstantiationException | IllegalAccessException e) {             throw new DynamicCodeLoadingException("The class configured under '" + RocksDBOptions.OPTIONS_FACTORY.key() + "' is not a valid options factory (" + factoryClassName + ')', e).         }     } }
true;public;1;3;/**  * Sets the path where the RocksDB local database files should be stored on the local  * file system. Setting this path overrides the default behavior, where the  * files are stored across the configured temp directories.  *  * <p>Passing {@code null} to this function restores the default behavior, where the configured  * temp directories will be used.  *  * @param path The path where the local RocksDB database files are stored.  */ ;// ------------------------------------------------------------------------ // Parameters // ------------------------------------------------------------------------ /**  * Sets the path where the RocksDB local database files should be stored on the local  * file system. Setting this path overrides the default behavior, where the  * files are stored across the configured temp directories.  *  * <p>Passing {@code null} to this function restores the default behavior, where the configured  * temp directories will be used.  *  * @param path The path where the local RocksDB database files are stored.  */ public void setDbStoragePath(String path) {     setDbStoragePaths(path == null ? null : new String[] { path }). }
true;public;1;49;/**  * Sets the directories in which the local RocksDB database puts its files (like SST and  * metadata files). These directories do not need to be persistent, they can be ephemeral,  * meaning that they are lost on a machine failure, because state in RocksDB is persisted  * in checkpoints.  *  * <p>If nothing is configured, these directories default to the TaskManager's local  * temporary file directories.  *  * <p>Each distinct state will be stored in one path, but when the state backend creates  * multiple states, they will store their files on different paths.  *  * <p>Passing {@code null} to this function restores the default behavior, where the configured  * temp directories will be used.  *  * @param paths The paths across which the local RocksDB database files will be spread.  */ ;/**  * Sets the directories in which the local RocksDB database puts its files (like SST and  * metadata files). These directories do not need to be persistent, they can be ephemeral,  * meaning that they are lost on a machine failure, because state in RocksDB is persisted  * in checkpoints.  *  * <p>If nothing is configured, these directories default to the TaskManager's local  * temporary file directories.  *  * <p>Each distinct state will be stored in one path, but when the state backend creates  * multiple states, they will store their files on different paths.  *  * <p>Passing {@code null} to this function restores the default behavior, where the configured  * temp directories will be used.  *  * @param paths The paths across which the local RocksDB database files will be spread.  */ public void setDbStoragePaths(String... paths) {     if (paths == null) {         localRocksDbDirectories = null.     } else if (paths.length == 0) {         throw new IllegalArgumentException("empty paths").     } else {         File[] pp = new File[paths.length].         for (int i = 0. i < paths.length. i++) {             final String rawPath = paths[i].             final String path.             if (rawPath == null) {                 throw new IllegalArgumentException("null path").             } else {                 // we need this for backwards compatibility, to allow URIs like 'file:///'...                 URI uri = null.                 try {                     uri = new Path(rawPath).toUri().                 } catch (Exception e) {                 // cannot parse as a path                 }                 if (uri != null && uri.getScheme() != null) {                     if ("file".equalsIgnoreCase(uri.getScheme())) {                         path = uri.getPath().                     } else {                         throw new IllegalArgumentException("Path " + rawPath + " has a non-local scheme").                     }                 } else {                     path = rawPath.                 }             }             pp[i] = new File(path).             if (!pp[i].isAbsolute()) {                 throw new IllegalArgumentException("Relative paths are not supported").             }         }         localRocksDbDirectories = pp.     } }
true;public;0;11;/**  * Gets the configured local DB storage paths, or null, if none were configured.  *  * <p>Under these directories on the TaskManager, RocksDB stores its SST files and  * metadata files. These directories do not need to be persistent, they can be ephermeral,  * meaning that they are lost on a machine failure, because state in RocksDB is persisted  * in checkpoints.  *  * <p>If nothing is configured, these directories default to the TaskManager's local  * temporary file directories.  */ ;/**  * Gets the configured local DB storage paths, or null, if none were configured.  *  * <p>Under these directories on the TaskManager, RocksDB stores its SST files and  * metadata files. These directories do not need to be persistent, they can be ephermeral,  * meaning that they are lost on a machine failure, because state in RocksDB is persisted  * in checkpoints.  *  * <p>If nothing is configured, these directories default to the TaskManager's local  * temporary file directories.  */ public String[] getDbStoragePaths() {     if (localRocksDbDirectories == null) {         return null.     } else {         String[] paths = new String[localRocksDbDirectories.length].         for (int i = 0. i < paths.length. i++) {             paths[i] = localRocksDbDirectories[i].toString().         }         return paths.     } }
true;public;0;3;/**  * Gets whether incremental checkpoints are enabled for this state backend.  */ ;/**  * Gets whether incremental checkpoints are enabled for this state backend.  */ public boolean isIncrementalCheckpointsEnabled() {     return enableIncrementalCheckpointing.getOrDefault(CheckpointingOptions.INCREMENTAL_CHECKPOINTS.defaultValue()). }
true;public;0;3;/**  * Gets whether incremental checkpoints are enabled for this state backend.  */ ;/**  * Gets whether incremental checkpoints are enabled for this state backend.  */ public boolean isTtlCompactionFilterEnabled() {     return enableTtlCompactionFilter.getOrDefault(TTL_COMPACT_FILTER_ENABLED.defaultValue()). }
true;public;0;3;/**  * Enable compaction filter to cleanup state with TTL is enabled.  *  * <p>Note: User can still decide in state TTL configuration in state descriptor  * whether the filter is active for particular state or not.  */ ;/**  * Enable compaction filter to cleanup state with TTL is enabled.  *  * <p>Note: User can still decide in state TTL configuration in state descriptor  * whether the filter is active for particular state or not.  */ public void enableTtlCompactionFilter() {     enableTtlCompactionFilter = TernaryBoolean.TRUE. }
true;public;1;3;/**  * Sets the predefined options for RocksDB.  *  * <p>If user-configured options within {@link RocksDBConfigurableOptions} is set (through flink-conf.yaml)  * or a user-defined options factory is set (via {@link #setOptions(OptionsFactory)}),  * then the options from the factory are applied on top of the here specified  * predefined options and customized options.  *  * @param options The options to set (must not be null).  */ ;// ------------------------------------------------------------------------ // Parametrize with RocksDB Options // ------------------------------------------------------------------------ /**  * Sets the predefined options for RocksDB.  *  * <p>If user-configured options within {@link RocksDBConfigurableOptions} is set (through flink-conf.yaml)  * or a user-defined options factory is set (via {@link #setOptions(OptionsFactory)}),  * then the options from the factory are applied on top of the here specified  * predefined options and customized options.  *  * @param options The options to set (must not be null).  */ public void setPredefinedOptions(PredefinedOptions options) {     predefinedOptions = checkNotNull(options). }
true;public;0;6;/**  * Gets the currently set predefined options for RocksDB.  * The default options (if nothing was set via {@link #setPredefinedOptions(PredefinedOptions)})  * are {@link PredefinedOptions#DEFAULT}.  *  * <p>If user-configured options within {@link RocksDBConfigurableOptions} is set (through flink-conf.yaml)  * of a user-defined options factory is set (via {@link #setOptions(OptionsFactory)}),  * then the options from the factory are applied on top of the predefined and customized options.  *  * @return The currently set predefined options for RocksDB.  */ ;/**  * Gets the currently set predefined options for RocksDB.  * The default options (if nothing was set via {@link #setPredefinedOptions(PredefinedOptions)})  * are {@link PredefinedOptions#DEFAULT}.  *  * <p>If user-configured options within {@link RocksDBConfigurableOptions} is set (through flink-conf.yaml)  * of a user-defined options factory is set (via {@link #setOptions(OptionsFactory)}),  * then the options from the factory are applied on top of the predefined and customized options.  *  * @return The currently set predefined options for RocksDB.  */ public PredefinedOptions getPredefinedOptions() {     if (predefinedOptions == null) {         predefinedOptions = PredefinedOptions.DEFAULT.     }     return predefinedOptions. }
true;public;1;3;/**  * Sets {@link org.rocksdb.Options} for the RocksDB instances.  * Because the options are not serializable and hold native code references,  * they must be specified through a factory.  *  * <p>The options created by the factory here are applied on top of the pre-defined  * options profile selected via {@link #setPredefinedOptions(PredefinedOptions)}.  * If the pre-defined options profile is the default  * ({@link PredefinedOptions#DEFAULT}), then the factory fully controls the RocksDB  * options.  *  * @param optionsFactory The options factory that lazily creates the RocksDB options.  */ ;/**  * Sets {@link org.rocksdb.Options} for the RocksDB instances.  * Because the options are not serializable and hold native code references,  * they must be specified through a factory.  *  * <p>The options created by the factory here are applied on top of the pre-defined  * options profile selected via {@link #setPredefinedOptions(PredefinedOptions)}.  * If the pre-defined options profile is the default  * ({@link PredefinedOptions#DEFAULT}), then the factory fully controls the RocksDB  * options.  *  * @param optionsFactory The options factory that lazily creates the RocksDB options.  */ public void setOptions(OptionsFactory optionsFactory) {     this.optionsFactory = optionsFactory. }
true;public;0;3;/**  * Gets the options factory that lazily creates the RocksDB options.  *  * @return The options factory.  */ ;/**  * Gets the options factory that lazily creates the RocksDB options.  *  * @return The options factory.  */ public OptionsFactory getOptions() {     return optionsFactory. }
true;public;0;14;/**  * Gets the RocksDB {@link DBOptions} to be used for all RocksDB instances.  */ ;/**  * Gets the RocksDB {@link DBOptions} to be used for all RocksDB instances.  */ public DBOptions getDbOptions() {     // initial options from pre-defined profile     DBOptions opt = getPredefinedOptions().createDBOptions().     // add user-defined options factory, if specified     if (optionsFactory != null) {         opt = optionsFactory.createDBOptions(opt).     }     // add necessary default options     opt = opt.setCreateIfMissing(true).     return opt. }
true;public;0;11;/**  * Gets the RocksDB {@link ColumnFamilyOptions} to be used for all RocksDB instances.  */ ;/**  * Gets the RocksDB {@link ColumnFamilyOptions} to be used for all RocksDB instances.  */ public ColumnFamilyOptions getColumnOptions() {     // initial options from pre-defined profile     ColumnFamilyOptions opt = getPredefinedOptions().createColumnOptions().     // add user-defined options, if specified     if (optionsFactory != null) {         opt = optionsFactory.createColumnOptions(opt).     }     return opt. }
false;public;0;8;;public RocksDBNativeMetricOptions getMemoryWatcherOptions() {     RocksDBNativeMetricOptions options = this.defaultMetricOptions.     if (optionsFactory != null) {         options = optionsFactory.createNativeMetricsOptions(options).     }     return options. }
true;public;0;4;/**  * Gets the number of threads used to transfer files while snapshotting/restoring.  */ ;/**  * Gets the number of threads used to transfer files while snapshotting/restoring.  */ public int getNumberOfTransferingThreads() {     return numberOfTransferingThreads == UNDEFINED_NUMBER_OF_TRANSFERING_THREADS ? CHECKPOINT_TRANSFER_THREAD_NUM.defaultValue() : numberOfTransferingThreads. }
true;public;1;5;/**  * Sets the number of threads used to transfer files while snapshotting/restoring.  *  * @param numberOfTransferingThreads The number of threads used to transfer files while snapshotting/restoring.  */ ;/**  * Sets the number of threads used to transfer files while snapshotting/restoring.  *  * @param numberOfTransferingThreads The number of threads used to transfer files while snapshotting/restoring.  */ public void setNumberOfTransferingThreads(int numberOfTransferingThreads) {     Preconditions.checkArgument(numberOfTransferingThreads > 0, "The number of threads used to transfer files in RocksDBStateBackend should be greater than zero.").     this.numberOfTransferingThreads = numberOfTransferingThreads. }
false;public;0;9;;// ------------------------------------------------------------------------ // utilities // ------------------------------------------------------------------------ @Override public String toString() {     return "RocksDBStateBackend{" + "checkpointStreamBackend=" + checkpointStreamBackend + ", localRocksDbDirectories=" + Arrays.toString(localRocksDbDirectories) + ", enableIncrementalCheckpointing=" + enableIncrementalCheckpointing + ", numberOfTransferingThreads=" + numberOfTransferingThreads + '}'. }
false;private;1;55;;// ------------------------------------------------------------------------ // static library loading utilities // ------------------------------------------------------------------------ private void ensureRocksDBIsLoaded(String tempDirectory) throws IOException {     synchronized (RocksDBStateBackend.class) {         if (!rocksDbInitialized) {             final File tempDirParent = new File(tempDirectory).getAbsoluteFile().             LOG.info("Attempting to load RocksDB native library and store it under '{}'", tempDirParent).             Throwable lastException = null.             for (int attempt = 1. attempt <= ROCKSDB_LIB_LOADING_ATTEMPTS. attempt++) {                 try {                     // when multiple instances of this class and RocksDB exist in different                     // class loaders, then we can see the following exception:                     // "java.lang.UnsatisfiedLinkError: Native Library /path/to/temp/dir/librocksdbjni-linux64.so                     // already loaded in another class loader"                     // to avoid that, we need to add a random element to the library file path                     // (I know, seems like an unnecessary hack, since the JVM obviously can handle multiple                     // instances of the same JNI library being loaded in different class loaders, but                     // apparently not when coming from the same file path, so there we go)                     final File rocksLibFolder = new File(tempDirParent, "rocksdb-lib-" + new AbstractID()).                     // make sure the temp path exists                     LOG.debug("Attempting to create RocksDB native library folder {}", rocksLibFolder).                     // noinspection ResultOfMethodCallIgnored                     rocksLibFolder.mkdirs().                     // explicitly load the JNI dependency if it has not been loaded before                     NativeLibraryLoader.getInstance().loadLibrary(rocksLibFolder.getAbsolutePath()).                     // this initialization here should validate that the loading succeeded                     RocksDB.loadLibrary().                     // seems to have worked                     LOG.info("Successfully loaded RocksDB native library").                     rocksDbInitialized = true.                     return.                 } catch (Throwable t) {                     lastException = t.                     LOG.debug("RocksDB JNI library loading attempt {} failed", attempt, t).                     // try to force RocksDB to attempt reloading the library                     try {                         resetRocksDBLoadedFlag().                     } catch (Throwable tt) {                         LOG.debug("Failed to reset 'initialized' flag in RocksDB native code loader", tt).                     }                 }             }             throw new IOException("Could not load the native RocksDB library", lastException).         }     } }
false;static;0;6;;@VisibleForTesting static void resetRocksDBLoadedFlag() throws Exception {     final Field initField = org.rocksdb.NativeLibraryLoader.class.getDeclaredField("initialized").     initField.setAccessible(true).     initField.setBoolean(null, false). }
