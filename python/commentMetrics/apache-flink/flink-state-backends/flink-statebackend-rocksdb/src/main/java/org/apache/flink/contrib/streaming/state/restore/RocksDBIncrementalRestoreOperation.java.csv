commented;modifiers;parameterAmount;loc;comment;code
true;public;0;20;/**  * Root method that branches for different implementations of {@link KeyedStateHandle}.  */ ;/**  * Root method that branches for different implementations of {@link KeyedStateHandle}.  */ @Override public RocksDBRestoreResult restore() throws Exception {     if (restoreStateHandles == null || restoreStateHandles.isEmpty()) {         return null.     }     final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next().     boolean isRescaling = (restoreStateHandles.size() > 1 || !Objects.equals(theFirstStateHandle.getKeyGroupRange(), keyGroupRange)).     if (isRescaling) {         restoreWithRescaling(restoreStateHandles).     } else {         restoreWithoutRescaling(theFirstStateHandle).     }     return new RocksDBRestoreResult(this.db, defaultColumnFamilyHandle, nativeMetricMonitor, lastCompletedCheckpointId, backendUID, restoredSstFiles). }
true;private;1;17;/**  * Recovery from a single remote incremental state without rescaling.  */ ;/**  * Recovery from a single remote incremental state without rescaling.  */ private void restoreWithoutRescaling(KeyedStateHandle keyedStateHandle) throws Exception {     if (keyedStateHandle instanceof IncrementalRemoteKeyedStateHandle) {         IncrementalRemoteKeyedStateHandle incrementalRemoteKeyedStateHandle = (IncrementalRemoteKeyedStateHandle) keyedStateHandle.         restorePreviousIncrementalFilesStatus(incrementalRemoteKeyedStateHandle).         restoreFromRemoteState(incrementalRemoteKeyedStateHandle).     } else if (keyedStateHandle instanceof IncrementalLocalKeyedStateHandle) {         IncrementalLocalKeyedStateHandle incrementalLocalKeyedStateHandle = (IncrementalLocalKeyedStateHandle) keyedStateHandle.         restorePreviousIncrementalFilesStatus(incrementalLocalKeyedStateHandle).         restoreFromLocalState(incrementalLocalKeyedStateHandle).     } else {         throw new BackendBuildingException("Unexpected state handle type, " + "expected " + IncrementalRemoteKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class + ", but found " + keyedStateHandle.getClass()).     } }
false;private;1;7;;private void restorePreviousIncrementalFilesStatus(IncrementalKeyedStateHandle localKeyedStateHandle) {     backendUID = localKeyedStateHandle.getBackendIdentifier().     restoredSstFiles.put(localKeyedStateHandle.getCheckpointId(), localKeyedStateHandle.getSharedStateHandleIDs()).     lastCompletedCheckpointId = localKeyedStateHandle.getCheckpointId(). }
false;private;1;11;;private void restoreFromRemoteState(IncrementalRemoteKeyedStateHandle stateHandle) throws Exception {     final Path tmpRestoreInstancePath = new Path(instanceBasePath.getAbsolutePath(), // used as restore source for IncrementalRemoteKeyedStateHandle     UUID.randomUUID().toString()).     try {         restoreFromLocalState(transferRemoteStateToLocalDirectory(tmpRestoreInstancePath, stateHandle)).     } finally {         cleanUpPathQuietly(tmpRestoreInstancePath).     } }
false;private;1;23;;private void restoreFromLocalState(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {     KeyedBackendSerializationProxy<K> serializationProxy = readMetaData(localKeyedStateHandle.getMetaDataState()).     List<StateMetaInfoSnapshot> stateMetaInfoSnapshots = serializationProxy.getStateMetaInfoSnapshots().     columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots, true).     columnFamilyHandles = new ArrayList<>(columnFamilyDescriptors.size() + 1).     Path restoreSourcePath = localKeyedStateHandle.getDirectoryStateHandle().getDirectory().     LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.", operatorIdentifier, backendUID).     if (!instanceRocksDBPath.mkdirs()) {         String errMsg = "Could not create RocksDB data directory: " + instanceBasePath.getAbsolutePath().         LOG.error(errMsg).         throw new IOException(errMsg).     }     restoreInstanceDirectoryFromPath(restoreSourcePath, dbPath).     openDB().     registerColumnFamilyHandles(stateMetaInfoSnapshots). }
false;private;2;21;;private IncrementalLocalKeyedStateHandle transferRemoteStateToLocalDirectory(Path temporaryRestoreInstancePath, IncrementalRemoteKeyedStateHandle restoreStateHandle) throws Exception {     try (RocksDBStateDownloader rocksDBStateDownloader = new RocksDBStateDownloader(numberOfTransferringThreads)) {         rocksDBStateDownloader.transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath, cancelStreamRegistry).     }     // local recovery.     return new IncrementalLocalKeyedStateHandle(restoreStateHandle.getBackendIdentifier(), restoreStateHandle.getCheckpointId(), new DirectoryStateHandle(temporaryRestoreInstancePath), restoreStateHandle.getKeyGroupRange(), restoreStateHandle.getMetaStateHandle(), restoreStateHandle.getSharedState().keySet()). }
false;private;1;10;;private void cleanUpPathQuietly(@Nonnull Path path) {     try {         FileSystem fileSystem = path.getFileSystem().         if (fileSystem.exists(path)) {             fileSystem.delete(path, true).         }     } catch (IOException ex) {         LOG.warn("Failed to clean up path " + path, ex).     } }
false;private;1;15;;private void registerColumnFamilyHandles(List<StateMetaInfoSnapshot> metaInfoSnapshots) throws BackendBuildingException {     // Register CF handlers     for (int i = 0. i < metaInfoSnapshots.size(). ++i) {         try {             getOrRegisterStateColumnFamilyHandle(columnFamilyHandles.get(i), metaInfoSnapshots.get(i)).         } catch (RocksDBException e) {             String errMsg = "Failed to register CF handle.".             LOG.error(errMsg, e).             throw new BackendBuildingException(errMsg, e).         }     } }
true;private;1;69;/**  * Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary  * RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the  * real restore instance and then the temporary instance is discarded.  */ ;/**  * Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary  * RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the  * real restore instance and then the temporary instance is discarded.  */ private void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {     // Prepare for restore with rescaling     KeyedStateHandle initialHandle = RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(restoreStateHandles, keyGroupRange).     // Init base DB instance     if (initialHandle != null) {         restoreStateHandles.remove(initialHandle).         initDBWithRescaling(initialHandle).     } else {         openDB().     }     // Transfer remaining key-groups from temporary instance into base DB     byte[] startKeyGroupPrefixBytes = new byte[keyGroupPrefixBytes].     RocksDBKeySerializationUtils.serializeKeyGroup(keyGroupRange.getStartKeyGroup(), startKeyGroupPrefixBytes).     byte[] stopKeyGroupPrefixBytes = new byte[keyGroupPrefixBytes].     RocksDBKeySerializationUtils.serializeKeyGroup(keyGroupRange.getEndKeyGroup() + 1, stopKeyGroupPrefixBytes).     for (KeyedStateHandle rawStateHandle : restoreStateHandles) {         if (!(rawStateHandle instanceof IncrementalRemoteKeyedStateHandle)) {             throw new IllegalStateException("Unexpected state handle type, " + "expected " + IncrementalRemoteKeyedStateHandle.class + ", but found " + rawStateHandle.getClass()).         }         Path temporaryRestoreInstancePath = new Path(instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString()).         try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle((IncrementalRemoteKeyedStateHandle) rawStateHandle, temporaryRestoreInstancePath).             RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(this.db)) {             List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors.             List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles.             // iterating only the requested descriptors automatically skips the default column family handle             for (int i = 0. i < tmpColumnFamilyDescriptors.size(). ++i) {                 ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i).                 ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterStateColumnFamilyHandle(null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i)).columnFamilyHandle.                 try (RocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {                     iterator.seek(startKeyGroupPrefixBytes).                     while (iterator.isValid()) {                         if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {                             writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value()).                         } else {                             // we can just break here.                             break.                         }                         iterator.next().                     }                 }             // releases native iterator resources             }         } finally {             cleanUpPathQuietly(temporaryRestoreInstancePath).         }     } }
false;private;1;21;;private void initDBWithRescaling(KeyedStateHandle initialHandle) throws Exception {     assert (initialHandle instanceof IncrementalRemoteKeyedStateHandle).     // 1. Restore base DB from selected initial handle     restoreFromRemoteState((IncrementalRemoteKeyedStateHandle) initialHandle).     // 2. Clip the base DB instance     try {         RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(db, columnFamilyHandles, keyGroupRange, initialHandle.getKeyGroupRange(), keyGroupPrefixBytes).     } catch (RocksDBException e) {         String errMsg = "Failed to clip DB after initialization.".         LOG.error(errMsg, e).         throw new BackendBuildingException(errMsg, e).     } }
false;public;0;10;;@Override public void close() {     List<ColumnFamilyOptions> columnFamilyOptions = new ArrayList<>(columnFamilyDescriptors.size() + 1).     columnFamilyDescriptors.forEach((cfd) -> columnFamilyOptions.add(cfd.getOptions())).     RocksDBOperationUtils.addColumnFamilyOptionsToCloseLater(columnFamilyOptions, defaultColumnFamilyHandle).     IOUtils.closeQuietly(defaultColumnFamilyHandle).     IOUtils.closeAllQuietly(columnFamilyHandles).     IOUtils.closeQuietly(db).     IOUtils.closeAllQuietly(columnFamilyOptions). }
false;private;2;31;;private RestoredDBInstance restoreDBInstanceFromStateHandle(IncrementalRemoteKeyedStateHandle restoreStateHandle, Path temporaryRestoreInstancePath) throws Exception {     try (RocksDBStateDownloader rocksDBStateDownloader = new RocksDBStateDownloader(numberOfTransferringThreads)) {         rocksDBStateDownloader.transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath, cancelStreamRegistry).     }     KeyedBackendSerializationProxy<K> serializationProxy = readMetaData(restoreStateHandle.getMetaStateHandle()).     // read meta data     List<StateMetaInfoSnapshot> stateMetaInfoSnapshots = serializationProxy.getStateMetaInfoSnapshots().     List<ColumnFamilyDescriptor> columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots, false).     List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(stateMetaInfoSnapshots.size() + 1).     RocksDB restoreDb = RocksDBOperationUtils.openDB(temporaryRestoreInstancePath.getPath(), columnFamilyDescriptors, columnFamilyHandles, RocksDBOperationUtils.createColumnFamilyOptions(columnFamilyOptionsFactory, "default"), dbOptions).     return new RestoredDBInstance(restoreDb, columnFamilyHandles, columnFamilyDescriptors, stateMetaInfoSnapshots). }
true;private;2;22;/**  * This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.  */ ;/**  * This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.  */ private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(List<StateMetaInfoSnapshot> stateMetaInfoSnapshots, boolean registerTtlCompactFilter) {     List<ColumnFamilyDescriptor> columnFamilyDescriptors = new ArrayList<>(stateMetaInfoSnapshots.size()).     for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {         ColumnFamilyOptions options = RocksDBOperationUtils.createColumnFamilyOptions(columnFamilyOptionsFactory, stateMetaInfoSnapshot.getName()).         if (registerTtlCompactFilter) {             ttlCompactFiltersManager.setAndRegisterCompactFilterIfStateTtl(ttlTimeProvider, stateMetaInfoSnapshot, options).         }         ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET), options).         columnFamilyDescriptors.add(columnFamilyDescriptor).     }     return columnFamilyDescriptors. }
true;private;2;24;/**  * This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from  * a local state.  */ ;/**  * This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from  * a local state.  */ private void restoreInstanceDirectoryFromPath(Path source, String instanceRocksDBPath) throws IOException {     FileSystem fileSystem = source.getFileSystem().     final FileStatus[] fileStatuses = fileSystem.listStatus(source).     if (fileStatuses == null) {         throw new IOException("Cannot list file statues. Directory " + source + " does not exist.").     }     for (FileStatus fileStatus : fileStatuses) {         final Path filePath = fileStatus.getPath().         final String fileName = filePath.getName().         File restoreFile = new File(source.getPath(), fileName).         File targetFile = new File(instanceRocksDBPath, fileName).         if (fileName.endsWith(SST_FILE_SUFFIX)) {             // hardlink'ing the immutable sst-files.             Files.createLink(targetFile.toPath(), restoreFile.toPath()).         } else {             // true copy for all other files.             Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING).         }     } }
true;private;1;15;/**  * Reads Flink's state meta data file from the state handle.  */ ;/**  * Reads Flink's state meta data file from the state handle.  */ private KeyedBackendSerializationProxy<K> readMetaData(StreamStateHandle metaStateHandle) throws Exception {     FSDataInputStream inputStream = null.     try {         inputStream = metaStateHandle.openInputStream().         cancelStreamRegistry.registerCloseable(inputStream).         DataInputView in = new DataInputViewStreamWrapper(inputStream).         return readMetaData(in).     } finally {         if (cancelStreamRegistry.unregisterCloseable(inputStream)) {             inputStream.close().         }     } }
