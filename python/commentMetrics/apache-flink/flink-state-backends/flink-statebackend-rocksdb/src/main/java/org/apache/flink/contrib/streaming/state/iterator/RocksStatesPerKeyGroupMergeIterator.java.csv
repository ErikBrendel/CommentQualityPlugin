commented;modifiers;parameterAmount;loc;comment;code
true;public;0;31;/**  * Advances the iterator. Should only be called if {@link #isValid()} returned true.  * Valid flag can only change after calling {@link #next()}.  */ ;/**  * Advances the iterator. Should only be called if {@link #isValid()} returned true.  * Valid flag can only change after calling {@link #next()}.  */ public void next() {     newKeyGroup = false.     newKVState = false.     final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator().     rocksIterator.next().     byte[] oldKey = currentSubIterator.getCurrentKey().     if (rocksIterator.isValid()) {         currentSubIterator.setCurrentKey(rocksIterator.key()).         if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {             heap.offer(currentSubIterator).             currentSubIterator = heap.remove().             newKVState = currentSubIterator.getIterator() != rocksIterator.             detectNewKeyGroup(oldKey).         }     } else {         IOUtils.closeQuietly(rocksIterator).         if (heap.isEmpty()) {             currentSubIterator = null.             valid = false.         } else {             currentSubIterator = heap.remove().             newKVState = true.             detectNewKeyGroup(oldKey).         }     } }
false;private;1;20;;private PriorityQueue<RocksSingleStateIterator> buildIteratorHeap(List<Tuple2<RocksIteratorWrapper, Integer>> kvStateIterators) {     Comparator<RocksSingleStateIterator> iteratorComparator = COMPARATORS.get(keyGroupPrefixByteCount - 1).     PriorityQueue<RocksSingleStateIterator> iteratorPriorityQueue = new PriorityQueue<>(kvStateIterators.size(), iteratorComparator).     for (Tuple2<RocksIteratorWrapper, Integer> rocksIteratorWithKVStateId : kvStateIterators) {         final RocksIteratorWrapper rocksIterator = rocksIteratorWithKVStateId.f0.         rocksIterator.seekToFirst().         if (rocksIterator.isValid()) {             iteratorPriorityQueue.offer(new RocksSingleStateIterator(rocksIterator, rocksIteratorWithKVStateId.f1)).         } else {             IOUtils.closeQuietly(rocksIterator).         }     }     return iteratorPriorityQueue. }
false;private;2;3;;private boolean isDifferentKeyGroup(byte[] a, byte[] b) {     return 0 != compareKeyGroupsForByteArrays(a, b, keyGroupPrefixByteCount). }
false;private;1;5;;private void detectNewKeyGroup(byte[] oldKey) {     if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {         newKeyGroup = true.     } }
true;public;0;10;/**  * @return key-group for the current key  */ ;/**  * @return key-group for the current key  */ public int keyGroup() {     final byte[] currentKey = currentSubIterator.getCurrentKey().     int result = 0.     // big endian decode     for (int i = 0. i < keyGroupPrefixByteCount. ++i) {         result <<= 8.         result |= (currentKey[i] & 0xFF).     }     return result. }
false;public;0;3;;public byte[] key() {     return currentSubIterator.getCurrentKey(). }
false;public;0;3;;public byte[] value() {     return currentSubIterator.getIterator().value(). }
true;public;0;3;/**  * @return Id of K/V state to which the current key belongs.  */ ;/**  * @return Id of K/V state to which the current key belongs.  */ public int kvStateId() {     return currentSubIterator.getKvStateId(). }
true;public;0;3;/**  * Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor.  * @return true iff the current key belong to a different k/v-state than it's predecessor.  */ ;/**  * Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor.  * @return true iff the current key belong to a different k/v-state than it's predecessor.  */ public boolean isNewKeyValueState() {     return newKVState. }
true;public;0;3;/**  * Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor.  * @return true iff the current key belong to a different key-group than it's predecessor.  */ ;/**  * Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor.  * @return true iff the current key belong to a different key-group than it's predecessor.  */ public boolean isNewKeyGroup() {     return newKeyGroup. }
true;public;0;3;/**  * Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as  * {@link #next()} should only be called if valid returned true. Should be checked after each call to  * {@link #next()} before accessing iterator state.  * @return True iff this iterator is valid.  */ ;/**  * Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as  * {@link #next()} should only be called if valid returned true. Should be checked after each call to  * {@link #next()} before accessing iterator state.  * @return True iff this iterator is valid.  */ public boolean isValid() {     return valid. }
false;private,static;3;9;;private static int compareKeyGroupsForByteArrays(byte[] a, byte[] b, int len) {     for (int i = 0. i < len. ++i) {         int diff = (a[i] & 0xFF) - (b[i] & 0xFF).         if (diff != 0) {             return diff.         }     }     return 0. }
false;public;0;8;;@Override public void close() {     IOUtils.closeQuietly(currentSubIterator).     currentSubIterator = null.     IOUtils.closeAllQuietly(heap).     heap.clear(). }
