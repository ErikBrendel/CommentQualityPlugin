commented;modifiers;parameterAmount;loc;comment;code
true;public,static;5;26;/**  * The method to clip the db instance according to the target key group range using  * the {@link RocksDB#delete(ColumnFamilyHandle, byte[])}.  *  * @param db the RocksDB instance to be clipped.  * @param columnFamilyHandles the column families in the db instance.  * @param targetKeyGroupRange the target key group range.  * @param currentKeyGroupRange the key group range of the db instance.  * @param keyGroupPrefixBytes Number of bytes required to prefix the key groups.  */ ;/**  * The method to clip the db instance according to the target key group range using  * the {@link RocksDB#delete(ColumnFamilyHandle, byte[])}.  *  * @param db the RocksDB instance to be clipped.  * @param columnFamilyHandles the column families in the db instance.  * @param targetKeyGroupRange the target key group range.  * @param currentKeyGroupRange the key group range of the db instance.  * @param keyGroupPrefixBytes Number of bytes required to prefix the key groups.  */ public static void clipDBWithKeyGroupRange(@Nonnull RocksDB db, @Nonnull List<ColumnFamilyHandle> columnFamilyHandles, @Nonnull KeyGroupRange targetKeyGroupRange, @Nonnull KeyGroupRange currentKeyGroupRange, @Nonnegative int keyGroupPrefixBytes) throws RocksDBException {     final byte[] beginKeyGroupBytes = new byte[keyGroupPrefixBytes].     final byte[] endKeyGroupBytes = new byte[keyGroupPrefixBytes].     if (currentKeyGroupRange.getStartKeyGroup() < targetKeyGroupRange.getStartKeyGroup()) {         RocksDBKeySerializationUtils.serializeKeyGroup(currentKeyGroupRange.getStartKeyGroup(), beginKeyGroupBytes).         RocksDBKeySerializationUtils.serializeKeyGroup(targetKeyGroupRange.getStartKeyGroup(), endKeyGroupBytes).         deleteRange(db, columnFamilyHandles, beginKeyGroupBytes, endKeyGroupBytes).     }     if (currentKeyGroupRange.getEndKeyGroup() > targetKeyGroupRange.getEndKeyGroup()) {         RocksDBKeySerializationUtils.serializeKeyGroup(targetKeyGroupRange.getEndKeyGroup() + 1, beginKeyGroupBytes).         RocksDBKeySerializationUtils.serializeKeyGroup(currentKeyGroupRange.getEndKeyGroup() + 1, endKeyGroupBytes).         deleteRange(db, columnFamilyHandles, beginKeyGroupBytes, endKeyGroupBytes).     } }
true;private,static;4;24;/**  * Delete the record falls into [beginKeyBytes, endKeyBytes) of the db.  *  * @param db the target need to be clipped.  * @param columnFamilyHandles the column family need to be clipped.  * @param beginKeyBytes the begin key bytes  * @param endKeyBytes the end key bytes  */ ;/**  * Delete the record falls into [beginKeyBytes, endKeyBytes) of the db.  *  * @param db the target need to be clipped.  * @param columnFamilyHandles the column family need to be clipped.  * @param beginKeyBytes the begin key bytes  * @param endKeyBytes the end key bytes  */ private static void deleteRange(RocksDB db, List<ColumnFamilyHandle> columnFamilyHandles, byte[] beginKeyBytes, byte[] endKeyBytes) throws RocksDBException {     for (ColumnFamilyHandle columnFamilyHandle : columnFamilyHandles) {         try (RocksIteratorWrapper iteratorWrapper = RocksDBOperationUtils.getRocksIterator(db, columnFamilyHandle).             RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(db)) {             iteratorWrapper.seek(beginKeyBytes).             while (iteratorWrapper.isValid()) {                 final byte[] currentKey = iteratorWrapper.key().                 if (beforeThePrefixBytes(currentKey, endKeyBytes)) {                     writeBatchWrapper.remove(columnFamilyHandle, currentKey).                 } else {                     break.                 }                 iteratorWrapper.next().             }         }     } }
true;public,static;2;10;/**  * check whether the bytes is before prefixBytes in the character order.  */ ;/**  * check whether the bytes is before prefixBytes in the character order.  */ public static boolean beforeThePrefixBytes(@Nonnull byte[] bytes, @Nonnull byte[] prefixBytes) {     final int prefixLength = prefixBytes.length.     for (int i = 0. i < prefixLength. ++i) {         int r = (char) prefixBytes[i] - (char) bytes[i].         if (r != 0) {             return r > 0.         }     }     return false. }
true;public,static;2;17;/**  * Choose the best state handle according to the {@link #STATE_HANDLE_EVALUATOR}  * to init the initial db.  *  * @param restoreStateHandles The candidate state handles.  * @param targetKeyGroupRange The target key group range.  * @return The best candidate or null if no candidate was a good fit.  */ ;/**  * Choose the best state handle according to the {@link #STATE_HANDLE_EVALUATOR}  * to init the initial db.  *  * @param restoreStateHandles The candidate state handles.  * @param targetKeyGroupRange The target key group range.  * @return The best candidate or null if no candidate was a good fit.  */ @Nullable public static KeyedStateHandle chooseTheBestStateHandleForInitial(@Nonnull Collection<KeyedStateHandle> restoreStateHandles, @Nonnull KeyGroupRange targetKeyGroupRange) {     KeyedStateHandle bestStateHandle = null.     double bestScore = 0.     for (KeyedStateHandle rawStateHandle : restoreStateHandles) {         double handleScore = STATE_HANDLE_EVALUATOR.apply(rawStateHandle, targetKeyGroupRange).         if (handleScore > bestScore) {             bestStateHandle = rawStateHandle.             bestScore = handleScore.         }     }     return bestStateHandle. }
