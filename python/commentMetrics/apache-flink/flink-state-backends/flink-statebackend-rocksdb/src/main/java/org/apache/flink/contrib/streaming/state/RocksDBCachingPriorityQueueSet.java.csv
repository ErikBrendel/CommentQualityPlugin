commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Nullable @Override public E peek() {     checkRefillCacheFromStore().     if (peekCache != null) {         return peekCache.     }     byte[] firstBytes = orderedCache.peekFirst().     if (firstBytes != null) {         peekCache = deserializeElement(firstBytes).         return peekCache.     } else {         return null.     } }
false;public;0;27;;@Nullable @Override public E poll() {     checkRefillCacheFromStore().     final byte[] firstBytes = orderedCache.pollFirst().     if (firstBytes == null) {         return null.     }     // write-through sync     removeFromRocksDB(firstBytes).     if (orderedCache.isEmpty()) {         seekHint = firstBytes.     }     if (peekCache != null) {         E fromCache = peekCache.         peekCache = null.         return fromCache.     } else {         return deserializeElement(firstBytes).     } }
false;public;1;34;;@Override public boolean add(@Nonnull E toAdd) {     checkRefillCacheFromStore().     final byte[] toAddBytes = serializeElement(toAdd).     final boolean cacheFull = orderedCache.isFull().     if ((!cacheFull && allElementsInCache) || LEXICOGRAPHIC_BYTE_COMPARATOR.compare(toAddBytes, orderedCache.peekLast()) < 0) {         if (cacheFull) {             // we drop the element with lowest priority from the cache             orderedCache.pollLast().             // the dropped element is now only in the store             allElementsInCache = false.         }         if (orderedCache.add(toAddBytes)) {             // write-through sync             addToRocksDB(toAddBytes).             if (toAddBytes == orderedCache.peekFirst()) {                 peekCache = null.                 return true.             }         }     } else {         // we only added to the store         addToRocksDB(toAddBytes).         allElementsInCache = false.     }     return false. }
false;public;1;30;;@Override public boolean remove(@Nonnull E toRemove) {     checkRefillCacheFromStore().     final byte[] oldHead = orderedCache.peekFirst().     if (oldHead == null) {         return false.     }     final byte[] toRemoveBytes = serializeElement(toRemove).     // write-through sync     removeFromRocksDB(toRemoveBytes).     orderedCache.remove(toRemoveBytes).     if (orderedCache.isEmpty()) {         seekHint = toRemoveBytes.         peekCache = null.         return true.     }     if (oldHead != orderedCache.peekFirst()) {         peekCache = null.         return true.     }     return false. }
false;public;1;11;;@Override public void addAll(@Nullable Collection<? extends E> toAdd) {     if (toAdd == null) {         return.     }     for (E element : toAdd) {         add(element).     } }
false;public;0;5;;@Override public boolean isEmpty() {     checkRefillCacheFromStore().     return orderedCache.isEmpty(). }
false;public;0;5;;@Nonnull @Override public CloseableIterator<E> iterator() {     return new DeserializingIteratorWrapper(orderedBytesIterator()). }
true;public;0;16;/**  * This implementation comes at a relatively high cost per invocation. It should not be called repeatedly when it is  * clear that the value did not change. Currently this is only truly used to realize certain higher-level tests.  */ ;/**  * This implementation comes at a relatively high cost per invocation. It should not be called repeatedly when it is  * clear that the value did not change. Currently this is only truly used to realize certain higher-level tests.  */ @Override public int size() {     if (allElementsInCache) {         return orderedCache.size().     } else {         int count = 0.         try (final RocksBytesIterator iterator = orderedBytesIterator()) {             while (iterator.hasNext()) {                 iterator.next().                 ++count.             }         }         return count.     } }
false;public;0;4;;@Override public int getInternalIndex() {     return internalIndex. }
false;public;1;4;;@Override public void setInternalIndex(int newIndex) {     this.internalIndex = newIndex. }
false;private;0;7;;@Nonnull private RocksBytesIterator orderedBytesIterator() {     flushWriteBatch().     return new RocksBytesIterator(new RocksIteratorWrapper(db.newIterator(columnFamilyHandle))). }
true;private;0;7;/**  * Ensures that recent writes are flushed and reflect in the RocksDB instance.  */ ;/**  * Ensures that recent writes are flushed and reflect in the RocksDB instance.  */ private void flushWriteBatch() {     try {         batchWrapper.flush().     } catch (RocksDBException e) {         throw new FlinkRuntimeException(e).     } }
false;private;1;7;;private void addToRocksDB(@Nonnull byte[] toAddBytes) {     try {         batchWrapper.put(columnFamilyHandle, toAddBytes, DUMMY_BYTES).     } catch (RocksDBException e) {         throw new FlinkRuntimeException(e).     } }
false;private;1;7;;private void removeFromRocksDB(@Nonnull byte[] toRemoveBytes) {     try {         batchWrapper.remove(columnFamilyHandle, toRemoveBytes).     } catch (RocksDBException e) {         throw new FlinkRuntimeException(e).     } }
false;private;0;10;;private void checkRefillCacheFromStore() {     if (!allElementsInCache && orderedCache.isEmpty()) {         try (final RocksBytesIterator iterator = orderedBytesIterator()) {             orderedCache.bulkLoadFromOrderedIterator(iterator).             allElementsInCache = !iterator.hasNext().         } catch (Exception e) {             throw new FlinkRuntimeException("Exception while refilling store from iterator.", e).         }     } }
false;private,static;2;8;;private static boolean isPrefixWith(byte[] bytes, byte[] prefixBytes) {     for (int i = 0. i < prefixBytes.length. ++i) {         if (bytes[i] != prefixBytes[i]) {             return false.         }     }     return true. }
false;private;2;13;;@Nonnull private byte[] createKeyGroupBytes(int keyGroupId, int numPrefixBytes) {     outputView.clear().     try {         RocksDBKeySerializationUtils.writeKeyGroup(keyGroupId, numPrefixBytes, outputView).     } catch (IOException e) {         throw new FlinkRuntimeException("Could not write key-group bytes.", e).     }     return outputView.getCopyOfBuffer(). }
false;private;1;11;;@Nonnull private byte[] serializeElement(@Nonnull E element) {     try {         outputView.clear().         outputView.write(groupPrefixBytes).         byteOrderProducingSerializer.serialize(element, outputView).         return outputView.getCopyOfBuffer().     } catch (IOException e) {         throw new FlinkRuntimeException("Error while serializing the element.", e).     } }
false;private;1;10;;@Nonnull private E deserializeElement(@Nonnull byte[] bytes) {     try {         final int numPrefixBytes = groupPrefixBytes.length.         inputView.setBuffer(bytes, numPrefixBytes, bytes.length - numPrefixBytes).         return byteOrderProducingSerializer.deserialize(inputView).     } catch (IOException e) {         throw new FlinkRuntimeException("Error while deserializing the element.", e).     } }
false;public;0;4;;@Override public void close() throws Exception {     bytesIterator.close(). }
false;public;0;4;;@Override public boolean hasNext() {     return bytesIterator.hasNext(). }
false;public;0;4;;@Override public E next() {     return deserializeElement(bytesIterator.next()). }
false;public;0;4;;@Override public void close() {     iterator.close(). }
false;public;0;4;;@Override public boolean hasNext() {     return currentElement != null. }
false;public;0;10;;@Override public byte[] next() {     final byte[] returnElement = this.currentElement.     if (returnElement == null) {         throw new NoSuchElementException("Iterator has no more elements!").     }     iterator.next().     currentElement = nextElementIfAvailable().     return returnElement. }
false;private;0;5;;private byte[] nextElementIfAvailable() {     final byte[] elementBytes.     return iterator.isValid() && isPrefixWith((elementBytes = iterator.key()), groupPrefixBytes) ? elementBytes : null. }
true;;0;1;/**  * Returns the number of contained elements.  */ ;/**  * Returns the number of contained elements.  */ int size().
true;;0;1;/**  * Returns the maximum number of elements that can be stored in the cache.  */ ;/**  * Returns the maximum number of elements that can be stored in the cache.  */ int maxSize().
true;;0;1;/**  * Returns <code>size() == 0</code>.  */ ;/**  * Returns <code>size() == 0</code>.  */ boolean isEmpty().
true;;0;1;/**  * Returns <code>size() == maxSize()</code>.  */ ;/**  * Returns <code>size() == maxSize()</code>.  */ boolean isFull().
true;;1;1;/**  * Adds the given element, if it was not already contained. Returns <code>true</code> iff the cache was modified.  */ ;/**  * Adds the given element, if it was not already contained. Returns <code>true</code> iff the cache was modified.  */ boolean add(@Nonnull byte[] toAdd).
true;;1;1;/**  * Removes the given element, if it is contained. Returns <code>true</code> iff the cache was modified.  */ ;/**  * Removes the given element, if it is contained. Returns <code>true</code> iff the cache was modified.  */ boolean remove(@Nonnull byte[] toRemove).
true;;0;2;/**  * Returns the first element or <code>null</code> if empty.  */ ;/**  * Returns the first element or <code>null</code> if empty.  */ @Nullable byte[] peekFirst().
true;;0;2;/**  * Returns the last element or <code>null</code> if empty.  */ ;/**  * Returns the last element or <code>null</code> if empty.  */ @Nullable byte[] peekLast().
true;;0;2;/**  * Returns and removes the first element or returns <code>null</code> if empty.  */ ;/**  * Returns and removes the first element or returns <code>null</code> if empty.  */ @Nullable byte[] pollFirst().
true;;0;2;/**  * Returns and removes the last element or returns <code>null</code> if empty.  */ ;/**  * Returns and removes the last element or returns <code>null</code> if empty.  */ @Nullable byte[] pollLast().
true;;1;1;/**  * Clears the cache and adds up to <code>maxSize()</code> elements from the iterator to the cache.  * Iterator must be ordered in the same order as this cache.  *  * @param orderedIterator iterator with elements in-order.  */ ;/**  * Clears the cache and adds up to <code>maxSize()</code> elements from the iterator to the cache.  * Iterator must be ordered in the same order as this cache.  *  * @param orderedIterator iterator with elements in-order.  */ void bulkLoadFromOrderedIterator(@Nonnull Iterator<byte[]> orderedIterator).
