commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;public void openDB() throws IOException {     db = RocksDBOperationUtils.openDB(dbPath, columnFamilyDescriptors, columnFamilyHandles, RocksDBOperationUtils.createColumnFamilyOptions(columnFamilyOptionsFactory, "default"), dbOptions).     // remove the default column family which is located at the first index     defaultColumnFamilyHandle = columnFamilyHandles.remove(0).     // init native metrics monitor if configured     nativeMetricMonitor = nativeMetricOptions.isEnabled() ? new RocksDBNativeMetricMonitor(nativeMetricOptions, metricGroup, db) : null. }
false;public;0;3;;public RocksDB getDb() {     return this.db. }
false;protected;2;30;;protected RocksDbKvStateInfo getOrRegisterStateColumnFamilyHandle(ColumnFamilyHandle columnFamilyHandle, StateMetaInfoSnapshot stateMetaInfoSnapshot) throws RocksDBException {     RocksDbKvStateInfo registeredStateMetaInfoEntry = kvStateInformation.get(stateMetaInfoSnapshot.getName()).     if (null == registeredStateMetaInfoEntry) {         // create a meta info for the state on restore.         // this allows us to retain the state in future snapshots even if it wasn't accessed         RegisteredStateMetaInfoBase stateMetaInfo = RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot).         if (columnFamilyHandle == null) {             registeredStateMetaInfoEntry = RocksDBOperationUtils.createStateInfo(stateMetaInfo, ttlCompactFiltersManager, ttlTimeProvider, db, columnFamilyOptionsFactory).         } else {             registeredStateMetaInfoEntry = new RocksDbKvStateInfo(columnFamilyHandle, stateMetaInfo).         }         RocksDBOperationUtils.registerKvStateInformation(kvStateInformation, nativeMetricMonitor, stateMetaInfoSnapshot.getName(), registeredStateMetaInfoEntry).     } else {     // TODO with eager state registration in place, check here for serializer migration strategies     }     return registeredStateMetaInfoEntry. }
false;protected;1;23;;protected KeyedBackendSerializationProxy<K> readMetaData(DataInputView dataInputView) throws IOException, StateMigrationException {     // isSerializerPresenceRequired flag is set to false, since for the RocksDB state backend,     // deserialization of state happens lazily during runtime. we depend on the fact     // that the new serializer for states could be compatible, and therefore the restore can continue     // without old serializers required to be present.     KeyedBackendSerializationProxy<K> serializationProxy = new KeyedBackendSerializationProxy<>(userCodeClassLoader).     serializationProxy.read(dataInputView).     if (!isKeySerializerCompatibilityChecked) {         // check for key serializer compatibility. this also reconfigures the         // key serializer to be compatible, if it is required and is possible         TypeSerializerSchemaCompatibility<K> keySerializerSchemaCompat = keySerializerProvider.setPreviousSerializerSnapshotForRestoredState(serializationProxy.getKeySerializerSnapshot()).         if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {             throw new StateMigrationException("The new key serializer must be compatible.").         }         isKeySerializerCompatibilityChecked = true.     }     return serializationProxy. }
true;public;0;8;/**  * Necessary clean up iff restore operation failed.  */ ;/**  * Necessary clean up iff restore operation failed.  */ @Override public void close() {     IOUtils.closeQuietly(defaultColumnFamilyHandle).     IOUtils.closeQuietly(nativeMetricMonitor).     IOUtils.closeQuietly(db).     // Making sure the already created column family options will be closed     columnFamilyDescriptors.forEach((cfd) -> IOUtils.closeQuietly(cfd.getOptions())). }
false;public,abstract;0;2;;@Override public abstract RocksDBRestoreResult restore() throws Exception.
