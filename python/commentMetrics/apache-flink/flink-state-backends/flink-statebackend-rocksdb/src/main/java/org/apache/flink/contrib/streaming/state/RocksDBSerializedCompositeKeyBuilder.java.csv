commented;modifiers;parameterAmount;loc;comment;code
true;public;2;7;/**  * Sets the key and key-group as prefix. This will serialize them into the buffer and the will be used to create  * composite keys with provided namespaces.  *  * @param key        the key.  * @param keyGroupId the key-group id for the key.  */ ;/**  * Sets the key and key-group as prefix. This will serialize them into the buffer and the will be used to create  * composite keys with provided namespaces.  *  * @param key        the key.  * @param keyGroupId the key-group id for the key.  */ public void setKeyAndKeyGroup(@Nonnull K key, @Nonnegative int keyGroupId) {     try {         serializeKeyGroupAndKey(key, keyGroupId).     } catch (IOException shouldNeverHappen) {         throw new FlinkRuntimeException(shouldNeverHappen).     } }
true;public;2;11;/**  * Returns a serialized composite key, from the key and key-group provided in a previous call to  * {@link #setKeyAndKeyGroup(Object, int)} and the given namespace.  *  * @param namespace           the namespace to concatenate for the serialized composite key bytes.  * @param namespaceSerializer the serializer to obtain the serialized form of the namespace.  * @param <N>                 the type of the namespace.  * @return the bytes for the serialized composite key of key-group, key, namespace.  */ ;/**  * Returns a serialized composite key, from the key and key-group provided in a previous call to  * {@link #setKeyAndKeyGroup(Object, int)} and the given namespace.  *  * @param namespace           the namespace to concatenate for the serialized composite key bytes.  * @param namespaceSerializer the serializer to obtain the serialized form of the namespace.  * @param <N>                 the type of the namespace.  * @return the bytes for the serialized composite key of key-group, key, namespace.  */ @Nonnull public <N> byte[] buildCompositeKeyNamespace(@Nonnull N namespace, @Nonnull TypeSerializer<N> namespaceSerializer) {     try {         serializeNamespace(namespace, namespaceSerializer).         final byte[] result = keyOutView.getCopyOfBuffer().         resetToKey().         return result.     } catch (IOException shouldNeverHappen) {         throw new FlinkRuntimeException(shouldNeverHappen).     } }
true;public;4;12;/**  * Returns a serialized composite key, from the key and key-group provided in a previous call to  * {@link #setKeyAndKeyGroup(Object, int)} and the given namespace, folloed by the given user-key.  *  * @param namespace           the namespace to concatenate for the serialized composite key bytes.  * @param namespaceSerializer the serializer to obtain the serialized form of the namespace.  * @param userKey             the user-key to concatenate for the serialized composite key, after the namespace.  * @param userKeySerializer   the serializer to obtain the serialized form of the user-key.  * @param <N>                 the type of the namespace.  * @param <UK>                the type of the user-key.  * @return the bytes for the serialized composite key of key-group, key, namespace.  */ ;/**  * Returns a serialized composite key, from the key and key-group provided in a previous call to  * {@link #setKeyAndKeyGroup(Object, int)} and the given namespace, folloed by the given user-key.  *  * @param namespace           the namespace to concatenate for the serialized composite key bytes.  * @param namespaceSerializer the serializer to obtain the serialized form of the namespace.  * @param userKey             the user-key to concatenate for the serialized composite key, after the namespace.  * @param userKeySerializer   the serializer to obtain the serialized form of the user-key.  * @param <N>                 the type of the namespace.  * @param <UK>                the type of the user-key.  * @return the bytes for the serialized composite key of key-group, key, namespace.  */ @Nonnull public <N, UK> byte[] buildCompositeKeyNamesSpaceUserKey(@Nonnull N namespace, @Nonnull TypeSerializer<N> namespaceSerializer, @Nonnull UK userKey, @Nonnull TypeSerializer<UK> userKeySerializer) throws IOException {     serializeNamespace(namespace, namespaceSerializer).     userKeySerializer.serialize(userKey, keyOutView).     byte[] result = keyOutView.getCopyOfBuffer().     resetToKey().     return result. }
false;private;2;14;;private void serializeKeyGroupAndKey(K key, int keyGroupId) throws IOException {     // clear buffer and mark     resetFully().     // write key-group     RocksDBKeySerializationUtils.writeKeyGroup(keyGroupId, keyGroupPrefixBytes, keyOutView).     // write key     keySerializer.serialize(key, keyOutView).     afterKeyMark = keyOutView.length(). }
false;private;2;19;;private <N> void serializeNamespace(@Nonnull N namespace, @Nonnull TypeSerializer<N> namespaceSerializer) throws IOException {     // this should only be called when there is already a key written so that we build the composite.     assert isKeyWritten().     final boolean ambiguousCompositeKeyPossible = isAmbiguousCompositeKeyPossible(namespaceSerializer).     if (ambiguousCompositeKeyPossible) {         RocksDBKeySerializationUtils.writeVariableIntBytes(afterKeyMark - keyGroupPrefixBytes, keyOutView).     }     RocksDBKeySerializationUtils.writeNameSpace(namespace, namespaceSerializer, keyOutView, ambiguousCompositeKeyPossible). }
false;private;0;4;;private void resetFully() {     afterKeyMark = 0.     keyOutView.clear(). }
false;private;0;3;;private void resetToKey() {     keyOutView.setPosition(afterKeyMark). }
false;private;0;3;;private boolean isKeyWritten() {     return afterKeyMark > 0. }
false;;1;5;;@VisibleForTesting boolean isAmbiguousCompositeKeyPossible(TypeSerializer<?> namespaceSerializer) {     return keySerializerTypeVariableSized & RocksDBKeySerializationUtils.isSerializerTypeVariableSized(namespaceSerializer). }
