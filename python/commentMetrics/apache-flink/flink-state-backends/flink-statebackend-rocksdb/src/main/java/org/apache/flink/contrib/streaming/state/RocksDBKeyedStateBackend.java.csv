commented;modifiers;parameterAmount;loc;comment;code
false;;3;4;;<K, N, SV, S extends State, IS extends S> IS createState(StateDescriptor<S, SV> stateDesc, Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> registerResult, RocksDBKeyedStateBackend<K> backend) throws Exception.
false;public;2;35;;@SuppressWarnings("unchecked") @Override public <N> Stream<K> getKeys(String state, N namespace) {     RocksDbKvStateInfo columnInfo = kvStateInformation.get(state).     if (columnInfo == null || !(columnInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo)) {         return Stream.empty().     }     RegisteredKeyValueStateBackendMetaInfo<N, ?> registeredKeyValueStateBackendMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, ?>) columnInfo.metaInfo.     final TypeSerializer<N> namespaceSerializer = registeredKeyValueStateBackendMetaInfo.getNamespaceSerializer().     final DataOutputSerializer namespaceOutputView = new DataOutputSerializer(8).     boolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(getKeySerializer(), namespaceSerializer).     final byte[] nameSpaceBytes.     try {         RocksDBKeySerializationUtils.writeNameSpace(namespace, namespaceSerializer, namespaceOutputView, ambiguousKeyPossible).         nameSpaceBytes = namespaceOutputView.getCopyOfBuffer().     } catch (IOException ex) {         throw new FlinkRuntimeException("Failed to get keys from RocksDB state backend.", ex).     }     RocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(db, columnInfo.columnFamilyHandle).     iterator.seekToFirst().     final RocksStateKeysIterator<K> iteratorWrapper = new RocksStateKeysIterator<>(iterator, state, getKeySerializer(), keyGroupPrefixBytes, ambiguousKeyPossible, nameSpaceBytes).     Stream<K> targetStream = StreamSupport.stream(Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED), false).     return targetStream.onClose(iteratorWrapper::close). }
false;;1;5;;@VisibleForTesting ColumnFamilyHandle getColumnFamilyHandle(String state) {     RocksDbKvStateInfo columnInfo = kvStateInformation.get(state).     return columnInfo != null ? columnInfo.columnFamilyHandle : null. }
false;public;1;5;;@Override public void setCurrentKey(K newKey) {     super.setCurrentKey(newKey).     sharedRocksKeyBuilder.setKeyAndKeyGroup(getCurrentKey(), getCurrentKeyGroupIndex()). }
true;public;0;55;/**  * Should only be called by one thread, and only after all accesses to the DB happened.  */ ;/**  * Should only be called by one thread, and only after all accesses to the DB happened.  */ @Override public void dispose() {     if (this.disposed) {         return.     }     super.dispose().     // This call will block until all clients that still acquire access to the RocksDB instance have released it,     // so that we cannot release the native resources while clients are still working with it in parallel.     rocksDBResourceGuard.close().     // working on the disposed object results in SEGFAULTS.     if (db != null) {         IOUtils.closeQuietly(writeBatchWrapper).         // and no more metric collection will be attempted against the database.         if (nativeMetricMonitor != null) {             nativeMetricMonitor.close().         }         List<ColumnFamilyOptions> columnFamilyOptions = new ArrayList<>(kvStateInformation.values().size()).         // RocksDB's native memory management requires that *all* CFs (including default) are closed before the         // DB is closed. See:         // https://github.com/facebook/rocksdb/wiki/RocksJava-Basics#opening-a-database-with-column-families         // Start with default CF ...         RocksDBOperationUtils.addColumnFamilyOptionsToCloseLater(columnFamilyOptions, defaultColumnFamily).         IOUtils.closeQuietly(defaultColumnFamily).         // ... continue with the ones created by Flink...         for (RocksDbKvStateInfo kvStateInfo : kvStateInformation.values()) {             RocksDBOperationUtils.addColumnFamilyOptionsToCloseLater(columnFamilyOptions, kvStateInfo.columnFamilyHandle).             IOUtils.closeQuietly(kvStateInfo.columnFamilyHandle).         }         // ... and finally close the DB instance ...         IOUtils.closeQuietly(db).         columnFamilyOptions.forEach(IOUtils::closeQuietly).         IOUtils.closeQuietly(dbOptions).         IOUtils.closeQuietly(writeOptions).         ttlCompactFiltersManager.disposeAndClearRegisteredCompactionFactories().         kvStateInformation.clear().         cleanInstanceBasePath().     }     this.disposed = true. }
false;public;2;8;;@Nonnull @Override public <T extends HeapPriorityQueueElement & PriorityComparable & Keyed> KeyGroupedInternalPriorityQueue<T> create(@Nonnull String stateName, @Nonnull TypeSerializer<T> byteOrderedElementSerializer) {     return priorityQueueFactory.create(stateName, byteOrderedElementSerializer). }
false;private;0;9;;private void cleanInstanceBasePath() {     LOG.info("Deleting existing instance base directory {}.", instanceBasePath).     try {         FileUtils.deleteDirectory(instanceBasePath).     } catch (IOException ex) {         LOG.warn("Could not delete instance base path for RocksDB: " + instanceBasePath, ex).     } }
false;public;0;3;;// ------------------------------------------------------------------------ // Getters and Setters // ------------------------------------------------------------------------ public int getKeyGroupPrefixBytes() {     return keyGroupPrefixBytes. }
false;;0;4;;@VisibleForTesting PriorityQueueSetFactory getPriorityQueueFactory() {     return priorityQueueFactory. }
false;public;0;3;;public WriteOptions getWriteOptions() {     return writeOptions. }
false;;0;3;;RocksDBSerializedCompositeKeyBuilder<K> getSharedRocksKeyBuilder() {     return sharedRocksKeyBuilder. }
false;;0;4;;@VisibleForTesting boolean isDisposed() {     return this.disposed. }
true;public;4;24;/**  * Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and  * is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always  * be called by the same thread.  *  * @param checkpointId  The Id of the checkpoint.  * @param timestamp     The timestamp of the checkpoint.  * @param streamFactory The factory that we can use for writing our state to streams.  * @param checkpointOptions Options for how to perform this checkpoint.  * @return Future to the state handle of the snapshot data.  * @throws Exception indicating a problem in the synchronous part of the checkpoint.  */ ;/**  * Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and  * is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always  * be called by the same thread.  *  * @param checkpointId  The Id of the checkpoint.  * @param timestamp     The timestamp of the checkpoint.  * @param streamFactory The factory that we can use for writing our state to streams.  * @param checkpointOptions Options for how to perform this checkpoint.  * @return Future to the state handle of the snapshot data.  * @throws Exception indicating a problem in the synchronous part of the checkpoint.  */ @Nonnull @Override public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(final long checkpointId, final long timestamp, @Nonnull final CheckpointStreamFactory streamFactory, @Nonnull CheckpointOptions checkpointOptions) throws Exception {     long startTime = System.currentTimeMillis().     // flush everything into db before taking a snapshot     writeBatchWrapper.flush().     RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy = CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ? savepointSnapshotStrategy : checkpointSnapshotStrategy.     RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner = chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions).     chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime).     return snapshotRunner. }
false;public;1;4;;@Override public void restore(Collection<KeyedStateHandle> restoreState) { // all restore work done in builder and nothing to do here }
false;public;1;11;;@Override public void notifyCheckpointComplete(long completedCheckpointId) throws Exception {     if (checkpointSnapshotStrategy != null) {         checkpointSnapshotStrategy.notifyCheckpointComplete(completedCheckpointId).     }     if (savepointSnapshotStrategy != null) {         savepointSnapshotStrategy.notifyCheckpointComplete(completedCheckpointId).     } }
true;private;3;46;/**  * Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.  *  * <p>When restoring from a snapshot, we don’t restore the individual k/v states, just the global RocksDB database and  * the list of k/v state information. When a k/v state is first requested we check here whether we  * already have a registered entry for that and return it (after some necessary state compatibility checks)  * or create a new one if it does not exist.  */ ;/**  * Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.  *  * <p>When restoring from a snapshot, we don’t restore the individual k/v states, just the global RocksDB database and  * the list of k/v state information. When a k/v state is first requested we check here whether we  * already have a registered entry for that and return it (after some necessary state compatibility checks)  * or create a new one if it does not exist.  */ private <N, S extends State, SV, SEV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(StateDescriptor<S, SV> stateDesc, TypeSerializer<N> namespaceSerializer, @Nonnull StateSnapshotTransformFactory<SEV> snapshotTransformFactory) throws Exception {     RocksDbKvStateInfo oldStateInfo = kvStateInformation.get(stateDesc.getName()).     TypeSerializer<SV> stateSerializer = stateDesc.getSerializer().     RocksDbKvStateInfo newRocksStateInfo.     RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo.     if (oldStateInfo != null) {         @SuppressWarnings("unchecked")         RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.metaInfo.         newMetaInfo = updateRestoredStateMetaInfo(Tuple2.of(oldStateInfo.columnFamilyHandle, castedMetaInfo), stateDesc, namespaceSerializer, stateSerializer).         newRocksStateInfo = new RocksDbKvStateInfo(oldStateInfo.columnFamilyHandle, newMetaInfo).         kvStateInformation.put(stateDesc.getName(), newRocksStateInfo).     } else {         newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(stateDesc.getType(), stateDesc.getName(), namespaceSerializer, stateSerializer, StateSnapshotTransformFactory.noTransform()).         newRocksStateInfo = RocksDBOperationUtils.createStateInfo(newMetaInfo, ttlCompactFiltersManager, ttlTimeProvider, db, columnFamilyOptionsFactory).         RocksDBOperationUtils.registerKvStateInformation(this.kvStateInformation, this.nativeMetricMonitor, stateDesc.getName(), newRocksStateInfo).     }     StateSnapshotTransformFactory<SV> wrappedSnapshotTransformFactory = wrapStateSnapshotTransformFactory(stateDesc, snapshotTransformFactory, newMetaInfo.getStateSerializer()).     newMetaInfo.updateSnapshotTransformFactory(wrappedSnapshotTransformFactory).     ttlCompactFiltersManager.configCompactFilter(stateDesc, newMetaInfo.getStateSerializer()).     return Tuple2.of(newRocksStateInfo.columnFamilyHandle, newMetaInfo). }
false;private;4;26;;private <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo, StateDescriptor<S, SV> stateDesc, TypeSerializer<N> namespaceSerializer, TypeSerializer<SV> stateSerializer) throws Exception {     @SuppressWarnings("unchecked")     RegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1.     TypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer).     if (s.isCompatibleAfterMigration() || s.isIncompatible()) {         throw new StateMigrationException("The new namespace serializer must be compatible.").     }     restoredKvStateMetaInfo.checkStateMetaInfo(stateDesc).     TypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility = restoredKvStateMetaInfo.updateStateSerializer(stateSerializer).     if (newStateSerializerCompatibility.isCompatibleAfterMigration()) {         migrateStateValues(stateDesc, oldStateInfo).     } else if (newStateSerializerCompatibility.isIncompatible()) {         throw new StateMigrationException("The new state serializer cannot be incompatible.").     }     return restoredKvStateMetaInfo. }
true;private;2;62;/**  * Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate  * the key here, which is made up of key group, key, namespace and map key  * (in case of MapState).  */ ;/**  * Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate  * the key here, which is made up of key group, key, namespace and map key  * (in case of MapState).  */ private <N, S extends State, SV> void migrateStateValues(StateDescriptor<S, SV> stateDesc, Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {     if (stateDesc.getType() == StateDescriptor.Type.MAP) {         throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." + " However, migration for MapState currently isn't supported.").     }     LOG.info("Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.", stateDesc).     // we need to get an actual state instance because migration is different     // for different state types. For example, ListState needs to deal with     // individual elements     StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass()).     if (stateFactory == null) {         String message = String.format("State %s is not supported by %s", stateDesc.getClass(), this.getClass()).         throw new FlinkRuntimeException(message).     }     State state = stateFactory.createState(stateDesc, stateMetaInfo, RocksDBKeyedStateBackend.this).     if (!(state instanceof AbstractRocksDBState)) {         throw new FlinkRuntimeException("State should be an AbstractRocksDBState but is " + state).     }     @SuppressWarnings("unchecked")     AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state.     Snapshot rocksDBSnapshot = db.getSnapshot().     try (RocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(db, stateMetaInfo.f0).         RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())) {         iterator.seekToFirst().         DataInputDeserializer serializedValueInput = new DataInputDeserializer().         DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512).         while (iterator.isValid()) {             serializedValueInput.setBuffer(iterator.value()).             rocksDBState.migrateSerializedValue(serializedValueInput, migratedSerializedValueOutput, stateMetaInfo.f1.getPreviousStateSerializer(), stateMetaInfo.f1.getStateSerializer()).             batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer()).             migratedSerializedValueOutput.clear().             iterator.next().         }     } finally {         db.releaseSnapshot(rocksDBSnapshot).         rocksDBSnapshot.close().     } }
false;public;3;16;;@Override @Nonnull public <N, SV, SEV, S extends State, IS extends S> IS createInternalState(@Nonnull TypeSerializer<N> namespaceSerializer, @Nonnull StateDescriptor<S, SV> stateDesc, @Nonnull StateSnapshotTransformFactory<SEV> snapshotTransformFactory) throws Exception {     StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass()).     if (stateFactory == null) {         String message = String.format("State %s is not supported by %s", stateDesc.getClass(), this.getClass()).         throw new FlinkRuntimeException(message).     }     Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> registerResult = tryRegisterKvStateInformation(stateDesc, namespaceSerializer, snapshotTransformFactory).     return stateFactory.createState(stateDesc, registerResult, RocksDBKeyedStateBackend.this). }
true;;0;3;/**  * Only visible for testing, DO NOT USE.  */ ;/**  * Only visible for testing, DO NOT USE.  */ File getInstanceBasePath() {     return instanceBasePath. }
false;public;0;4;;@Override public boolean supportsAsynchronousSnapshots() {     return true. }
false;public;0;20;;@VisibleForTesting @SuppressWarnings("unchecked") @Override public int numKeyValueStateEntries() {     int count = 0.     for (RocksDbKvStateInfo metaInfo : kvStateInformation.values()) {         // TODO maybe filterOrTransform only for k/v states         try (RocksIteratorWrapper rocksIterator = RocksDBOperationUtils.getRocksIterator(db, metaInfo.columnFamilyHandle)) {             rocksIterator.seekToFirst().             while (rocksIterator.isValid()) {                 count++.                 rocksIterator.next().             }         }     }     return count. }
false;public;0;4;;@Override public boolean requiresLegacySynchronousTimerSnapshots() {     return priorityQueueFactory instanceof HeapPriorityQueueSetFactory. }
false;public;0;4;;@Override public void close() throws Exception {     this.columnFamilyHandle.close(). }
false;public;1;5;;@VisibleForTesting public void compactState(StateDescriptor<?, ?> stateDesc) throws RocksDBException {     RocksDbKvStateInfo kvStateInfo = kvStateInformation.get(stateDesc.getName()).     db.compactRange(kvStateInfo.columnFamilyHandle). }
