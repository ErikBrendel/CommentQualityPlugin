# id;timestamp;commentText;codeText;commentWords;codeWords
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1519061869;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())__			__			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1519379856;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())__			__			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1519567828;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())__			__			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1519567828;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())__			__			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1519568061;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())__			__			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1519570794;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())__			__			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1519570794;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())__			__			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1519570794;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1519570795;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1520253977;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1520850256;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1520891167;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1521626215;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1522337739;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1523010728;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1523010728;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1523010728;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1524129142;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1524760045;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1524906327;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1525332388;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1525661782;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1526313052;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1526562913;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1527071274;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1528201124;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1529325710;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1530639128;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1531145571;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(_							restoredMetaInfo.getStateType(),_							restoredMetaInfo.getName(),_							restoredMetaInfo.getNamespaceSerializer(),_							restoredMetaInfo.getStateSerializer())___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,registered,keyed,backend,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,registered,keyed,backend,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,get,state,type,restored,meta,info,get,name,restored,meta,info,get,namespace,serializer,restored,meta,info,get,state,serializer,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1531404901;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1531405434;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1531419503;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1531422929;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_						new RegisteredKeyedBackendStateMetaInfo<>(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1531771917;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1531771917;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1533212741;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1533212741;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1533224436;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1533318024;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1533565670;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1533647766;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1533924441;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1533924476;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.__@throws IOException_@throws ClassNotFoundException_@throws RocksDBException;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,class,not,found,exception,throws,rocks,dbexception;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1534854671;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1534854671;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1534937605;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.getKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1539149054;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.restoreKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,restore,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1539939663;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (CompatibilityUtil.resolveCompatibilityResult(_				serializationProxy.restoreKeySerializer(),_				UnloadableDummyTypeSerializer.class,_				serializationProxy.getKeySerializerConfigSnapshot(),_				rocksDBKeyedStateBackend.keySerializer)_				.isRequiresMigration()) {__				_				throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_					"Aborting now since state migration is currently not available")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.registerKvStateInformation(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,compatibility,util,resolve,compatibility,result,serialization,proxy,restore,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,rocks,dbkeyed,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,register,kv,state,information,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader, false)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.registerKvStateInformation(stateMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,false,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,register,kv,state,information,state,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, null)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,null,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, null)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,null,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, null)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,null,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					registeredColumn = new Tuple2<>(columnFamily, null)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,column,new,tuple2,column,family,null,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1544521602;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1544521602;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,rocks,dbkeyed,state,backend,restored,kv,state,meta,infos,put,restored,meta,info,get,name,restored,meta,info,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1544521602;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1545300278;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1546862341;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1546862378;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			_			_			if (!serializationProxy.getKeySerializerConfigSnapshot()_					.resolveSchemaCompatibility(rocksDBKeyedStateBackend.keySerializer).isCompatibleAsIs()) {_				throw new StateMigrationException("The new key serializer must be compatible.")__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,rocks,dbkeyed,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1546867949;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			if (!isKeySerializerCompatibilityChecked) {_				_				_				TypeSerializerSchemaCompatibility<K> keySerializerSchemaCompat =_					rocksDBKeyedStateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerConfigSnapshot())__				if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				isKeySerializerCompatibilityChecked = true__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,k,key,serializer,schema,compat,rocks,dbkeyed,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,config,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1546867949;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			if (!isKeySerializerCompatibilityChecked) {_				_				_				TypeSerializerSchemaCompatibility<K> keySerializerSchemaCompat =_					rocksDBKeyedStateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__				if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				isKeySerializerCompatibilityChecked = true__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,k,key,serializer,schema,compat,rocks,dbkeyed,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1546956357;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			if (!isKeySerializerCompatibilityChecked) {_				_				_				TypeSerializerSchemaCompatibility<K> keySerializerSchemaCompat =_					rocksDBKeyedStateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__				if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				isKeySerializerCompatibilityChecked = true__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,k,key,serializer,schema,compat,rocks,dbkeyed,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1546956357;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			if (!isKeySerializerCompatibilityChecked) {_				_				_				TypeSerializerSchemaCompatibility<K> keySerializerSchemaCompat =_					rocksDBKeyedStateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__				if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				isKeySerializerCompatibilityChecked = true__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,k,key,serializer,schema,compat,rocks,dbkeyed,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1548411242;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			if (!isKeySerializerCompatibilityChecked) {_				_				_				TypeSerializerSchemaCompatibility<K> keySerializerSchemaCompat =_					rocksDBKeyedStateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__				if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				isKeySerializerCompatibilityChecked = true__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,k,key,serializer,schema,compat,rocks,dbkeyed,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException;1548440094;Restore the KV-state / ColumnFamily meta data for all key-groups referenced by the current state handle.;private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {__			_			_			_			_			KeyedBackendSerializationProxy<K> serializationProxy =_				new KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader)___			serializationProxy.read(currentStateHandleInView)___			if (!isKeySerializerCompatibilityChecked) {_				_				_				TypeSerializerSchemaCompatibility<K> keySerializerSchemaCompat =_					rocksDBKeyedStateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__				if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				isKeySerializerCompatibilityChecked = true__			}__			this.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?_				SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE___			List<StateMetaInfoSnapshot> restoredMetaInfos =_				serializationProxy.getStateMetaInfoSnapshots()__			currentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size())___			for (StateMetaInfoSnapshot restoredMetaInfo : restoredMetaInfos) {__				Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> registeredColumn =_					rocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName())___				if (registeredColumn == null) {_					byte[] nameBytes = restoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)___					ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_						nameBytes,_						rocksDBKeyedStateBackend.columnOptions)___					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor)___					_					_					RegisteredStateMetaInfoBase stateMetaInfo =_						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo)__					registeredColumn = new Tuple2<>(columnFamily, stateMetaInfo)__					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn)___				} else {_					_				}_				currentStateHandleKVStateColumnFamilies.add(registeredColumn.f0)__			}_		};restore,the,kv,state,column,family,meta,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,meta,data,throws,ioexception,state,migration,exception,rocks,dbexception,keyed,backend,serialization,proxy,k,serialization,proxy,new,keyed,backend,serialization,proxy,rocks,dbkeyed,state,backend,user,code,class,loader,serialization,proxy,read,current,state,handle,in,view,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,k,key,serializer,schema,compat,rocks,dbkeyed,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,this,keygroup,stream,compression,decorator,serialization,proxy,is,using,key,group,compression,snappy,stream,compression,decorator,instance,uncompressed,stream,compression,decorator,instance,list,state,meta,info,snapshot,restored,meta,infos,serialization,proxy,get,state,meta,info,snapshots,current,state,handle,kvstate,column,families,new,array,list,restored,meta,infos,size,for,state,meta,info,snapshot,restored,meta,info,restored,meta,infos,tuple2,column,family,handle,registered,state,meta,info,base,registered,column,rocks,dbkeyed,state,backend,kv,state,information,get,restored,meta,info,get,name,if,registered,column,null,byte,name,bytes,restored,meta,info,get,name,get,bytes,config,constants,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,name,bytes,rocks,dbkeyed,state,backend,column,options,column,family,handle,column,family,rocks,dbkeyed,state,backend,db,create,column,family,column,family,descriptor,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,restored,meta,info,registered,column,new,tuple2,column,family,state,meta,info,rocks,dbkeyed,state,backend,kv,state,information,put,restored,meta,info,get,name,registered,column,else,current,state,handle,kvstate,column,families,add,registered,column,f0
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1519570794;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1519570794;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1519570794;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1519570795;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1520253977;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1520850256;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1520891167;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1521626215;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1522337739;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1523010728;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1523010728;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1523010728;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1524129142;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1524760045;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1524906327;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1525332388;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1525661782;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1526313052;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1526562913;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance( 			IncrementalKeyedStateHandle restoreStateHandle, 			boolean hasExtraKeys) throws Exception;1527071274;Recovery from remote incremental state.;private void restoreInstance(_			IncrementalKeyedStateHandle restoreStateHandle,_			boolean hasExtraKeys) throws Exception {__			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {__				transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___				_				List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_					readMetaData(restoreStateHandle.getMetaStateHandle())___				List<ColumnFamilyDescriptor> columnFamilyDescriptors =_					createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___				if (hasExtraKeys) {_					restoreKeyGroupsShardWithTemporaryHelperInstance(_						temporaryRestoreInstancePath,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				} else {__					_					_					IncrementalLocalKeyedStateHandle localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())___					restoreLocalStateIntoFullInstance(_						localKeyedStateHandle,_						columnFamilyDescriptors,_						stateMetaInfoSnapshots)__				}_			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,remote,incremental,state;private,void,restore,instance,incremental,keyed,state,handle,restore,state,handle,boolean,has,extra,keys,throws,exception,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,if,has,extra,keys,restore,key,groups,shard,with,temporary,helper,instance,temporary,restore,instance,path,column,family,descriptors,state,meta,info,snapshots,else,incremental,local,keyed,state,handle,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo, 		StateMetaInfoSnapshot restoredMetaInfoSnapshot, 		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo, 		TypeSerializer<SV> newStateSerializer) throws Exception;1540907751;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo,_		StateMetaInfoSnapshot restoredMetaInfoSnapshot,_		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo,_		TypeSerializer<SV> newStateSerializer) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			Tuple2.of(stateInfo.f0, newMetaInfo),_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV, S> rocksDBState = (AbstractRocksDBState<?, ?, SV, S>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			@SuppressWarnings("unchecked")_			TypeSerializerSnapshot<SV> priorValueSerializerSnapshot = (TypeSerializerSnapshot<SV>)_				Preconditions.checkNotNull(restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER))__			TypeSerializer<SV> priorValueSerializer = priorValueSerializerSnapshot.restoreSerializer()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					priorValueSerializer,_					newStateSerializer)___				batchWriter.put(stateInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,state,meta,info,base,state,info,state,meta,info,snapshot,restored,meta,info,snapshot,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,type,serializer,sv,new,state,serializer,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,tuple2,of,state,info,f0,new,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,s,rocks,dbstate,abstract,rocks,dbstate,sv,s,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,suppress,warnings,unchecked,type,serializer,snapshot,sv,prior,value,serializer,snapshot,type,serializer,snapshot,sv,preconditions,check,not,null,restored,meta,info,snapshot,get,type,serializer,config,snapshot,state,meta,info,snapshot,common,serializer,keys,type,serializer,sv,prior,value,serializer,prior,value,serializer,snapshot,restore,serializer,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,prior,value,serializer,new,state,serializer,batch,writer,put,state,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo, 		StateMetaInfoSnapshot restoredMetaInfoSnapshot, 		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo, 		TypeSerializer<SV> newStateSerializer) throws Exception;1540907751;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo,_		StateMetaInfoSnapshot restoredMetaInfoSnapshot,_		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo,_		TypeSerializer<SV> newStateSerializer) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			Tuple2.of(stateInfo.f0, newMetaInfo),_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV, S> rocksDBState = (AbstractRocksDBState<?, ?, SV, S>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			@SuppressWarnings("unchecked")_			TypeSerializerSnapshot<SV> priorValueSerializerSnapshot = (TypeSerializerSnapshot<SV>)_				Preconditions.checkNotNull(restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER))__			TypeSerializer<SV> priorValueSerializer = priorValueSerializerSnapshot.restoreSerializer()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					priorValueSerializer,_					newStateSerializer)___				batchWriter.put(stateInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,state,meta,info,base,state,info,state,meta,info,snapshot,restored,meta,info,snapshot,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,type,serializer,sv,new,state,serializer,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,tuple2,of,state,info,f0,new,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,s,rocks,dbstate,abstract,rocks,dbstate,sv,s,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,suppress,warnings,unchecked,type,serializer,snapshot,sv,prior,value,serializer,snapshot,type,serializer,snapshot,sv,preconditions,check,not,null,restored,meta,info,snapshot,get,type,serializer,config,snapshot,state,meta,info,snapshot,common,serializer,keys,type,serializer,sv,prior,value,serializer,prior,value,serializer,snapshot,restore,serializer,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,prior,value,serializer,new,state,serializer,batch,writer,put,state,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo, 		StateMetaInfoSnapshot restoredMetaInfoSnapshot, 		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo, 		TypeSerializer<SV> newStateSerializer) throws Exception;1544521602;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo,_		StateMetaInfoSnapshot restoredMetaInfoSnapshot,_		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo,_		TypeSerializer<SV> newStateSerializer) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			Tuple2.of(stateInfo.f0, newMetaInfo),_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV, S> rocksDBState = (AbstractRocksDBState<?, ?, SV, S>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			@SuppressWarnings("unchecked")_			TypeSerializerSnapshot<SV> priorValueSerializerSnapshot = (TypeSerializerSnapshot<SV>)_				Preconditions.checkNotNull(restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER))__			TypeSerializer<SV> priorValueSerializer = priorValueSerializerSnapshot.restoreSerializer()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					priorValueSerializer,_					newStateSerializer)___				batchWriter.put(stateInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,state,meta,info,base,state,info,state,meta,info,snapshot,restored,meta,info,snapshot,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,type,serializer,sv,new,state,serializer,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,tuple2,of,state,info,f0,new,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,s,rocks,dbstate,abstract,rocks,dbstate,sv,s,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,suppress,warnings,unchecked,type,serializer,snapshot,sv,prior,value,serializer,snapshot,type,serializer,snapshot,sv,preconditions,check,not,null,restored,meta,info,snapshot,get,type,serializer,config,snapshot,state,meta,info,snapshot,common,serializer,keys,type,serializer,sv,prior,value,serializer,prior,value,serializer,snapshot,restore,serializer,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,prior,value,serializer,new,state,serializer,batch,writer,put,state,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1519570794;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1519570794;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1519570794;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1519570795;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1520253977;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1520850256;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1520891167;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1521626215;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1522337739;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1523010728;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1523010728;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1523010728;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1524129142;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1524760045;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1524906327;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1525332388;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1525661782;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1526313052;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1526562913;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1527071274;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(1 + stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,1,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1528201124;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1529325710;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1530639128;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots);1531145571;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1528201124;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1529325710;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1530639128;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531145571;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531404901;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531405434;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531419503;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531422929;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531771917;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531771917;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533212741;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533212741;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533224436;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533318024;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533565670;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533647766;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533924441;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533924476;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1534854671;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1534854671;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1534937605;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1539149054;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1539939663;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1544521602;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1544521602;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1544521602;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1545300278;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546862341;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546862378;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546867949;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546867949;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546956357;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546956357;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1548411242;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1548440094;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_						(IncrementalKeyedStateHandle) rawStateHandle,_						temporaryRestoreInstancePath)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1550581511;Recovery from multi incremental states with rescaling. For rescaling, this method creates a temporary_RocksDB instance for a key-groups shard. All contents from the temporary instance are copied into the_real restore instance and then the temporary instance is discarded.;void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			this.restoredBackendUID = UUID.randomUUID()___			initTargetDB(restoreStateHandles, stateBackend.keyGroupRange)___			byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getStartKeyGroup(), startKeyGroupPrefixBytes)___			byte[] stopKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__			RocksDBKeySerializationUtils.serializeKeyGroup(stateBackend.getKeyGroupRange().getEndKeyGroup() + 1, stopKeyGroupPrefixBytes)___			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (!(rawStateHandle instanceof IncrementalKeyedStateHandle)) {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				Path temporaryRestoreInstancePath = new Path(stateBackend.instanceBasePath.getAbsolutePath() + UUID.randomUUID().toString())__				try (RestoredDBInstance tmpRestoreDBInfo = restoreDBInstanceFromStateHandle(_					(IncrementalKeyedStateHandle) rawStateHandle, temporaryRestoreInstancePath, false)__					RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__					List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors = tmpRestoreDBInfo.columnFamilyDescriptors__					List<ColumnFamilyHandle> tmpColumnFamilyHandles = tmpRestoreDBInfo.columnFamilyHandles___					_					for (int i = 0_ i < tmpColumnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i)__						ColumnFamilyDescriptor tmpColumnFamilyDescriptor = tmpColumnFamilyDescriptors.get(i)___						ColumnFamilyHandle targetColumnFamilyHandle = getOrRegisterColumnFamilyHandle(_							tmpColumnFamilyDescriptor, null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))___						try (RocksIteratorWrapper iterator = getRocksIterator(tmpRestoreDBInfo.db, tmpColumnFamilyHandle)) {__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(iterator.key(), stopKeyGroupPrefixBytes)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								} else {_									_									_									break__								}__								iterator.next()__							}_						} _					}_				} finally {_					FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__					if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_						restoreFileSystem.delete(temporaryRestoreInstancePath, true)__					}_				}_			}_		};recovery,from,multi,incremental,states,with,rescaling,for,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;void,restore,with,rescaling,collection,keyed,state,handle,restore,state,handles,throws,exception,this,restored,backend,uid,uuid,random,uuid,init,target,db,restore,state,handles,state,backend,key,group,range,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,start,key,group,start,key,group,prefix,bytes,byte,stop,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,rocks,dbkey,serialization,utils,serialize,key,group,state,backend,get,key,group,range,get,end,key,group,1,stop,key,group,prefix,bytes,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,restored,dbinstance,tmp,restore,dbinfo,restore,dbinstance,from,state,handle,incremental,keyed,state,handle,raw,state,handle,temporary,restore,instance,path,false,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,list,column,family,descriptor,tmp,column,family,descriptors,tmp,restore,dbinfo,column,family,descriptors,list,column,family,handle,tmp,column,family,handles,tmp,restore,dbinfo,column,family,handles,for,int,i,0,i,tmp,column,family,descriptors,size,i,column,family,handle,tmp,column,family,handle,tmp,column,family,handles,get,i,column,family,descriptor,tmp,column,family,descriptor,tmp,column,family,descriptors,get,i,column,family,handle,target,column,family,handle,get,or,register,column,family,handle,tmp,column,family,descriptor,null,tmp,restore,dbinfo,state,meta,info,snapshots,get,i,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,tmp,restore,dbinfo,db,tmp,column,family,handle,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,if,rocks,dbincremental,checkpoint,utils,before,the,prefix,bytes,iterator,key,stop,key,group,prefix,bytes,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,else,break,iterator,next,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1519570794;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1519570794;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1519570794;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1519570795;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1520253977;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1520850256;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1520891167;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1521626215;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1522337739;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1523010728;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1523010728;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1523010728;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1524129142;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1524760045;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1524906327;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1525332388;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1525661782;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1526313052;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1526562913;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception;1527071274;Recovery from local incremental state.;private void restoreInstance(IncrementalLocalKeyedStateHandle localKeyedStateHandle) throws Exception {_			_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots =_				readMetaData(localKeyedStateHandle.getMetaDataState())___			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___			restoreLocalStateIntoFullInstance(_				localKeyedStateHandle,_				columnFamilyDescriptors,_				stateMetaInfoSnapshots)__		};recovery,from,local,incremental,state;private,void,restore,instance,incremental,local,keyed,state,handle,local,keyed,state,handle,throws,exception,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,list,column,family,descriptor,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1519061869;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1519379856;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1519567828;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1519567828;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1519568061;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1519570794;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1519570794;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1519570794;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1519570795;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1520253977;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1520850256;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1520891167;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1521626215;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1522337739;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1523010728;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1523010728;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1523010728;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1524129142;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1524760045;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1524906327;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1525332388;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1525661782;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1526313052;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1526562913;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1527071274;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1528201124;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1529325710;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1530639128;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1531145571;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1531404901;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1531405434;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1531419503;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1531422929;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1531771917;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1531771917;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1533212741;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1533212741;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1533224436;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1533318024;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1533565670;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyValueState();1533647766;Indicates if current key starts a new k/v-state, i.e. belong to a different k/v-state than it's predecessor._@return true iff the current key belong to a different k/v-state than it's predecessor.;public boolean isNewKeyValueState() {_			return newKVState__		};indicates,if,current,key,starts,a,new,k,v,state,i,e,belong,to,a,different,k,v,state,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,k,v,state,than,it,s,predecessor;public,boolean,is,new,key,value,state,return,new,kvstate
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1533318024;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1533565670;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1533647766;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1533924441;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1533924476;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1534854671;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1534854671;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1534937605;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1539149054;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1539939663;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			registerKvStateInformation(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,register,kv,state,information,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1540907751;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			registerKvStateInformation(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,register,kv,state,information,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1540907751;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			registerKvStateInformation(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,register,kv,state,information,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException;1540907751;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<S> snapshotTransformer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc,_				snapshotTransformer)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer(),_				snapshotTransformer)___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			registerKvStateInformation(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,s,snapshot,transformer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,snapshot,transformer,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,snapshot,transformer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,register,kv,state,information,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV, SEV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 		StateDescriptor<S, SV> stateDesc, 		TypeSerializer<N> namespaceSerializer, 		@Nonnull StateSnapshotTransformFactory<SEV> snapshotTransformFactory) throws Exception;1550581511;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV, SEV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_		StateDescriptor<S, SV> stateDesc,_		TypeSerializer<N> namespaceSerializer,_		@Nonnull StateSnapshotTransformFactory<SEV> snapshotTransformFactory) throws Exception {__		RocksDbKvStateInfo oldStateInfo = kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		RocksDbKvStateInfo newRocksStateInfo__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.metaInfo___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.columnFamilyHandle, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer)___			newRocksStateInfo = new RocksDbKvStateInfo(oldStateInfo.columnFamilyHandle, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), newRocksStateInfo)___		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				StateSnapshotTransformFactory.noTransform())___			newRocksStateInfo = createStateInfo(newMetaInfo)__			registerKvStateInformation(stateDesc.getName(), newRocksStateInfo)__		}__		StateSnapshotTransformFactory<SV> wrappedSnapshotTransformFactory = wrapStateSnapshotTransformFactory(_			stateDesc, snapshotTransformFactory, newMetaInfo.getStateSerializer())__		newMetaInfo.updateSnapshotTransformFactory(wrappedSnapshotTransformFactory)___		ttlCompactFiltersManager.configCompactFilter(stateDesc, newMetaInfo.getStateSerializer())___		return Tuple2.of(newRocksStateInfo.columnFamilyHandle, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,sev,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nonnull,state,snapshot,transform,factory,sev,snapshot,transform,factory,throws,exception,rocks,db,kv,state,info,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,rocks,db,kv,state,info,new,rocks,state,info,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,meta,info,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,column,family,handle,casted,meta,info,state,desc,namespace,serializer,state,serializer,new,rocks,state,info,new,rocks,db,kv,state,info,old,state,info,column,family,handle,new,meta,info,kv,state,information,put,state,desc,get,name,new,rocks,state,info,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,state,snapshot,transform,factory,no,transform,new,rocks,state,info,create,state,info,new,meta,info,register,kv,state,information,state,desc,get,name,new,rocks,state,info,state,snapshot,transform,factory,sv,wrapped,snapshot,transform,factory,wrap,state,snapshot,transform,factory,state,desc,snapshot,transform,factory,new,meta,info,get,state,serializer,new,meta,info,update,snapshot,transform,factory,wrapped,snapshot,transform,factory,ttl,compact,filters,manager,config,compact,filter,state,desc,new,meta,info,get,state,serializer,return,tuple2,of,new,rocks,state,info,column,family,handle,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV, SEV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 		StateDescriptor<S, SV> stateDesc, 		TypeSerializer<N> namespaceSerializer, 		@Nonnull StateSnapshotTransformFactory<SEV> snapshotTransformFactory) throws Exception;1550863001;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV, SEV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_		StateDescriptor<S, SV> stateDesc,_		TypeSerializer<N> namespaceSerializer,_		@Nonnull StateSnapshotTransformFactory<SEV> snapshotTransformFactory) throws Exception {__		RocksDbKvStateInfo oldStateInfo = kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		RocksDbKvStateInfo newRocksStateInfo__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo =_				(RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.metaInfo___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.columnFamilyHandle, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer)___			newRocksStateInfo = new RocksDbKvStateInfo(oldStateInfo.columnFamilyHandle, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), newRocksStateInfo)__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				StateSnapshotTransformFactory.noTransform())___			newRocksStateInfo = RocksDBOperationUtils.createStateInfo(newMetaInfo, ttlCompactFiltersManager,_				ttlTimeProvider, db, columnFamilyOptionsFactory)__			RocksDBOperationUtils.registerKvStateInformation(this.kvStateInformation, this.nativeMetricMonitor,_				stateDesc.getName(), newRocksStateInfo)__		}__		StateSnapshotTransformFactory<SV> wrappedSnapshotTransformFactory = wrapStateSnapshotTransformFactory(_			stateDesc, snapshotTransformFactory, newMetaInfo.getStateSerializer())__		newMetaInfo.updateSnapshotTransformFactory(wrappedSnapshotTransformFactory)___		ttlCompactFiltersManager.configCompactFilter(stateDesc, newMetaInfo.getStateSerializer())___		return Tuple2.of(newRocksStateInfo.columnFamilyHandle, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,sev,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nonnull,state,snapshot,transform,factory,sev,snapshot,transform,factory,throws,exception,rocks,db,kv,state,info,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,rocks,db,kv,state,info,new,rocks,state,info,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,meta,info,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,column,family,handle,casted,meta,info,state,desc,namespace,serializer,state,serializer,new,rocks,state,info,new,rocks,db,kv,state,info,old,state,info,column,family,handle,new,meta,info,kv,state,information,put,state,desc,get,name,new,rocks,state,info,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,state,snapshot,transform,factory,no,transform,new,rocks,state,info,rocks,dboperation,utils,create,state,info,new,meta,info,ttl,compact,filters,manager,ttl,time,provider,db,column,family,options,factory,rocks,dboperation,utils,register,kv,state,information,this,kv,state,information,this,native,metric,monitor,state,desc,get,name,new,rocks,state,info,state,snapshot,transform,factory,sv,wrapped,snapshot,transform,factory,wrap,state,snapshot,transform,factory,state,desc,snapshot,transform,factory,new,meta,info,get,state,serializer,new,meta,info,update,snapshot,transform,factory,wrapped,snapshot,transform,factory,ttl,compact,filters,manager,config,compact,filter,state,desc,new,meta,info,get,state,serializer,return,tuple2,of,new,rocks,state,info,column,family,handle,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1540907751;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_			stateDesc.getType(),_			stateDesc.getName(),_			namespaceSerializer,_			stateSerializer,_			snapshotTransformer)___		if (stateInfo != null) {_			newMetaInfo = migrateStateIfNecessary(_				newMetaInfo,_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				stateInfo)___			stateInfo.f1 = newMetaInfo__		} else {_			ColumnFamilyHandle columnFamily = createColumnFamily(stateDesc.getName())___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			registerKvStateInformation(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,if,state,info,null,new,meta,info,migrate,state,if,necessary,new,meta,info,state,desc,namespace,serializer,state,serializer,state,info,state,info,f1,new,meta,info,else,column,family,handle,column,family,create,column,family,state,desc,get,name,state,info,tuple2,of,column,family,new,meta,info,register,kv,state,information,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1540907751;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_			stateDesc.getType(),_			stateDesc.getName(),_			namespaceSerializer,_			stateSerializer,_			snapshotTransformer)___		if (stateInfo != null) {_			newMetaInfo = migrateStateIfNecessary(_				newMetaInfo,_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				stateInfo)___			stateInfo.f1 = newMetaInfo__		} else {_			ColumnFamilyHandle columnFamily = createColumnFamily(stateDesc.getName())___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			registerKvStateInformation(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,if,state,info,null,new,meta,info,migrate,state,if,necessary,new,meta,info,state,desc,namespace,serializer,state,serializer,state,info,state,info,f1,new,meta,info,else,column,family,handle,column,family,create,column,family,state,desc,get,name,state,info,tuple2,of,column,family,new,meta,info,register,kv,state,information,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1544521602;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_			stateDesc.getType(),_			stateDesc.getName(),_			namespaceSerializer,_			stateSerializer,_			snapshotTransformer)___		if (stateInfo != null) {_			newMetaInfo = migrateStateIfNecessary(_				newMetaInfo,_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				stateInfo)___			stateInfo.f1 = newMetaInfo__		} else {_			ColumnFamilyHandle columnFamily = createColumnFamily(stateDesc.getName())___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			registerKvStateInformation(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,if,state,info,null,new,meta,info,migrate,state,if,necessary,new,meta,info,state,desc,namespace,serializer,state,serializer,state,info,state,info,f1,new,meta,info,else,column,family,handle,column,family,create,column,family,state,desc,get,name,state,info,tuple2,of,column,family,new,meta,info,register,kv,state,information,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1544521602;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1544521602;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1545300278;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1546862341;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1546862378;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1546867949;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1546867949;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1546956357;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1546956357;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation( 			StateDescriptor<S, SV> stateDesc, 			TypeSerializer<N> namespaceSerializer, 			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception;1548411242;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S extends State, SV> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> tryRegisterKvStateInformation(_			StateDescriptor<S, SV> stateDesc,_			TypeSerializer<N> namespaceSerializer,_			@Nullable StateSnapshotTransformer<SV> snapshotTransformer) throws Exception {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> oldStateInfo =_			kvStateInformation.get(stateDesc.getName())___		TypeSerializer<SV> stateSerializer = stateDesc.getSerializer()___		ColumnFamilyHandle newColumnFamily__		RegisteredKeyValueStateBackendMetaInfo<N, SV> newMetaInfo__		if (oldStateInfo != null) {_			@SuppressWarnings("unchecked")_			RegisteredKeyValueStateBackendMetaInfo<N, SV> castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo<N, SV>) oldStateInfo.f1___			newMetaInfo = updateRestoredStateMetaInfo(_				Tuple2.of(oldStateInfo.f0, castedMetaInfo),_				stateDesc,_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			oldStateInfo.f1 = newMetaInfo__			newColumnFamily = oldStateInfo.f0__		} else {_			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateDesc.getName(),_				namespaceSerializer,_				stateSerializer,_				snapshotTransformer)___			newColumnFamily = createColumnFamily(stateDesc.getName())__			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo))__		}__		return Tuple2.of(newColumnFamily, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,extends,state,sv,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,try,register,kv,state,information,state,descriptor,s,sv,state,desc,type,serializer,n,namespace,serializer,nullable,state,snapshot,transformer,sv,snapshot,transformer,throws,exception,tuple2,column,family,handle,registered,state,meta,info,base,old,state,info,kv,state,information,get,state,desc,get,name,type,serializer,sv,state,serializer,state,desc,get,serializer,column,family,handle,new,column,family,registered,key,value,state,backend,meta,info,n,sv,new,meta,info,if,old,state,info,null,suppress,warnings,unchecked,registered,key,value,state,backend,meta,info,n,sv,casted,meta,info,registered,key,value,state,backend,meta,info,n,sv,old,state,info,f1,new,meta,info,update,restored,state,meta,info,tuple2,of,old,state,info,f0,casted,meta,info,state,desc,namespace,serializer,state,serializer,snapshot,transformer,old,state,info,f1,new,meta,info,new,column,family,old,state,info,f0,else,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,desc,get,name,namespace,serializer,state,serializer,snapshot,transformer,new,column,family,create,column,family,state,desc,get,name,register,kv,state,information,state,desc,get,name,tuple2,of,new,column,family,new,meta,info,return,tuple2,of,new,column,family,new,meta,info
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1519061869;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1519379856;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1519567828;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1519567828;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1519568061;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1519570794;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1519570794;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1519570794;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1519570795;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1520253977;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, rocksDBKeyedStateBackend.writeOptions, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, rocksDBKeyedStateBackend.writeOptions, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,rocks,dbkeyed,state,backend,write,options,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,rocks,dbkeyed,state,backend,write,options,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1520850256;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1520891167;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1521626215;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1522337739;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1523010728;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1523010728;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1523010728;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1524129142;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1524760045;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1524906327;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1525332388;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1525661782;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1526313052;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1526562913;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_				int keyGroup = keyGroupOffset.f0___				_				Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_					"The key group must belong to the backend")___				long offset = keyGroupOffset.f1__				_				if (0L != offset) {_					currentStateHandleInStream.seek(offset)__					try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_						DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__						_						int kvStateId = compressedKgInputView.readShort()__						ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__						_						boolean keyGroupHasMoreKeys = true__						while (keyGroupHasMoreKeys) {_							byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__							if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_								_								RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__								rocksDBKeyedStateBackend.db.put(handle, key, value)__								_								kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_									& compressedKgInputView.readShort()__								if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_									keyGroupHasMoreKeys = false__								} else {_									handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__								}_							} else {_								rocksDBKeyedStateBackend.db.put(handle, key, value)__							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,rocks,dbkeyed,state,backend,db,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,rocks,dbkeyed,state,backend,db,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1527071274;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1528201124;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1529325710;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1530639128;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1531145571;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1531404901;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1531405434;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1531419503;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1531422929;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1531771917;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1531771917;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1533212741;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1533212741;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1533224436;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1533318024;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1533565670;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1533647766;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1533924441;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1533924476;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.__@throws IOException_@throws RocksDBException;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(key)) {_									_									RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle,throws,ioexception,throws,rocks,dbexception;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,rocks,dbfull,snapshot,operation,has,meta,data,follows,flag,key,rocks,dbfull,snapshot,operation,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,rocks,dbfull,snapshot,operation,compressed,kg,input,view,read,short,if,rocks,dbfull,snapshot,operation,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1534854671;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1534854671;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1534937605;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1539149054;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1539939663;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1540907751;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1544521602;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1544521602;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1544521602;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1545300278;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1546862341;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1546862378;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1546867949;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1546867949;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1546956357;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1546956357;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1548411242;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1548440094;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							ColumnFamilyHandle handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(handle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										handle = currentStateHandleKVStateColumnFamilies.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(handle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,column,family,handle,handle,current,state,handle,kvstate,column,families,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,handle,current,state,handle,kvstate,column,families,get,kv,state,id,else,write,batch,wrapper,put,handle,key,value
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKVStateData() throws IOException, RocksDBException;1550581511;Restore the KV-state / ColumnFamily data for all key-groups referenced by the current state handle.;private void restoreKVStateData() throws IOException, RocksDBException {_			_			try (RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(rocksDBKeyedStateBackend.db)) {_				for (Tuple2<Integer, Long> keyGroupOffset : currentKeyGroupsStateHandle.getGroupRangeOffsets()) {_					int keyGroup = keyGroupOffset.f0___					_					Preconditions.checkState(rocksDBKeyedStateBackend.getKeyGroupRange().contains(keyGroup),_						"The key group must belong to the backend")___					long offset = keyGroupOffset.f1__					_					if (0L != offset) {_						currentStateHandleInStream.seek(offset)__						try (InputStream compressedKgIn = keygroupStreamCompressionDecorator.decorateWithCompression(currentStateHandleInStream)) {_							DataInputViewStreamWrapper compressedKgInputView = new DataInputViewStreamWrapper(compressedKgIn)__							_							int kvStateId = compressedKgInputView.readShort()__							RocksDbKvStateInfo stateInfo = currentKvStates.get(kvStateId)__							_							boolean keyGroupHasMoreKeys = true__							while (keyGroupHasMoreKeys) {_								byte[] key = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								byte[] value = BytePrimitiveArraySerializer.INSTANCE.deserialize(compressedKgInputView)__								if (hasMetaDataFollowsFlag(key)) {_									_									clearMetaDataFollowsFlag(key)__									writeBatchWrapper.put(stateInfo.columnFamilyHandle, key, value)__									_									kvStateId = END_OF_KEY_GROUP_MARK_										& compressedKgInputView.readShort()__									if (END_OF_KEY_GROUP_MARK == kvStateId) {_										keyGroupHasMoreKeys = false__									} else {_										stateInfo = currentKvStates.get(kvStateId)__									}_								} else {_									writeBatchWrapper.put(stateInfo.columnFamilyHandle, key, value)__								}_							}_						}_					}_				}_			}_		};restore,the,kv,state,column,family,data,for,all,key,groups,referenced,by,the,current,state,handle;private,void,restore,kvstate,data,throws,ioexception,rocks,dbexception,try,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,rocks,dbkeyed,state,backend,db,for,tuple2,integer,long,key,group,offset,current,key,groups,state,handle,get,group,range,offsets,int,key,group,key,group,offset,f0,preconditions,check,state,rocks,dbkeyed,state,backend,get,key,group,range,contains,key,group,the,key,group,must,belong,to,the,backend,long,offset,key,group,offset,f1,if,0l,offset,current,state,handle,in,stream,seek,offset,try,input,stream,compressed,kg,in,keygroup,stream,compression,decorator,decorate,with,compression,current,state,handle,in,stream,data,input,view,stream,wrapper,compressed,kg,input,view,new,data,input,view,stream,wrapper,compressed,kg,in,int,kv,state,id,compressed,kg,input,view,read,short,rocks,db,kv,state,info,state,info,current,kv,states,get,kv,state,id,boolean,key,group,has,more,keys,true,while,key,group,has,more,keys,byte,key,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,byte,value,byte,primitive,array,serializer,instance,deserialize,compressed,kg,input,view,if,has,meta,data,follows,flag,key,clear,meta,data,follows,flag,key,write,batch,wrapper,put,state,info,column,family,handle,key,value,kv,state,id,compressed,kg,input,view,read,short,if,kv,state,id,key,group,has,more,keys,false,else,state,info,current,kv,states,get,kv,state,id,else,write,batch,wrapper,put,state,info,column,family,handle,key,value
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1519061869;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1519379856;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1519567828;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1519567828;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1519568061;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1519570794;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1519570794;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1519570794;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1519570795;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1520253977;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1520850256;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1520891167;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1521626215;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1522337739;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1523010728;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1523010728;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1523010728;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1524129142;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1524760045;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1524906327;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1525332388;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1525661782;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1526313052;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1526562913;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1527071274;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1528201124;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1529325710;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1530639128;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1531145571;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1531404901;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1531405434;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1531419503;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1531422929;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1531771917;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1531771917;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1533212741;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1533212741;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1533224436;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1533318024;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1533565670;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int kvStateId();1533647766;@return Id of K/V state to which the current key belongs.;public int kvStateId() {_			return currentSubIterator.getKvStateId()__		};return,id,of,k,v,state,to,which,the,current,key,belongs;public,int,kv,state,id,return,current,sub,iterator,get,kv,state,id
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1534854671;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1534937605;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1539149054;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1539939663;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1540907751;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1540907751;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1540907751;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1540907751;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1540907751;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1544521602;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1544521602;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1544521602;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1545300278;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1546862341;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1546862378;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1546867949;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1546867949;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1546956357;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1546956357;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1548411242;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1548440094;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1550581511;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> @Nonnull 	@Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		@Nonnull final CheckpointStreamFactory streamFactory, 		@Nonnull CheckpointOptions checkpointOptions) throws Exception;1550863001;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Nonnull_	@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		@Nonnull final CheckpointStreamFactory streamFactory,_		@Nonnull CheckpointOptions checkpointOptions) throws Exception {__		long startTime = System.currentTimeMillis()___		_		writeBatchWrapper.flush()___		RocksDBSnapshotStrategyBase<K> chosenSnapshotStrategy =_			CheckpointType.SAVEPOINT == checkpointOptions.getCheckpointType() ?_				savepointSnapshotStrategy : checkpointSnapshotStrategy___		RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner =_			chosenSnapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions)___		chosenSnapshotStrategy.logSyncCompleted(streamFactory, startTime)___		return snapshotRunner__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;nonnull,override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,nonnull,final,checkpoint,stream,factory,stream,factory,nonnull,checkpoint,options,checkpoint,options,throws,exception,long,start,time,system,current,time,millis,write,batch,wrapper,flush,rocks,dbsnapshot,strategy,base,k,chosen,snapshot,strategy,checkpoint,type,savepoint,checkpoint,options,get,checkpoint,type,savepoint,snapshot,strategy,checkpoint,snapshot,strategy,runnable,future,snapshot,result,keyed,state,handle,snapshot,runner,chosen,snapshot,strategy,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options,chosen,snapshot,strategy,log,sync,completed,stream,factory,start,time,return,snapshot,runner
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp);1519061869;1) Create a snapshot object from RocksDB.__@param checkpointId id of the checkpoint for which we take the snapshot_@param checkpointTimeStamp timestamp of the checkpoint for which we take the snapshot;public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp) {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateIterators = new ArrayList<>(stateBackend.kvStateInformation.size())__			this.checkpointId = checkpointId__			this.checkpointTimeStamp = checkpointTimeStamp__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db,param,checkpoint,id,id,of,the,checkpoint,for,which,we,take,the,snapshot,param,checkpoint,time,stamp,timestamp,of,the,checkpoint,for,which,we,take,the,snapshot;public,void,take,dbsnap,shot,long,checkpoint,id,long,checkpoint,time,stamp,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,iterators,new,array,list,state,backend,kv,state,information,size,this,checkpoint,id,checkpoint,id,this,checkpoint,time,stamp,checkpoint,time,stamp,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp);1519379856;1) Create a snapshot object from RocksDB.__@param checkpointId id of the checkpoint for which we take the snapshot_@param checkpointTimeStamp timestamp of the checkpoint for which we take the snapshot;public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp) {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateIterators = new ArrayList<>(stateBackend.kvStateInformation.size())__			this.checkpointId = checkpointId__			this.checkpointTimeStamp = checkpointTimeStamp__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db,param,checkpoint,id,id,of,the,checkpoint,for,which,we,take,the,snapshot,param,checkpoint,time,stamp,timestamp,of,the,checkpoint,for,which,we,take,the,snapshot;public,void,take,dbsnap,shot,long,checkpoint,id,long,checkpoint,time,stamp,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,iterators,new,array,list,state,backend,kv,state,information,size,this,checkpoint,id,checkpoint,id,this,checkpoint,time,stamp,checkpoint,time,stamp,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp);1519567828;1) Create a snapshot object from RocksDB.__@param checkpointId id of the checkpoint for which we take the snapshot_@param checkpointTimeStamp timestamp of the checkpoint for which we take the snapshot;public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp) {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateIterators = new ArrayList<>(stateBackend.kvStateInformation.size())__			this.checkpointId = checkpointId__			this.checkpointTimeStamp = checkpointTimeStamp__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db,param,checkpoint,id,id,of,the,checkpoint,for,which,we,take,the,snapshot,param,checkpoint,time,stamp,timestamp,of,the,checkpoint,for,which,we,take,the,snapshot;public,void,take,dbsnap,shot,long,checkpoint,id,long,checkpoint,time,stamp,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,iterators,new,array,list,state,backend,kv,state,information,size,this,checkpoint,id,checkpoint,id,this,checkpoint,time,stamp,checkpoint,time,stamp,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp);1519567828;1) Create a snapshot object from RocksDB.__@param checkpointId id of the checkpoint for which we take the snapshot_@param checkpointTimeStamp timestamp of the checkpoint for which we take the snapshot;public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp) {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateIterators = new ArrayList<>(stateBackend.kvStateInformation.size())__			this.checkpointId = checkpointId__			this.checkpointTimeStamp = checkpointTimeStamp__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db,param,checkpoint,id,id,of,the,checkpoint,for,which,we,take,the,snapshot,param,checkpoint,time,stamp,timestamp,of,the,checkpoint,for,which,we,take,the,snapshot;public,void,take,dbsnap,shot,long,checkpoint,id,long,checkpoint,time,stamp,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,iterators,new,array,list,state,backend,kv,state,information,size,this,checkpoint,id,checkpoint,id,this,checkpoint,time,stamp,checkpoint,time,stamp,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp);1519568061;1) Create a snapshot object from RocksDB.__@param checkpointId id of the checkpoint for which we take the snapshot_@param checkpointTimeStamp timestamp of the checkpoint for which we take the snapshot;public void takeDBSnapShot(long checkpointId, long checkpointTimeStamp) {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateIterators = new ArrayList<>(stateBackend.kvStateInformation.size())__			this.checkpointId = checkpointId__			this.checkpointTimeStamp = checkpointTimeStamp__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db,param,checkpoint,id,id,of,the,checkpoint,for,which,we,take,the,snapshot,param,checkpoint,time,stamp,timestamp,of,the,checkpoint,for,which,we,take,the,snapshot;public,void,take,dbsnap,shot,long,checkpoint,id,long,checkpoint,time,stamp,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,iterators,new,array,list,state,backend,kv,state,information,size,this,checkpoint,id,checkpoint,id,this,checkpoint,time,stamp,checkpoint,time,stamp,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1519570794;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(columnFamilyHandles.size() - 1)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,column,family,handles,size,1,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1519570794;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(columnFamilyHandles.size() - 1)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,column,family,handles,size,1,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1519570794;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1519570795;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1520253977;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1520850256;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1520891167;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1521626215;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1522337739;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1523010728;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1523010728;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1523010728;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1524129142;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1524760045;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1524906327;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1525332388;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1525661782;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1526313052;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1526562913;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1527071274;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1528201124;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1529325710;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1530639128;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1531145571;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(_						stateMetaInfoSnapshot.getStateType(),_						stateMetaInfoSnapshot.getName(),_						stateMetaInfoSnapshot.getNamespaceSerializer(),_						stateMetaInfoSnapshot.getStateSerializer())___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1519061869;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			outStream = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,out,stream,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1519379856;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			outStream = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,out,stream,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1519567828;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			outStream = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,out,stream,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1519567828;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			outStream = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,out,stream,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1519568061;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			outStream = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,out,stream,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1519570794;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1519570794;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1519570794;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1519570795;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1520253977;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1520850256;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1520891167;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1521626215;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1522337739;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1523010728;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1523010728;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1523010728;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1524129142;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1524760045;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1524906327;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1525332388;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1525661782;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1526313052;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIterator, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1526562913;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1527071274;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1528201124;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1529325710;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1530639128;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1531145571;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1531404901;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1531405434;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1531419503;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1531422929;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1531771917;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1531771917;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1533212741;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1533212741;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1533224436;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1533318024;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1533565670;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1533647766;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1533924441;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void releaseSnapshotResources();1533924476;5) Release the snapshot object for RocksDB and clean up.;public void releaseSnapshotResources() {__			checkpointStreamWithResultProvider = null___			if (null != kvStateIterators) {_				for (Tuple2<RocksIteratorWrapper, Integer> kvStateIterator : kvStateIterators) {_					IOUtils.closeQuietly(kvStateIterator.f0)__				}_				kvStateIterators = null__			}__			if (null != snapshot) {_				if (null != stateBackend.db) {_					stateBackend.db.releaseSnapshot(snapshot)__				}_				IOUtils.closeQuietly(snapshot)__				snapshot = null__			}__			if (null != readOptions) {_				IOUtils.closeQuietly(readOptions)__				readOptions = null__			}__			this.dbLease.close()__		};5,release,the,snapshot,object,for,rocks,db,and,clean,up;public,void,release,snapshot,resources,checkpoint,stream,with,result,provider,null,if,null,kv,state,iterators,for,tuple2,rocks,iterator,wrapper,integer,kv,state,iterator,kv,state,iterators,ioutils,close,quietly,kv,state,iterator,f0,kv,state,iterators,null,if,null,snapshot,if,null,state,backend,db,state,backend,db,release,snapshot,snapshot,ioutils,close,quietly,snapshot,snapshot,null,if,null,read,options,ioutils,close,quietly,read,options,read,options,null,this,db,lease,close
RocksDBKeyedStateBackend -> @VisibleForTesting 	public File getInstanceBasePath();1519061869;Only visible for testing, DO NOT USE.;@VisibleForTesting_	public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;visible,for,testing,public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> @VisibleForTesting 	public File getInstanceBasePath();1519379856;Only visible for testing, DO NOT USE.;@VisibleForTesting_	public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;visible,for,testing,public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> @VisibleForTesting 	public File getInstanceBasePath();1519567828;Only visible for testing, DO NOT USE.;@VisibleForTesting_	public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;visible,for,testing,public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> @VisibleForTesting 	public File getInstanceBasePath();1519567828;Only visible for testing, DO NOT USE.;@VisibleForTesting_	public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;visible,for,testing,public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> @VisibleForTesting 	public File getInstanceBasePath();1519568061;Only visible for testing, DO NOT USE.;@VisibleForTesting_	public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;visible,for,testing,public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException;1531404901;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName, db)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,db,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException;1531405434;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName, db)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,db,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException;1531419503;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName, db)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,db,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException;1531422929;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName, db)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,db,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1519570794;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1519570794;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1519570794;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1519570795;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1520253977;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1520850256;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1520891167;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1521626215;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1522337739;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1523010728;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1523010728;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1523010728;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1524129142;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1524760045;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1524906327;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1525332388;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1525661782;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1526313052;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1526562913;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1527071274;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			boolean hasExtraKeys = (restoreStateHandles.size() > 1 ||_				!Objects.equals(restoreStateHandles.iterator().next().getKeyGroupRange(), stateBackend.keyGroupRange))___			if (hasExtraKeys) {_				stateBackend.createDB()__			}__			for (KeyedStateHandle rawStateHandle : restoreStateHandles) {__				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {_					restoreInstance((IncrementalKeyedStateHandle) rawStateHandle, hasExtraKeys)__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {_					Preconditions.checkState(!hasExtraKeys, "Cannot recover from local state after rescaling.")__					restoreInstance((IncrementalLocalKeyedStateHandle) rawStateHandle)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}_			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,boolean,has,extra,keys,restore,state,handles,size,1,objects,equals,restore,state,handles,iterator,next,get,key,group,range,state,backend,key,group,range,if,has,extra,keys,state,backend,create,db,for,keyed,state,handle,raw,state,handle,restore,state,handles,if,raw,state,handle,instanceof,incremental,keyed,state,handle,restore,instance,incremental,keyed,state,handle,raw,state,handle,has,extra,keys,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,preconditions,check,state,has,extra,keys,cannot,recover,from,local,state,after,rescaling,restore,instance,incremental,local,keyed,state,handle,raw,state,handle,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1528201124;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1529325710;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1530639128;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531145571;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531404901;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531405434;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531419503;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531422929;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531771917;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1531771917;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533212741;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533212741;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533224436;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533318024;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533565670;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533647766;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533924441;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1533924476;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1534854671;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1534854671;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1534937605;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1539149054;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1539939663;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1540907751;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1544521602;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1544521602;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1544521602;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1545300278;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546862341;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546862378;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546867949;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546867949;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546956357;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1546956357;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1548411242;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1548440094;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception;1550581511;Root method that branches for different implementations of {@link KeyedStateHandle}.;void restore(Collection<KeyedStateHandle> restoreStateHandles) throws Exception {__			if (restoreStateHandles.isEmpty()) {_				return__			}__			final KeyedStateHandle theFirstStateHandle = restoreStateHandles.iterator().next()___			boolean isRescaling = (restoreStateHandles.size() > 1 ||_				!Objects.equals(theFirstStateHandle.getKeyGroupRange(), stateBackend.keyGroupRange))___			if (!isRescaling) {_				restoreWithoutRescaling(theFirstStateHandle)__			} else {_				restoreWithRescaling(restoreStateHandles)__			}_		};root,method,that,branches,for,different,implementations,of,link,keyed,state,handle;void,restore,collection,keyed,state,handle,restore,state,handles,throws,exception,if,restore,state,handles,is,empty,return,final,keyed,state,handle,the,first,state,handle,restore,state,handles,iterator,next,boolean,is,rescaling,restore,state,handles,size,1,objects,equals,the,first,state,handle,get,key,group,range,state,backend,key,group,range,if,is,rescaling,restore,without,rescaling,the,first,state,handle,else,restore,with,rescaling,restore,state,handles
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1528201124;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1529325710;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1530639128;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1531145571;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1531404901;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1531405434;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1531419503;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1531422929;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1531771917;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1531771917;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1533212741;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1533212741;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1533224436;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1533318024;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1533565670;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1533647766;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1533924441;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1533924476;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1534854671;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1534854671;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1534937605;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1539149054;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1539939663;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1540907751;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1540907751;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1540907751;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1540907751;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1540907751;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1544521602;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1544521602;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1544521602;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1545300278;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1546862341;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1546862378;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1546867949;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1546867949;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1546956357;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1546956357;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1548411242;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1548440094;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle,_						instancePath)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void initTargetDB( 			Collection<KeyedStateHandle> restoreStateHandles, 			KeyGroupRange targetKeyGroupRange) throws Exception;1550581511;This method first try to find a initial handle to init the target db, if the initial handle_is not null, we just init the target db with the handle and clip it with the target key-group_range. If the initial handle is null we create a empty db as the target db.;private void initTargetDB(_			Collection<KeyedStateHandle> restoreStateHandles,_			KeyGroupRange targetKeyGroupRange) throws Exception {__			IncrementalKeyedStateHandle initialHandle = (IncrementalKeyedStateHandle) RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(_				restoreStateHandles, targetKeyGroupRange)___			if (initialHandle != null) {_				restoreStateHandles.remove(initialHandle)__				RestoredDBInstance restoreDBInfo = null__				Path instancePath = new Path(stateBackend.instanceRocksDBPath.getAbsolutePath())__				try {_					restoreDBInfo = restoreDBInstanceFromStateHandle(_						initialHandle, instancePath, true)___					RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(_						restoreDBInfo.db,_						restoreDBInfo.columnFamilyHandles,_						targetKeyGroupRange,_						initialHandle.getKeyGroupRange(),_						stateBackend.keyGroupPrefixBytes)___					stateBackend.db = restoreDBInfo.db__					stateBackend.defaultColumnFamily = restoreDBInfo.defaultColumnFamilyHandle__					stateBackend.writeBatchWrapper =_						new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___					for (int i = 0_ i < restoreDBInfo.stateMetaInfoSnapshots.size()_ ++i) {_						getOrRegisterColumnFamilyHandle(_							restoreDBInfo.columnFamilyDescriptors.get(i),_							restoreDBInfo.columnFamilyHandles.get(i),_							restoreDBInfo.stateMetaInfoSnapshots.get(i))__					}_				} catch (Exception e) {_					if (restoreDBInfo != null) {_						restoreDBInfo.close()__					}_					FileSystem restoreFileSystem = instancePath.getFileSystem()__					if (restoreFileSystem.exists(instancePath)) {_						restoreFileSystem.delete(instancePath, true)__					}_					throw e__				}_			} else {_				List<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1)__				stateBackend.db = stateBackend.openDB(_					stateBackend.instanceRocksDBPath.getAbsolutePath(),_					Collections.emptyList(),_					columnFamilyHandles)__				stateBackend.defaultColumnFamily = columnFamilyHandles.get(0)__				stateBackend.writeBatchWrapper =_					new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)__			}_		};this,method,first,try,to,find,a,initial,handle,to,init,the,target,db,if,the,initial,handle,is,not,null,we,just,init,the,target,db,with,the,handle,and,clip,it,with,the,target,key,group,range,if,the,initial,handle,is,null,we,create,a,empty,db,as,the,target,db;private,void,init,target,db,collection,keyed,state,handle,restore,state,handles,key,group,range,target,key,group,range,throws,exception,incremental,keyed,state,handle,initial,handle,incremental,keyed,state,handle,rocks,dbincremental,checkpoint,utils,choose,the,best,state,handle,for,initial,restore,state,handles,target,key,group,range,if,initial,handle,null,restore,state,handles,remove,initial,handle,restored,dbinstance,restore,dbinfo,null,path,instance,path,new,path,state,backend,instance,rocks,dbpath,get,absolute,path,try,restore,dbinfo,restore,dbinstance,from,state,handle,initial,handle,instance,path,true,rocks,dbincremental,checkpoint,utils,clip,dbwith,key,group,range,restore,dbinfo,db,restore,dbinfo,column,family,handles,target,key,group,range,initial,handle,get,key,group,range,state,backend,key,group,prefix,bytes,state,backend,db,restore,dbinfo,db,state,backend,default,column,family,restore,dbinfo,default,column,family,handle,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,restore,dbinfo,state,meta,info,snapshots,size,i,get,or,register,column,family,handle,restore,dbinfo,column,family,descriptors,get,i,restore,dbinfo,column,family,handles,get,i,restore,dbinfo,state,meta,info,snapshots,get,i,catch,exception,e,if,restore,dbinfo,null,restore,dbinfo,close,file,system,restore,file,system,instance,path,get,file,system,if,restore,file,system,exists,instance,path,restore,file,system,delete,instance,path,true,throw,e,else,list,column,family,handle,column,family,handles,new,array,list,1,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,collections,empty,list,column,family,handles,state,backend,default,column,family,column,family,handles,get,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1519061869;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(DEFAULT_COLUMN_FAMILY_NAME_BYTES, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1519379856;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(DEFAULT_COLUMN_FAMILY_NAME_BYTES, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1519567828;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(DEFAULT_COLUMN_FAMILY_NAME_BYTES, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1519567828;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(DEFAULT_COLUMN_FAMILY_NAME_BYTES, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1519568061;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(DEFAULT_COLUMN_FAMILY_NAME_BYTES, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1519570794;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(DEFAULT_COLUMN_FAMILY_NAME_BYTES, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1519570794;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(DEFAULT_COLUMN_FAMILY_NAME_BYTES, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1519570794;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1519570795;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1520253977;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1520850256;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1520891167;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1521626215;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1522337739;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1523010728;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1523010728;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1523010728;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		Map rawAccess = kvStateInformation__		rawAccess.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,tuple,new,tuple2,column,family,new,meta,info,map,raw,access,kv,state,information,raw,access,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1524129142;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		kvStateInformation.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple,new,tuple2,column,family,new,meta,info,kv,state,information,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> @SuppressWarnings("rawtypes, unchecked") 	protected <N, S> ColumnFamilyHandle getColumnFamily( 		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException;1524760045;Creates a column family handle for use with a k/v state. When restoring from a snapshot_we don't restore the individual k/v states, just the global RocksDB database and the_list of column families. When a k/v state is first requested we check here whether we_already have a column family for that and return it or create a new one if it doesn't exist.__<p>This also checks whether the {@link StateDescriptor} for a state matches the one_that we checkpointed, i.e. is already in the map of column families.;@SuppressWarnings("rawtypes, unchecked")_	protected <N, S> ColumnFamilyHandle getColumnFamily(_		StateDescriptor<?, S> descriptor, TypeSerializer<N> namespaceSerializer) throws IOException, StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(descriptor.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_			descriptor.getType(),_			descriptor.getName(),_			namespaceSerializer,_			descriptor.getSerializer())___		if (stateInfo != null) {_			__			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfo =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(descriptor.getName())___			Preconditions.checkState(_				Objects.equals(newMetaInfo.getName(), restoredMetaInfo.getName()),_				"Incompatible state names. " +_					"Was [" + restoredMetaInfo.getName() + "], " +_					"registered with [" + newMetaInfo.getName() + "].")___			if (!Objects.equals(newMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)_				&& !Objects.equals(restoredMetaInfo.getStateType(), StateDescriptor.Type.UNKNOWN)) {__				Preconditions.checkState(_					newMetaInfo.getStateType() == restoredMetaInfo.getStateType(),_					"Incompatible state types. " +_						"Was [" + restoredMetaInfo.getStateType() + "], " +_						"registered with [" + newMetaInfo.getStateType() + "].")__			}__			_			CompatibilityResult<N> namespaceCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getNamespaceSerializer(),_				null,_				restoredMetaInfo.getNamespaceSerializerConfigSnapshot(),_				newMetaInfo.getNamespaceSerializer())___			CompatibilityResult<S> stateCompatibility = CompatibilityUtil.resolveCompatibilityResult(_				restoredMetaInfo.getStateSerializer(),_				UnloadableDummyTypeSerializer.class,_				restoredMetaInfo.getStateSerializerConfigSnapshot(),_				newMetaInfo.getStateSerializer())___			if (namespaceCompatibility.isRequiresMigration() || stateCompatibility.isRequiresMigration()) {_				_				throw new StateMigrationException("State migration isn't supported, yet.")__			} else {_				stateInfo.f1 = newMetaInfo__				return stateInfo.f0__			}_		}__		byte[] nameBytes = descriptor.getName().getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		final ColumnFamilyHandle columnFamily___		try {_			columnFamily = db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple =_			new Tuple2<>(columnFamily, newMetaInfo)__		kvStateInformation.put(descriptor.getName(), tuple)__		return columnFamily__	};creates,a,column,family,handle,for,use,with,a,k,v,state,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,column,families,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,column,family,for,that,and,return,it,or,create,a,new,one,if,it,doesn,t,exist,p,this,also,checks,whether,the,link,state,descriptor,for,a,state,matches,the,one,that,we,checkpointed,i,e,is,already,in,the,map,of,column,families;suppress,warnings,rawtypes,unchecked,protected,n,s,column,family,handle,get,column,family,state,descriptor,s,descriptor,type,serializer,n,namespace,serializer,throws,ioexception,state,migration,exception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,descriptor,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,new,registered,keyed,backend,state,meta,info,descriptor,get,type,descriptor,get,name,namespace,serializer,descriptor,get,serializer,if,state,info,null,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,descriptor,get,name,preconditions,check,state,objects,equals,new,meta,info,get,name,restored,meta,info,get,name,incompatible,state,names,was,restored,meta,info,get,name,registered,with,new,meta,info,get,name,if,objects,equals,new,meta,info,get,state,type,state,descriptor,type,unknown,objects,equals,restored,meta,info,get,state,type,state,descriptor,type,unknown,preconditions,check,state,new,meta,info,get,state,type,restored,meta,info,get,state,type,incompatible,state,types,was,restored,meta,info,get,state,type,registered,with,new,meta,info,get,state,type,compatibility,result,n,namespace,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,namespace,serializer,null,restored,meta,info,get,namespace,serializer,config,snapshot,new,meta,info,get,namespace,serializer,compatibility,result,s,state,compatibility,compatibility,util,resolve,compatibility,result,restored,meta,info,get,state,serializer,unloadable,dummy,type,serializer,class,restored,meta,info,get,state,serializer,config,snapshot,new,meta,info,get,state,serializer,if,namespace,compatibility,is,requires,migration,state,compatibility,is,requires,migration,throw,new,state,migration,exception,state,migration,isn,t,supported,yet,else,state,info,f1,new,meta,info,return,state,info,f0,byte,name,bytes,descriptor,get,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,final,column,family,handle,column,family,try,column,family,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple,new,tuple2,column,family,new,meta,info,kv,state,information,put,descriptor,get,name,tuple,return,column,family
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1519061869;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1519379856;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1519567828;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1519567828;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1519568061;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1519570794;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1519570794;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1519570794;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1519570795;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1520253977;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1520850256;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1520891167;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1521626215;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1522337739;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1523010728;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1523010728;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1523010728;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1524129142;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1524760045;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1524906327;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1525332388;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1525661782;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1526313052;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIterator rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {_				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1533318024;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1533565670;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next();1533647766;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException;1519061869;4) Returns a state handle to the snapshot after the snapshot procedure is completed and null before.__@return state handle to the completed snapshot;public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(outStream)) {__				StreamStateHandle stateHandle = outStream.closeAndGetHandle()__				outStream = null___				if (stateHandle != null) {_					return new KeyGroupsStateHandle(keyGroupRangeOffsets, stateHandle)__				}_			}_			return null__		};4,returns,a,state,handle,to,the,snapshot,after,the,snapshot,procedure,is,completed,and,null,before,return,state,handle,to,the,completed,snapshot;public,key,groups,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,out,stream,stream,state,handle,state,handle,out,stream,close,and,get,handle,out,stream,null,if,state,handle,null,return,new,key,groups,state,handle,key,group,range,offsets,state,handle,return,null
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException;1519379856;4) Returns a state handle to the snapshot after the snapshot procedure is completed and null before.__@return state handle to the completed snapshot;public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(outStream)) {__				StreamStateHandle stateHandle = outStream.closeAndGetHandle()__				outStream = null___				if (stateHandle != null) {_					return new KeyGroupsStateHandle(keyGroupRangeOffsets, stateHandle)__				}_			}_			return null__		};4,returns,a,state,handle,to,the,snapshot,after,the,snapshot,procedure,is,completed,and,null,before,return,state,handle,to,the,completed,snapshot;public,key,groups,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,out,stream,stream,state,handle,state,handle,out,stream,close,and,get,handle,out,stream,null,if,state,handle,null,return,new,key,groups,state,handle,key,group,range,offsets,state,handle,return,null
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException;1519567828;4) Returns a state handle to the snapshot after the snapshot procedure is completed and null before.__@return state handle to the completed snapshot;public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(outStream)) {__				StreamStateHandle stateHandle = outStream.closeAndGetHandle()__				outStream = null___				if (stateHandle != null) {_					return new KeyGroupsStateHandle(keyGroupRangeOffsets, stateHandle)__				}_			}_			return null__		};4,returns,a,state,handle,to,the,snapshot,after,the,snapshot,procedure,is,completed,and,null,before,return,state,handle,to,the,completed,snapshot;public,key,groups,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,out,stream,stream,state,handle,state,handle,out,stream,close,and,get,handle,out,stream,null,if,state,handle,null,return,new,key,groups,state,handle,key,group,range,offsets,state,handle,return,null
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException;1519567828;4) Returns a state handle to the snapshot after the snapshot procedure is completed and null before.__@return state handle to the completed snapshot;public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(outStream)) {__				StreamStateHandle stateHandle = outStream.closeAndGetHandle()__				outStream = null___				if (stateHandle != null) {_					return new KeyGroupsStateHandle(keyGroupRangeOffsets, stateHandle)__				}_			}_			return null__		};4,returns,a,state,handle,to,the,snapshot,after,the,snapshot,procedure,is,completed,and,null,before,return,state,handle,to,the,completed,snapshot;public,key,groups,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,out,stream,stream,state,handle,state,handle,out,stream,close,and,get,handle,out,stream,null,if,state,handle,null,return,new,key,groups,state,handle,key,group,range,offsets,state,handle,return,null
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException;1519568061;4) Returns a state handle to the snapshot after the snapshot procedure is completed and null before.__@return state handle to the completed snapshot;public KeyGroupsStateHandle getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(outStream)) {__				StreamStateHandle stateHandle = outStream.closeAndGetHandle()__				outStream = null___				if (stateHandle != null) {_					return new KeyGroupsStateHandle(keyGroupRangeOffsets, stateHandle)__				}_			}_			return null__		};4,returns,a,state,handle,to,the,snapshot,after,the,snapshot,procedure,is,completed,and,null,before,return,state,handle,to,the,completed,snapshot;public,key,groups,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,out,stream,stream,state,handle,state,handle,out,stream,close,and,get,handle,out,stream,null,if,state,handle,null,return,new,key,groups,state,handle,key,group,range,offsets,state,handle,return,null
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1548440094;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1550581511;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1526562913;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1527071274;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1528201124;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1529325710;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1530639128;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1531145571;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1531404901;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1531405434;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1531419503;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1531422929;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1531771917;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1531771917;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1533212741;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1533212741;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public void next() throws RocksDBException;1533224436;Advance the iterator. Should only be called if {@link #isValid()} returned true. Valid can only chance after_calls to {@link #next()}.;public void next() throws RocksDBException {_			newKeyGroup = false__			newKVState = false___			final RocksIteratorWrapper rocksIterator = currentSubIterator.getIterator()__			rocksIterator.next()___			byte[] oldKey = currentSubIterator.getCurrentKey()__			if (rocksIterator.isValid()) {__				currentSubIterator.currentKey = rocksIterator.key()___				if (isDifferentKeyGroup(oldKey, currentSubIterator.getCurrentKey())) {_					heap.offer(currentSubIterator)__					currentSubIterator = heap.poll()__					newKVState = currentSubIterator.getIterator() != rocksIterator__					detectNewKeyGroup(oldKey)__				}_			} else {_				IOUtils.closeQuietly(rocksIterator)___				if (heap.isEmpty()) {_					currentSubIterator = null__					valid = false__				} else {_					currentSubIterator = heap.poll()__					newKVState = true__					detectNewKeyGroup(oldKey)__				}_			}_		};advance,the,iterator,should,only,be,called,if,link,is,valid,returned,true,valid,can,only,chance,after,calls,to,link,next;public,void,next,throws,rocks,dbexception,new,key,group,false,new,kvstate,false,final,rocks,iterator,wrapper,rocks,iterator,current,sub,iterator,get,iterator,rocks,iterator,next,byte,old,key,current,sub,iterator,get,current,key,if,rocks,iterator,is,valid,current,sub,iterator,current,key,rocks,iterator,key,if,is,different,key,group,old,key,current,sub,iterator,get,current,key,heap,offer,current,sub,iterator,current,sub,iterator,heap,poll,new,kvstate,current,sub,iterator,get,iterator,rocks,iterator,detect,new,key,group,old,key,else,ioutils,close,quietly,rocks,iterator,if,heap,is,empty,current,sub,iterator,null,valid,false,else,current,sub,iterator,heap,poll,new,kvstate,true,detect,new,key,group,old,key
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db);1531145571;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,rocks,db,db,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db);1531404901;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,rocks,db,db,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db);1531405434;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,rocks,db,db,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db);1531419503;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,rocks,db,db,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db);1531422929;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName, RocksDB db) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,rocks,db,db,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1528201124;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1529325710;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1530639128;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1531145571;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1531404901;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1531405434;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1531419503;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1531422929;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1531771917;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1531771917;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1533212741;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1533212741;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1533224436;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1533318024;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1533565670;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1533647766;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1533924441;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1533924476;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1534854671;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1534854671;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1534937605;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1539149054;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1539939663;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1540907751;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1540907751;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1540907751;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1540907751;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1540907751;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1544521602;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1544521602;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1544521602;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1545300278;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath, stateBackend.restoringThreadNum, stateBackend.cancelStreamRegistry)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,restoring,thread,num,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1546862341;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath, stateBackend.restoringThreadNum, stateBackend.cancelStreamRegistry)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,restoring,thread,num,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1546862378;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath, stateBackend.restoringThreadNum, stateBackend.cancelStreamRegistry)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,restoring,thread,num,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1546867949;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath, stateBackend.restoringThreadNum, stateBackend.cancelStreamRegistry)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,restoring,thread,num,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1546867949;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath, stateBackend.restoringThreadNum, stateBackend.cancelStreamRegistry)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,restoring,thread,num,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1546956357;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath, stateBackend.restoringThreadNum, stateBackend.cancelStreamRegistry)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,restoring,thread,num,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1546956357;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					transferAllStateDataToDirectory(restoreStateHandle, temporaryRestoreInstancePath, stateBackend.restoringThreadNum, stateBackend.cancelStreamRegistry)___					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,restoring,thread,num,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1548411242;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					try (RocksDBStateDownloader rocksDBStateDownloader =_						new RocksDBStateDownloader(stateBackend.numberOfTransferingThreads)) {_						rocksDBStateDownloader.transferAllStateDataToDirectory(_							restoreStateHandle,_							temporaryRestoreInstancePath,_							stateBackend.cancelStreamRegistry)__					}__					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,try,rocks,dbstate,downloader,rocks,dbstate,downloader,new,rocks,dbstate,downloader,state,backend,number,of,transfering,threads,rocks,dbstate,downloader,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1548440094;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> columnFamilyDescriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					try (RocksDBStateDownloader rocksDBStateDownloader =_						new RocksDBStateDownloader(stateBackend.numberOfTransferingThreads)) {_						rocksDBStateDownloader.transferAllStateDataToDirectory(_							restoreStateHandle,_							temporaryRestoreInstancePath,_							stateBackend.cancelStreamRegistry)__					}__					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					columnFamilyDescriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					columnFamilyDescriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,try,rocks,dbstate,downloader,rocks,dbstate,downloader,new,rocks,dbstate,downloader,state,backend,number,of,transfering,threads,rocks,dbstate,downloader,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,column,family,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,column,family,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception;1550581511;Recovery from a single remote incremental state without rescaling.;void restoreWithoutRescaling(KeyedStateHandle rawStateHandle) throws Exception {__			IncrementalLocalKeyedStateHandle localKeyedStateHandle__			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots__			List<ColumnFamilyDescriptor> descriptors___			_			Path temporaryRestoreInstancePath = new Path(_				stateBackend.instanceBasePath.getAbsolutePath(),_				UUID.randomUUID().toString())___			try {_				if (rawStateHandle instanceof IncrementalKeyedStateHandle) {__					IncrementalKeyedStateHandle restoreStateHandle = (IncrementalKeyedStateHandle) rawStateHandle___					_					try (RocksDBStateDownloader rocksDBStateDownloader =_							new RocksDBStateDownloader(stateBackend.numberOfTransferingThreads)) {_						rocksDBStateDownloader.transferAllStateDataToDirectory(_							restoreStateHandle,_							temporaryRestoreInstancePath,_							stateBackend.cancelStreamRegistry)__					}__					stateMetaInfoSnapshots = readMetaData(restoreStateHandle.getMetaStateHandle())__					descriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)___					_					_					localKeyedStateHandle = new IncrementalLocalKeyedStateHandle(_						restoreStateHandle.getBackendIdentifier(),_						restoreStateHandle.getCheckpointId(),_						new DirectoryStateHandle(temporaryRestoreInstancePath),_						restoreStateHandle.getKeyGroupRange(),_						restoreStateHandle.getMetaStateHandle(),_						restoreStateHandle.getSharedState().keySet())__				} else if (rawStateHandle instanceof IncrementalLocalKeyedStateHandle) {__					_					localKeyedStateHandle = (IncrementalLocalKeyedStateHandle) rawStateHandle__					stateMetaInfoSnapshots = readMetaData(localKeyedStateHandle.getMetaDataState())__					descriptors = createAndRegisterColumnFamilyDescriptors(stateMetaInfoSnapshots)__				} else {_					throw new IllegalStateException("Unexpected state handle type, " +_						"expected " + IncrementalKeyedStateHandle.class + " or " + IncrementalLocalKeyedStateHandle.class +_						", but found " + rawStateHandle.getClass())__				}__				restoreLocalStateIntoFullInstance(_					localKeyedStateHandle,_					descriptors,_					stateMetaInfoSnapshots)__			} finally {_				FileSystem restoreFileSystem = temporaryRestoreInstancePath.getFileSystem()__				if (restoreFileSystem.exists(temporaryRestoreInstancePath)) {_					restoreFileSystem.delete(temporaryRestoreInstancePath, true)__				}_			}_		};recovery,from,a,single,remote,incremental,state,without,rescaling;void,restore,without,rescaling,keyed,state,handle,raw,state,handle,throws,exception,incremental,local,keyed,state,handle,local,keyed,state,handle,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,descriptors,path,temporary,restore,instance,path,new,path,state,backend,instance,base,path,get,absolute,path,uuid,random,uuid,to,string,try,if,raw,state,handle,instanceof,incremental,keyed,state,handle,incremental,keyed,state,handle,restore,state,handle,incremental,keyed,state,handle,raw,state,handle,try,rocks,dbstate,downloader,rocks,dbstate,downloader,new,rocks,dbstate,downloader,state,backend,number,of,transfering,threads,rocks,dbstate,downloader,transfer,all,state,data,to,directory,restore,state,handle,temporary,restore,instance,path,state,backend,cancel,stream,registry,state,meta,info,snapshots,read,meta,data,restore,state,handle,get,meta,state,handle,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,local,keyed,state,handle,new,incremental,local,keyed,state,handle,restore,state,handle,get,backend,identifier,restore,state,handle,get,checkpoint,id,new,directory,state,handle,temporary,restore,instance,path,restore,state,handle,get,key,group,range,restore,state,handle,get,meta,state,handle,restore,state,handle,get,shared,state,key,set,else,if,raw,state,handle,instanceof,incremental,local,keyed,state,handle,local,keyed,state,handle,incremental,local,keyed,state,handle,raw,state,handle,state,meta,info,snapshots,read,meta,data,local,keyed,state,handle,get,meta,data,state,descriptors,create,and,register,column,family,descriptors,state,meta,info,snapshots,else,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,incremental,keyed,state,handle,class,or,incremental,local,keyed,state,handle,class,but,found,raw,state,handle,get,class,restore,local,state,into,full,instance,local,keyed,state,handle,descriptors,state,meta,info,snapshots,finally,file,system,restore,file,system,temporary,restore,instance,path,get,file,system,if,restore,file,system,exists,temporary,restore,instance,path,restore,file,system,delete,temporary,restore,instance,path,true
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1531404901;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1531405434;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1531419503;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1531422929;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1531771917;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1531771917;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1533212741;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1533212741;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1533224436;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1533318024;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1533565670;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1533647766;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1533924441;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1533924476;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1534854671;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1534854671;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1534937605;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1539149054;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1539939663;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1540907751;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1540907751;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1540907751;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1540907751;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1540907751;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1544521602;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1544521602;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,state,backend,restored,kv,state,meta,infos,put,state,meta,info,snapshot,get,name,state,meta,info,snapshot,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1544521602;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1545300278;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1546862341;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1546862378;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1546867949;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1546867949;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1546956357;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1546956357;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1548411242;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors( 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots);1548440094;This method recreates and registers all {@link ColumnFamilyDescriptor} from Flink's state meta data snapshot.;private List<ColumnFamilyDescriptor> createAndRegisterColumnFamilyDescriptors(_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) {__			List<ColumnFamilyDescriptor> columnFamilyDescriptors =_				new ArrayList<>(stateMetaInfoSnapshots.size())___			for (StateMetaInfoSnapshot stateMetaInfoSnapshot : stateMetaInfoSnapshots) {__				ColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(_					stateMetaInfoSnapshot.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),_					stateBackend.columnOptions)___				columnFamilyDescriptors.add(columnFamilyDescriptor)__			}_			return columnFamilyDescriptors__		};this,method,recreates,and,registers,all,link,column,family,descriptor,from,flink,s,state,meta,data,snapshot;private,list,column,family,descriptor,create,and,register,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,list,column,family,descriptor,column,family,descriptors,new,array,list,state,meta,info,snapshots,size,for,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,column,family,descriptor,column,family,descriptor,new,column,family,descriptor,state,meta,info,snapshot,get,name,get,bytes,config,constants,state,backend,column,options,column,family,descriptors,add,column,family,descriptor,return,column,family,descriptors
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1519061869;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1519379856;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1519567828;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1519567828;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1519568061;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1519570794;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1519570794;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1519570794;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1519570795;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1520253977;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1520850256;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1520891167;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1521626215;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1522337739;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1523010728;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1523010728;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1523010728;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1524129142;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1524760045;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1524906327;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1525332388;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1525661782;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIterator iterator, int kvStateId);1526313052;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIterator iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1519061869;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1519379856;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1519567828;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1519567828;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1519568061;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1519570794;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1519570794;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1519570794;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1519570795;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1520253977;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1520850256;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1520891167;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1521626215;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1522337739;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1523010728;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1523010728;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1523010728;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1524129142;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1524760045;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1524906327;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1525332388;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1525661782;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1526313052;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1526562913;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1527071274;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1528201124;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1529325710;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1530639128;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1531145571;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1531404901;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1531405434;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1531419503;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1531422929;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1531771917;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1531771917;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1533212741;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1533212741;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1533224436;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1533318024;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1533565670;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1533647766;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1533924441;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1533924476;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1534854671;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1534854671;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1534937605;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1539149054;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1539939663;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1544521602;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1544521602;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1544521602;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1545300278;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1546862341;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1546862378;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1546867949;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1546867949;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1546956357;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1546956357;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public void doRestore(Collection<KeyedStateHandle> keyedStateHandles) 			throws IOException, StateMigrationException, RocksDBException;1548411242;Restores all key-groups data that is referenced by the passed state handles.__@param keyedStateHandles List of all key groups state handles that shall be restored.;public void doRestore(Collection<KeyedStateHandle> keyedStateHandles)_			throws IOException, StateMigrationException, RocksDBException {__			rocksDBKeyedStateBackend.createDB()___			for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_				if (keyedStateHandle != null) {__					if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {_						throw new IllegalStateException("Unexpected state handle type, " +_							"expected: " + KeyGroupsStateHandle.class +_							", but found: " + keyedStateHandle.getClass())__					}_					this.currentKeyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle__					restoreKeyGroupsInStateHandle()__				}_			}_		};restores,all,key,groups,data,that,is,referenced,by,the,passed,state,handles,param,keyed,state,handles,list,of,all,key,groups,state,handles,that,shall,be,restored;public,void,do,restore,collection,keyed,state,handle,keyed,state,handles,throws,ioexception,state,migration,exception,rocks,dbexception,rocks,dbkeyed,state,backend,create,db,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,if,keyed,state,handle,null,if,keyed,state,handle,instanceof,key,groups,state,handle,throw,new,illegal,state,exception,unexpected,state,handle,type,expected,key,groups,state,handle,class,but,found,keyed,state,handle,get,class,this,current,key,groups,state,handle,key,groups,state,handle,keyed,state,handle,restore,key,groups,in,state,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1519570794;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1519570794;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1519570794;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1519570795;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1520253977;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1520850256;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1520891167;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1521626215;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1522337739;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1523010728;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1523010728;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1523010728;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1524129142;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1524760045;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1524906327;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1525332388;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1525661782;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1526313052;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1526562913;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1527071274;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1528201124;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1529325710;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1530639128;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1531145571;Reads Flink's state meta data file from the state handle.;private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,registered,keyed,backend,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1519570794;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1519570794;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1519570794;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1519570795;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1520253977;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1520850256;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1520891167;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1521626215;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1522337739;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1523010728;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1523010728;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1523010728;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1524129142;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1524760045;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1524906327;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1525332388;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1525661782;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1526313052;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1526562913;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1527071274;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1528201124;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1529325710;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1530639128;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1531145571;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1531404901;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1531405434;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1531419503;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1531422929;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1531771917;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1531771917;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1533212741;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1533212741;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1533224436;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1533318024;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1533565670;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1533647766;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1533924441;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> @Nonnull 		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException;1533924476;4) Returns a snapshot result for the completed snapshot.__@return snapshot result for the completed snapshot.;@Nonnull_		public SnapshotResult<KeyedStateHandle> getSnapshotResultStateHandle() throws IOException {__			if (snapshotCloseableRegistry.unregisterCloseable(checkpointStreamWithResultProvider)) {__				SnapshotResult<StreamStateHandle> res =_					checkpointStreamWithResultProvider.closeAndFinalizeCheckpointStreamResult()__				checkpointStreamWithResultProvider = null__				return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(res, keyGroupRangeOffsets)__			}__			return SnapshotResult.empty()__		};4,returns,a,snapshot,result,for,the,completed,snapshot,return,snapshot,result,for,the,completed,snapshot;nonnull,public,snapshot,result,keyed,state,handle,get,snapshot,result,state,handle,throws,ioexception,if,snapshot,closeable,registry,unregister,closeable,checkpoint,stream,with,result,provider,snapshot,result,stream,state,handle,res,checkpoint,stream,with,result,provider,close,and,finalize,checkpoint,stream,result,checkpoint,stream,with,result,provider,null,return,checkpoint,stream,with,result,provider,to,keyed,state,handle,snapshot,result,res,key,group,range,offsets,return,snapshot,result,empty
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1519061869;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1519379856;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1519567828;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1519567828;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1519568061;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1519570794;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1519570794;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1519570794;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1519570795;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1520253977;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1520850256;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1520891167;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1521626215;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1522337739;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1523010728;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1523010728;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1523010728;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1524129142;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1524760045;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1524906327;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1525332388;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1525661782;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1526313052;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1526562913;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1527071274;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1528201124;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1529325710;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1530639128;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1531145571;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1531404901;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1531405434;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1531419503;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1531422929;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1531771917;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1531771917;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1533212741;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1533212741;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1533224436;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1533318024;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1533565670;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isNewKeyGroup();1533647766;Indicates if current key starts a new key-group, i.e. belong to a different key-group than it's predecessor._@return true iff the current key belong to a different key-group than it's predecessor.;public boolean isNewKeyGroup() {_			return newKeyGroup__		};indicates,if,current,key,starts,a,new,key,group,i,e,belong,to,a,different,key,group,than,it,s,predecessor,return,true,iff,the,current,key,belong,to,a,different,key,group,than,it,s,predecessor;public,boolean,is,new,key,group,return,new,key,group
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1519568061;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		if (checkpointOptions.getCheckpointType() != CheckpointType.SAVEPOINT &&_			enableIncrementalCheckpointing) {_			return snapshotIncrementally(checkpointId, timestamp, streamFactory)__		} else {_			return snapshotFully(checkpointId, timestamp, streamFactory)__		}_	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,if,checkpoint,options,get,checkpoint,type,checkpoint,type,savepoint,enable,incremental,checkpointing,return,snapshot,incrementally,checkpoint,id,timestamp,stream,factory,else,return,snapshot,fully,checkpoint,id,timestamp,stream,factory
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1519570794;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1519570794;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1519570794;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1519570795;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1520253977;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1520850256;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1520891167;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1521626215;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1522337739;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1523010728;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1523010728;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1523010728;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1524129142;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1524760045;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1524906327;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1525332388;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1525661782;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1526313052;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1526562913;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1527071274;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1528201124;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1529325710;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1530639128;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1531145571;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1531404901;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1531405434;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1531419503;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1531422929;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1531771917;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1531771917;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1533212741;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		_		writeBatchWrapper.flush()___		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,write,batch,wrapper,flush,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1533212741;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		_		writeBatchWrapper.flush()___		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,write,batch,wrapper,flush,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1533224436;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		_		writeBatchWrapper.flush()___		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,write,batch,wrapper,flush,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1533318024;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		_		writeBatchWrapper.flush()___		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,write,batch,wrapper,flush,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1533565670;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		_		writeBatchWrapper.flush()___		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,write,batch,wrapper,flush,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1533647766;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		_		writeBatchWrapper.flush()___		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,write,batch,wrapper,flush,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1533924441;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		_		writeBatchWrapper.flush()___		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,write,batch,wrapper,flush,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1533924476;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		_		writeBatchWrapper.flush()___		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,write,batch,wrapper,flush,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1534854671;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception indicating a problem in the synchronous part of the checkpoint.;@Override_	public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		_		writeBatchWrapper.flush()___		return snapshotStrategy.performSnapshot(checkpointId, timestamp, streamFactory, checkpointOptions)__	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception,indicating,a,problem,in,the,synchronous,part,of,the,checkpoint;override,public,runnable,future,snapshot,result,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,write,batch,wrapper,flush,return,snapshot,strategy,perform,snapshot,checkpoint,id,timestamp,stream,factory,checkpoint,options
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1519570794;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1519570794;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1519570794;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1519570795;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1520253977;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1520850256;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1520891167;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1521626215;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1522337739;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1523010728;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1523010728;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1523010728;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1524129142;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1524760045;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1524906327;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1525332388;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1525661782;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1526313052;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1526562913;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1527071274;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1528201124;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1529325710;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1530639128;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1531145571;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1531404901;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1531405434;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1531419503;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1531422929;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1531771917;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1531771917;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1533212741;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1533212741;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1533224436;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1533318024;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1533565670;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1533647766;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1533924441;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1533924476;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1534854671;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1534854671;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1534937605;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1539149054;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1539939663;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1540907751;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1540907751;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1540907751;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1540907751;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1540907751;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1544521602;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1544521602;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1544521602;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1545300278;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1546862341;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1546862378;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1546867949;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1546867949;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1546956357;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1546956357;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1548411242;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1548440094;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreInstanceDirectoryFromPath(Path source) throws IOException;1550581511;This recreates the new working directory of the recovered RocksDB instance and links/copies the contents from_a local state.;private void restoreInstanceDirectoryFromPath(Path source) throws IOException {__			FileSystem fileSystem = source.getFileSystem()___			final FileStatus[] fileStatuses = fileSystem.listStatus(source)___			if (fileStatuses == null) {_				throw new IOException("Cannot list file statues. Directory " + source + " does not exist.")__			}__			for (FileStatus fileStatus : fileStatuses) {_				final Path filePath = fileStatus.getPath()__				final String fileName = filePath.getName()__				File restoreFile = new File(source.getPath(), fileName)__				File targetFile = new File(stateBackend.instanceRocksDBPath.getPath(), fileName)__				if (fileName.endsWith(SST_FILE_SUFFIX)) {_					_					Files.createLink(targetFile.toPath(), restoreFile.toPath())__				} else {_					_					Files.copy(restoreFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)__				}_			}_		};this,recreates,the,new,working,directory,of,the,recovered,rocks,db,instance,and,links,copies,the,contents,from,a,local,state;private,void,restore,instance,directory,from,path,path,source,throws,ioexception,file,system,file,system,source,get,file,system,final,file,status,file,statuses,file,system,list,status,source,if,file,statuses,null,throw,new,ioexception,cannot,list,file,statues,directory,source,does,not,exist,for,file,status,file,status,file,statuses,final,path,file,path,file,status,get,path,final,string,file,name,file,path,get,name,file,restore,file,new,file,source,get,path,file,name,file,target,file,new,file,state,backend,instance,rocks,dbpath,get,path,file,name,if,file,name,ends,with,files,create,link,target,file,to,path,restore,file,to,path,else,files,copy,restore,file,to,path,target,file,to,path,standard,copy,option
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1519061869;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(outStream, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,out,stream,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1519379856;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(outStream, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,out,stream,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1519567828;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(outStream, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,out,stream,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1519567828;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(outStream, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,out,stream,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1519568061;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(outStream, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,out,stream,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1519570794;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1519570794;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1519570794;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1519570795;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1520253977;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1520850256;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1520891167;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1521626215;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1522337739;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1523010728;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1523010728;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1523010728;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1524129142;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1524760045;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1524906327;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1525332388;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1525661782;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException;1526313052;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1519570794;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1519570794;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1519570794;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1519570795;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1520253977;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1520850256;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1520891167;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1521626215;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1522337739;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1523010728;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1523010728;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1523010728;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1524129142;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1524760045;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1524906327;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1525332388;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1525661782;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1526313052;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1526562913;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1527071274;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1528201124;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1529325710;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1530639128;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1531145571;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1531404901;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1531405434;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1531419503;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1531422929;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1531771917;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1531771917;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1533212741;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1533212741;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1533224436;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1533318024;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1533565670;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1533647766;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1533924441;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1533924476;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1534854671;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1534854671;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1534937605;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1539149054;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1539939663;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1540907751;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1540907751;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1540907751;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1540907751;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1540907751;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1544521602;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1544521602;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1544521602;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1545300278;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1546862341;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1546862378;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1546867949;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1546867949;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1546956357;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1546956357;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> public File getInstanceBasePath();1548411242;Only visible for testing, DO NOT USE.;public File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;public,file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1519061869;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			IOUtils.closeQuietly(db)___			_			db = null__		}__		kvStateInformation.clear()__		restoredKvStateMetaInfos.clear()___		IOUtils.closeQuietly(dbOptions)__		IOUtils.closeQuietly(columnOptions)___		cleanInstanceBasePath()__	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,default,column,family,ioutils,close,quietly,db,db,null,kv,state,information,clear,restored,kv,state,meta,infos,clear,ioutils,close,quietly,db,options,ioutils,close,quietly,column,options,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1519379856;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			IOUtils.closeQuietly(db)___			_			db = null__		}__		kvStateInformation.clear()__		restoredKvStateMetaInfos.clear()___		IOUtils.closeQuietly(dbOptions)__		IOUtils.closeQuietly(columnOptions)___		cleanInstanceBasePath()__	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,default,column,family,ioutils,close,quietly,db,db,null,kv,state,information,clear,restored,kv,state,meta,infos,clear,ioutils,close,quietly,db,options,ioutils,close,quietly,column,options,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1519567828;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			IOUtils.closeQuietly(db)___			_			db = null__		}__		kvStateInformation.clear()__		restoredKvStateMetaInfos.clear()___		IOUtils.closeQuietly(dbOptions)__		IOUtils.closeQuietly(columnOptions)___		cleanInstanceBasePath()__	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,default,column,family,ioutils,close,quietly,db,db,null,kv,state,information,clear,restored,kv,state,meta,infos,clear,ioutils,close,quietly,db,options,ioutils,close,quietly,column,options,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1519567828;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			IOUtils.closeQuietly(db)___			_			db = null__		}__		kvStateInformation.clear()__		restoredKvStateMetaInfos.clear()___		IOUtils.closeQuietly(dbOptions)__		IOUtils.closeQuietly(columnOptions)___		cleanInstanceBasePath()__	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,default,column,family,ioutils,close,quietly,db,db,null,kv,state,information,clear,restored,kv,state,meta,infos,clear,ioutils,close,quietly,db,options,ioutils,close,quietly,column,options,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1519568061;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			IOUtils.closeQuietly(db)___			_			db = null__		}__		kvStateInformation.clear()__		restoredKvStateMetaInfos.clear()___		IOUtils.closeQuietly(dbOptions)__		IOUtils.closeQuietly(columnOptions)___		cleanInstanceBasePath()__	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,default,column,family,ioutils,close,quietly,db,db,null,kv,state,information,clear,restored,kv,state,meta,infos,clear,ioutils,close,quietly,db,options,ioutils,close,quietly,column,options,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1519570794;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			IOUtils.closeQuietly(db)___			_			db = null__		}__		kvStateInformation.clear()__		restoredKvStateMetaInfos.clear()___		IOUtils.closeQuietly(dbOptions)__		IOUtils.closeQuietly(columnOptions)___		cleanInstanceBasePath()__	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,default,column,family,ioutils,close,quietly,db,db,null,kv,state,information,clear,restored,kv,state,meta,infos,clear,ioutils,close,quietly,db,options,ioutils,close,quietly,column,options,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1519570794;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			IOUtils.closeQuietly(db)___			_			db = null__		}__		kvStateInformation.clear()__		restoredKvStateMetaInfos.clear()___		IOUtils.closeQuietly(dbOptions)__		IOUtils.closeQuietly(columnOptions)___		cleanInstanceBasePath()__	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,default,column,family,ioutils,close,quietly,db,db,null,kv,state,information,clear,restored,kv,state,meta,infos,clear,ioutils,close,quietly,db,options,ioutils,close,quietly,column,options,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1519570794;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(columnOptions)___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,kv,state,information,clear,restored,kv,state,meta,infos,clear,ioutils,close,quietly,db,options,ioutils,close,quietly,column,options,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1519570795;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1520253977;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1520850256;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1520891167;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1521626215;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1522337739;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1523010728;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1523010728;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1523010728;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1524129142;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1524760045;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1524906327;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1525332388;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1525661782;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1526313052;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1526562913;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1527071274;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1528201124;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1529325710;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1530639128;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1531145571;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			if (priorityQueueFactory instanceof AutoCloseable) {_				IOUtils.closeQuietly((AutoCloseable) priorityQueueFactory)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,if,priority,queue,factory,instanceof,auto,closeable,ioutils,close,quietly,auto,closeable,priority,queue,factory,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1531404901;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			if (priorityQueueFactory instanceof AutoCloseable) {_				IOUtils.closeQuietly((AutoCloseable) priorityQueueFactory)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,if,priority,queue,factory,instanceof,auto,closeable,ioutils,close,quietly,auto,closeable,priority,queue,factory,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1531405434;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			if (priorityQueueFactory instanceof AutoCloseable) {_				IOUtils.closeQuietly((AutoCloseable) priorityQueueFactory)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,if,priority,queue,factory,instanceof,auto,closeable,ioutils,close,quietly,auto,closeable,priority,queue,factory,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1531419503;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			if (priorityQueueFactory instanceof AutoCloseable) {_				IOUtils.closeQuietly((AutoCloseable) priorityQueueFactory)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,if,priority,queue,factory,instanceof,auto,closeable,ioutils,close,quietly,auto,closeable,priority,queue,factory,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1531422929;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			if (priorityQueueFactory instanceof AutoCloseable) {_				IOUtils.closeQuietly((AutoCloseable) priorityQueueFactory)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,if,priority,queue,factory,instanceof,auto,closeable,ioutils,close,quietly,auto,closeable,priority,queue,factory,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1531771917;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1531771917;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1533212741;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1533212741;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1533224436;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1533318024;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1533565670;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1533647766;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1533924441;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1533924476;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1534854671;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1534854671;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1534937605;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1539149054;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1539939663;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1540907751;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1540907751;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1540907751;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1540907751;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1540907751;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1544521602;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1544521602;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()__			restoredKvStateMetaInfos.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,restored,kv,state,meta,infos,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1544521602;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1545300278;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1546862341;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1546862378;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1546867949;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1546867949;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1546956357;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1546956357;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1548411242;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1548440094;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			_			_			_			_			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> columnMetaData :_				kvStateInformation.values()) {_				IOUtils.closeQuietly(columnMetaData.f0)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			IOUtils.closeQuietly(columnOptions)__			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)__			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,ioutils,close,quietly,default,column,family,for,tuple2,column,family,handle,registered,state,meta,info,base,column,meta,data,kv,state,information,values,ioutils,close,quietly,column,meta,data,f0,ioutils,close,quietly,db,db,null,ioutils,close,quietly,column,options,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1550581511;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			List<ColumnFamilyOptions> columnFamilyOptions = new ArrayList<>(kvStateInformation.values().size())___			_			_			_			_			addColumnFamilyToCloseLater(columnFamilyOptions, defaultColumnFamily)__			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (RocksDbKvStateInfo kvStateInfo : kvStateInformation.values()) {_				addColumnFamilyToCloseLater(columnFamilyOptions, kvStateInfo.columnFamilyHandle)__				IOUtils.closeQuietly(kvStateInfo.columnFamilyHandle)__			}__			_			IOUtils.closeQuietly(db)___			_			db = null___			columnFamilyOptions.forEach(IOUtils::closeQuietly)___			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)___			ttlCompactFiltersManager.disposeAndClearRegisteredCompactionFactories()___			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,list,column,family,options,column,family,options,new,array,list,kv,state,information,values,size,add,column,family,to,close,later,column,family,options,default,column,family,ioutils,close,quietly,default,column,family,for,rocks,db,kv,state,info,kv,state,info,kv,state,information,values,add,column,family,to,close,later,column,family,options,kv,state,info,column,family,handle,ioutils,close,quietly,kv,state,info,column,family,handle,ioutils,close,quietly,db,db,null,column,family,options,for,each,ioutils,close,quietly,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,ttl,compact,filters,manager,dispose,and,clear,registered,compaction,factories,kv,state,information,clear,clean,instance,base,path
RocksDBKeyedStateBackend -> @Override 	public void dispose();1550863001;Should only be called by one thread, and only after all accesses to the DB happened.;@Override_	public void dispose() {_		if (this.disposed) {_			return__		}_		super.dispose()___		_		_		rocksDBResourceGuard.close()___		_		_		if (db != null) {__			IOUtils.closeQuietly(writeBatchWrapper)___			_			_			_			if (nativeMetricMonitor != null) {_				nativeMetricMonitor.close()__			}__			List<ColumnFamilyOptions> columnFamilyOptions = new ArrayList<>(kvStateInformation.values().size())___			_			_			_			_			RocksDBOperationUtils.addColumnFamilyOptionsToCloseLater(columnFamilyOptions, defaultColumnFamily)__			IOUtils.closeQuietly(defaultColumnFamily)___			_			for (RocksDbKvStateInfo kvStateInfo : kvStateInformation.values()) {_				RocksDBOperationUtils.addColumnFamilyOptionsToCloseLater(columnFamilyOptions, kvStateInfo.columnFamilyHandle)__				IOUtils.closeQuietly(kvStateInfo.columnFamilyHandle)__			}__			_			IOUtils.closeQuietly(db)___			columnFamilyOptions.forEach(IOUtils::closeQuietly)___			IOUtils.closeQuietly(dbOptions)__			IOUtils.closeQuietly(writeOptions)___			ttlCompactFiltersManager.disposeAndClearRegisteredCompactionFactories()___			kvStateInformation.clear()___			cleanInstanceBasePath()__		}_		this.disposed = true__	};should,only,be,called,by,one,thread,and,only,after,all,accesses,to,the,db,happened;override,public,void,dispose,if,this,disposed,return,super,dispose,rocks,dbresource,guard,close,if,db,null,ioutils,close,quietly,write,batch,wrapper,if,native,metric,monitor,null,native,metric,monitor,close,list,column,family,options,column,family,options,new,array,list,kv,state,information,values,size,rocks,dboperation,utils,add,column,family,options,to,close,later,column,family,options,default,column,family,ioutils,close,quietly,default,column,family,for,rocks,db,kv,state,info,kv,state,info,kv,state,information,values,rocks,dboperation,utils,add,column,family,options,to,close,later,column,family,options,kv,state,info,column,family,handle,ioutils,close,quietly,kv,state,info,column,family,handle,ioutils,close,quietly,db,column,family,options,for,each,ioutils,close,quietly,ioutils,close,quietly,db,options,ioutils,close,quietly,write,options,ttl,compact,filters,manager,dispose,and,clear,registered,compaction,factories,kv,state,information,clear,clean,instance,base,path,this,disposed,true
RocksDBKeyedStateBackend -> File getInstanceBasePath();1548440094;Only visible for testing, DO NOT USE.;File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> File getInstanceBasePath();1550581511;Only visible for testing, DO NOT USE.;File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> File getInstanceBasePath();1550863001;Only visible for testing, DO NOT USE.;File getInstanceBasePath() {_		return instanceBasePath__	};only,visible,for,testing,do,not,use;file,get,instance,base,path,return,instance,base,path
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1531771917;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1531771917;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1533212741;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1533212741;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1533224436;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1533318024;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1533565670;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1533647766;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1533924441;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1533924476;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1534854671;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1534854671;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1534937605;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1539149054;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1539939663;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1540907751;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1540907751;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1540907751;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1540907751;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1540907751;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1544521602;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1544521602;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1544521602;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1545300278;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1546862341;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1546862378;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1546867949;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1546867949;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1546956357;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1546956357;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1548411242;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName);1548440094;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new FlinkRuntimeException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,flink,runtime,exception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1526562913;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1527071274;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1528201124;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1529325710;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1530639128;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1531145571;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1531404901;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1531405434;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1531419503;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1531422929;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1531771917;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1531771917;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1533212741;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1533212741;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1533224436;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1533318024;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1533565670;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> MergeIterator -> MergeIterator(RocksIteratorWrapper iterator, int kvStateId);1533647766;@param iterator  The #RocksIterator to wrap ._@param kvStateId Id of the K/V state to which this iterator belongs.;MergeIterator(RocksIteratorWrapper iterator, int kvStateId) {_			this.iterator = Preconditions.checkNotNull(iterator)__			this.currentKey = iterator.key()__			this.kvStateId = kvStateId__		};param,iterator,the,rocks,iterator,to,wrap,param,kv,state,id,id,of,the,k,v,state,to,which,this,iterator,belongs;merge,iterator,rocks,iterator,wrapper,iterator,int,kv,state,id,this,iterator,preconditions,check,not,null,iterator,this,current,key,iterator,key,this,kv,state,id,kv,state,id
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1548440094;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1550581511;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<KeyedStateHandle> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1519061869;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception;@Override_	public RunnableFuture<KeyedStateHandle> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		if (checkpointOptions.getCheckpointType() != CheckpointType.SAVEPOINT &&_			enableIncrementalCheckpointing) {_			return snapshotIncrementally(checkpointId, timestamp, streamFactory)__		} else {_			return snapshotFully(checkpointId, timestamp, streamFactory)__		}_	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception;override,public,runnable,future,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,if,checkpoint,options,get,checkpoint,type,checkpoint,type,savepoint,enable,incremental,checkpointing,return,snapshot,incrementally,checkpoint,id,timestamp,stream,factory,else,return,snapshot,fully,checkpoint,id,timestamp,stream,factory
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<KeyedStateHandle> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1519379856;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception;@Override_	public RunnableFuture<KeyedStateHandle> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		if (checkpointOptions.getCheckpointType() != CheckpointType.SAVEPOINT &&_			enableIncrementalCheckpointing) {_			return snapshotIncrementally(checkpointId, timestamp, streamFactory)__		} else {_			return snapshotFully(checkpointId, timestamp, streamFactory)__		}_	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception;override,public,runnable,future,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,if,checkpoint,options,get,checkpoint,type,checkpoint,type,savepoint,enable,incremental,checkpointing,return,snapshot,incrementally,checkpoint,id,timestamp,stream,factory,else,return,snapshot,fully,checkpoint,id,timestamp,stream,factory
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<KeyedStateHandle> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1519567828;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception;@Override_	public RunnableFuture<KeyedStateHandle> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		if (checkpointOptions.getCheckpointType() != CheckpointType.SAVEPOINT &&_			enableIncrementalCheckpointing) {_			return snapshotIncrementally(checkpointId, timestamp, streamFactory)__		} else {_			return snapshotFully(checkpointId, timestamp, streamFactory)__		}_	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception;override,public,runnable,future,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,if,checkpoint,options,get,checkpoint,type,checkpoint,type,savepoint,enable,incremental,checkpointing,return,snapshot,incrementally,checkpoint,id,timestamp,stream,factory,else,return,snapshot,fully,checkpoint,id,timestamp,stream,factory
RocksDBKeyedStateBackend -> @Override 	public RunnableFuture<KeyedStateHandle> snapshot( 		final long checkpointId, 		final long timestamp, 		final CheckpointStreamFactory streamFactory, 		CheckpointOptions checkpointOptions) throws Exception;1519567828;Triggers an asynchronous snapshot of the keyed state backend from RocksDB. This snapshot can be canceled and_is also stopped when the backend is closed through {@link #dispose()}. For each backend, this method must always_be called by the same thread.__@param checkpointId  The Id of the checkpoint._@param timestamp     The timestamp of the checkpoint._@param streamFactory The factory that we can use for writing our state to streams._@param checkpointOptions Options for how to perform this checkpoint._@return Future to the state handle of the snapshot data._@throws Exception;@Override_	public RunnableFuture<KeyedStateHandle> snapshot(_		final long checkpointId,_		final long timestamp,_		final CheckpointStreamFactory streamFactory,_		CheckpointOptions checkpointOptions) throws Exception {__		if (checkpointOptions.getCheckpointType() != CheckpointType.SAVEPOINT &&_			enableIncrementalCheckpointing) {_			return snapshotIncrementally(checkpointId, timestamp, streamFactory)__		} else {_			return snapshotFully(checkpointId, timestamp, streamFactory)__		}_	};triggers,an,asynchronous,snapshot,of,the,keyed,state,backend,from,rocks,db,this,snapshot,can,be,canceled,and,is,also,stopped,when,the,backend,is,closed,through,link,dispose,for,each,backend,this,method,must,always,be,called,by,the,same,thread,param,checkpoint,id,the,id,of,the,checkpoint,param,timestamp,the,timestamp,of,the,checkpoint,param,stream,factory,the,factory,that,we,can,use,for,writing,our,state,to,streams,param,checkpoint,options,options,for,how,to,perform,this,checkpoint,return,future,to,the,state,handle,of,the,snapshot,data,throws,exception;override,public,runnable,future,keyed,state,handle,snapshot,final,long,checkpoint,id,final,long,timestamp,final,checkpoint,stream,factory,stream,factory,checkpoint,options,checkpoint,options,throws,exception,if,checkpoint,options,get,checkpoint,type,checkpoint,type,savepoint,enable,incremental,checkpointing,return,snapshot,incrementally,checkpoint,id,timestamp,stream,factory,else,return,snapshot,fully,checkpoint,id,timestamp,stream,factory
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException;1531771917;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException;1531771917;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException;1533212741;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException;1533212741;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException;1533224436;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException {__		Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyValueStateBackendMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyValueStateBackendMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,tuple2,column,family,handle,registered,state,meta,info,base,state,info,kv,state,information,get,state,desc,get,name,registered,key,value,state,backend,meta,info,n,s,new,meta,info,if,state,info,null,state,meta,info,snapshot,restored,meta,info,snapshot,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,key,value,state,backend,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,key,value,state,backend,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1519061869;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1519379856;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1519567828;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1519567828;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1519568061;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1519570794;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1519570794;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1519570794;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1519570795;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1520253977;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1520850256;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1520891167;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1521626215;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1522337739;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1523010728;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1523010728;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1523010728;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1524129142;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1524760045;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1524906327;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1525332388;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1525661782;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1526313052;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1526562913;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1527071274;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1528201124;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1529325710;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1530639128;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1531145571;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1531404901;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1531405434;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1531419503;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1531422929;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1531771917;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1531771917;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1533212741;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1533212741;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1533224436;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1533318024;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1533565670;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public int keyGroup();1533647766;@return key-group for the current key;public int keyGroup() {_			int result = 0__			_			for (int i = 0_ i < keyGroupPrefixByteCount_ ++i) {_				result <<= 8__				result |= (currentSubIterator.currentKey[i] & 0xFF)__			}_			return result__		};return,key,group,for,the,current,key;public,int,key,group,int,result,0,for,int,i,0,i,key,group,prefix,byte,count,i,result,8,result,current,sub,iterator,current,key,i,0x,ff,return,result
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1531404901;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1531405434;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1531419503;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1531422929;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_					new RegisteredKeyedBackendStateMetaInfo<>(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1531771917;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1531771917;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1533212741;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1533212741;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1533224436;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1533318024;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1533565670;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1533647766;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1533924441;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1533924476;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			stateBackend.backendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, stateBackend.backendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_			synchronized (stateBackend.materializedSstFiles) {_				stateBackend.materializedSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())__			}__			stateBackend.lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,state,backend,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,state,backend,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,synchronized,state,backend,materialized,sst,files,state,backend,materialized,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,state,backend,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1534854671;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1534854671;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1534937605;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1539149054;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.kvStateInformation.put(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1539939663;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1540907751;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)___				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1540907751;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, null))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,null,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1540907751;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, null))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,null,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1540907751;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, null))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,null,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1540907751;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, null))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,null,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1544521602;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1544521602;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1544521602;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1545300278;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1546862341;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1546862378;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1546867949;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1546867949;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1546956357;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1546956357;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1548411242;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1548440094;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new Tuple2<>(columnFamilyHandle, stateMetaInfo))__			}__			_				restoredSstFiles.put(_					restoreStateHandle.getCheckpointId(),_					restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,tuple2,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreLocalStateIntoFullInstance( 			IncrementalLocalKeyedStateHandle restoreStateHandle, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception;1550581511;This method implements the core of the restore logic that unifies how local and remote state are recovered.;private void restoreLocalStateIntoFullInstance(_			IncrementalLocalKeyedStateHandle restoreStateHandle,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<StateMetaInfoSnapshot> stateMetaInfoSnapshots) throws Exception {_			_			this.restoredBackendUID = restoreStateHandle.getBackendIdentifier()___			LOG.debug("Restoring keyed backend uid in operator {} from incremental snapshot to {}.",_				stateBackend.operatorIdentifier, this.restoredBackendUID)___			_			if (!stateBackend.instanceRocksDBPath.mkdirs()) {_				throw new IOException("Could not create RocksDB data directory.")__			}__			Path restoreSourcePath = restoreStateHandle.getDirectoryStateHandle().getDirectory()__			restoreInstanceDirectoryFromPath(restoreSourcePath)___			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			stateBackend.db = stateBackend.openDB(_				stateBackend.instanceRocksDBPath.getAbsolutePath(),_				columnFamilyDescriptors, columnFamilyHandles)___			_			stateBackend.defaultColumnFamily = columnFamilyHandles.remove(0)__			stateBackend.writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db, stateBackend.writeOptions)___			for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_				StateMetaInfoSnapshot stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)___				_				_				RegisteredStateMetaInfoBase stateMetaInfo =_					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot)__				stateBackend.registerKvStateInformation(_					stateMetaInfoSnapshot.getName(),_					new RocksDbKvStateInfo(columnFamilyHandle, stateMetaInfo))__			}__			_			restoredSstFiles.put(_				restoreStateHandle.getCheckpointId(),_				restoreStateHandle.getSharedStateHandleIDs())___			lastCompletedCheckpointId = restoreStateHandle.getCheckpointId()__		};this,method,implements,the,core,of,the,restore,logic,that,unifies,how,local,and,remote,state,are,recovered;private,void,restore,local,state,into,full,instance,incremental,local,keyed,state,handle,restore,state,handle,list,column,family,descriptor,column,family,descriptors,list,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,this,restored,backend,uid,restore,state,handle,get,backend,identifier,log,debug,restoring,keyed,backend,uid,in,operator,from,incremental,snapshot,to,state,backend,operator,identifier,this,restored,backend,uid,if,state,backend,instance,rocks,dbpath,mkdirs,throw,new,ioexception,could,not,create,rocks,db,data,directory,path,restore,source,path,restore,state,handle,get,directory,state,handle,get,directory,restore,instance,directory,from,path,restore,source,path,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,state,backend,db,state,backend,open,db,state,backend,instance,rocks,dbpath,get,absolute,path,column,family,descriptors,column,family,handles,state,backend,default,column,family,column,family,handles,remove,0,state,backend,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,state,backend,write,options,for,int,i,0,i,column,family,descriptors,size,i,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,column,family,handle,column,family,handle,column,family,handles,get,i,registered,state,meta,info,base,state,meta,info,registered,state,meta,info,base,from,meta,info,snapshot,state,meta,info,snapshot,state,backend,register,kv,state,information,state,meta,info,snapshot,get,name,new,rocks,db,kv,state,info,column,family,handle,state,meta,info,restored,sst,files,put,restore,state,handle,get,checkpoint,id,restore,state,handle,get,shared,state,handle,ids,last,completed,checkpoint,id,restore,state,handle,get,checkpoint,id
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1519061869;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1519379856;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1519567828;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1519567828;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1519568061;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1519570794;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1519570794;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1519570794;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1519570795;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1520253977;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1520850256;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1520891167;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1521626215;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1522337739;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1523010728;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1523010728;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1523010728;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1524129142;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1524760045;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1524906327;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1525332388;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1525661782;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1526313052;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1526562913;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1527071274;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1528201124;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1529325710;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1530639128;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1531145571;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1531404901;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1531405434;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1531419503;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1531422929;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1531771917;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1531771917;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1533212741;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1533212741;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1533224436;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1533318024;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1533565670;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1533647766;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1533924441;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1533924476;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1534854671;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1534854671;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1534937605;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1539149054;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1539939663;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1540907751;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1540907751;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1540907751;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1540907751;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1540907751;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1544521602;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1544521602;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1544521602;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1545300278;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1546862341;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1546862378;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1546867949;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1546867949;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1546956357;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1546956357;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend);1548411242;Creates a restore operation object for the given state backend instance.__@param rocksDBKeyedStateBackend the state backend into which we restore;public RocksDBFullRestoreOperation(RocksDBKeyedStateBackend<K> rocksDBKeyedStateBackend) {_			this.rocksDBKeyedStateBackend = Preconditions.checkNotNull(rocksDBKeyedStateBackend)__		};creates,a,restore,operation,object,for,the,given,state,backend,instance,param,rocks,dbkeyed,state,backend,the,state,backend,into,which,we,restore;public,rocks,dbfull,restore,operation,rocks,dbkeyed,state,backend,k,rocks,dbkeyed,state,backend,this,rocks,dbkeyed,state,backend,preconditions,check,not,null,rocks,dbkeyed,state,backend
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1519570794;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1519570794;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1519570794;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1519570795;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1520253977;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1520850256;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1520891167;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1521626215;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1522337739;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1523010728;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1523010728;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1523010728;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1524129142;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1524760045;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1524906327;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1525332388;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1525661782;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1526313052;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1526562913;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1527071274;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1528201124;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1529325710;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1530639128;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1531145571;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1531404901;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1531405434;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1531419503;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1531422929;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1531771917;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1531771917;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1533212741;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1533212741;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1533224436;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1533318024;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1533565670;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1533647766;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1533924441;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1533924476;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1534854671;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1534854671;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1534937605;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1539149054;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}_		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1539939663;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}__		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1540907751;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}__		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1540907751;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}__		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1540907751;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}__		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1540907751;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}__		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1540907751;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}__		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1544521602;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}__		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1544521602;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}__		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void transferAllDataFromStateHandles( 			Map<StateHandleID, StreamStateHandle> stateHandleMap, 			Path restoreInstancePath) throws IOException;1544521602;Copies all the files from the given stream state handles to the given path, renaming the files w.r.t. their_{@link StateHandleID}.;private void transferAllDataFromStateHandles(_			Map<StateHandleID, StreamStateHandle> stateHandleMap,_			Path restoreInstancePath) throws IOException {__			for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {_				StateHandleID stateHandleID = entry.getKey()__				StreamStateHandle remoteFileHandle = entry.getValue()__				copyStateDataHandleData(new Path(restoreInstancePath, stateHandleID.toString()), remoteFileHandle)__			}__		};copies,all,the,files,from,the,given,stream,state,handles,to,the,given,path,renaming,the,files,w,r,t,their,link,state,handle,id;private,void,transfer,all,data,from,state,handles,map,state,handle,id,stream,state,handle,state,handle,map,path,restore,instance,path,throws,ioexception,for,map,entry,state,handle,id,stream,state,handle,entry,state,handle,map,entry,set,state,handle,id,state,handle,id,entry,get,key,stream,state,handle,remote,file,handle,entry,get,value,copy,state,data,handle,data,new,path,restore,instance,path,state,handle,id,to,string,remote,file,handle
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1519570794;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateIterators = new ArrayList<>(stateBackend.kvStateInformation.size())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,iterators,new,array,list,state,backend,kv,state,information,size,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1519570794;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateInformationCopy = new ArrayList<>(stateBackend.kvStateInformation.values())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,information,copy,new,array,list,state,backend,kv,state,information,values,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1519570794;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateInformationCopy = new ArrayList<>(stateBackend.kvStateInformation.values())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,information,copy,new,array,list,state,backend,kv,state,information,values,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1519570795;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateInformationCopy = new ArrayList<>(stateBackend.kvStateInformation.values())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,information,copy,new,array,list,state,backend,kv,state,information,values,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1520253977;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateInformationCopy = new ArrayList<>(stateBackend.kvStateInformation.values())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,information,copy,new,array,list,state,backend,kv,state,information,values,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1520850256;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateInformationCopy = new ArrayList<>(stateBackend.kvStateInformation.values())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,information,copy,new,array,list,state,backend,kv,state,information,values,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1520891167;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateInformationCopy = new ArrayList<>(stateBackend.kvStateInformation.values())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,information,copy,new,array,list,state,backend,kv,state,information,values,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1521626215;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateInformationCopy = new ArrayList<>(stateBackend.kvStateInformation.values())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,information,copy,new,array,list,state,backend,kv,state,information,values,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1522337739;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateInformationCopy = new ArrayList<>(stateBackend.kvStateInformation.values())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,information,copy,new,array,list,state,backend,kv,state,information,values,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1523010728;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")__			this.kvStateInformationCopy = new ArrayList<>(stateBackend.kvStateInformation.values())__			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,kv,state,information,copy,new,array,list,state,backend,kv,state,information,values,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1523010728;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1523010728;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1524129142;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1524760045;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1524906327;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1525332388;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1525661782;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1526313052;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1526562913;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1527071274;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1528201124;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1529325710;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1530639128;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1531145571;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1531404901;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1531405434;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1531419503;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1531422929;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1531771917;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1531771917;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1533212741;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1533212741;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1533224436;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedColumnFamilyHandles = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())___				_				this.copiedColumnFamilyHandles.add(tuple2.f0)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,column,family,handles,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,column,family,handles,add,tuple2,f0,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1533318024;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedMeta = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())__				this.copiedMeta.add(tuple2)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,meta,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,meta,add,tuple2,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1533565670;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedMeta = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())__				this.copiedMeta.add(tuple2)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,meta,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,meta,add,tuple2,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1533647766;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedMeta = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())__				this.copiedMeta.add(tuple2)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,meta,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,meta,add,tuple2,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1533924441;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedMeta = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())__				this.copiedMeta.add(tuple2)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,meta,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,meta,add,tuple2,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void takeDBSnapShot();1533924476;1) Create a snapshot object from RocksDB.;public void takeDBSnapShot() {_			Preconditions.checkArgument(snapshot == null, "Only one ongoing snapshot allowed!")___			this.stateMetaInfoSnapshots = new ArrayList<>(stateBackend.kvStateInformation.size())___			this.copiedMeta = new ArrayList<>(stateBackend.kvStateInformation.size())___			for (Tuple2<ColumnFamilyHandle, RegisteredStateMetaInfoBase> tuple2 :_				stateBackend.kvStateInformation.values()) {_				_				this.stateMetaInfoSnapshots.add(tuple2.f1.snapshot())__				this.copiedMeta.add(tuple2)__			}_			this.snapshot = stateBackend.db.getSnapshot()__		};1,create,a,snapshot,object,from,rocks,db;public,void,take,dbsnap,shot,preconditions,check,argument,snapshot,null,only,one,ongoing,snapshot,allowed,this,state,meta,info,snapshots,new,array,list,state,backend,kv,state,information,size,this,copied,meta,new,array,list,state,backend,kv,state,information,size,for,tuple2,column,family,handle,registered,state,meta,info,base,tuple2,state,backend,kv,state,information,values,this,state,meta,info,snapshots,add,tuple2,f1,snapshot,this,copied,meta,add,tuple2,this,snapshot,state,backend,db,get,snapshot
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1519061869;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(outStream == null, "Output stream for snapshot is already set.")__			outStream = checkpointStreamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE)__			snapshotCloseableRegistry.registerCloseable(outStream)__			outputView = new DataOutputViewStreamWrapper(outStream)__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,out,stream,null,output,stream,for,snapshot,is,already,set,out,stream,checkpoint,stream,factory,create,checkpoint,state,output,stream,checkpointed,state,scope,exclusive,snapshot,closeable,registry,register,closeable,out,stream,output,view,new,data,output,view,stream,wrapper,out,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1519379856;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(outStream == null, "Output stream for snapshot is already set.")__			outStream = checkpointStreamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE)__			snapshotCloseableRegistry.registerCloseable(outStream)__			outputView = new DataOutputViewStreamWrapper(outStream)__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,out,stream,null,output,stream,for,snapshot,is,already,set,out,stream,checkpoint,stream,factory,create,checkpoint,state,output,stream,checkpointed,state,scope,exclusive,snapshot,closeable,registry,register,closeable,out,stream,output,view,new,data,output,view,stream,wrapper,out,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1519567828;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(outStream == null, "Output stream for snapshot is already set.")__			outStream = checkpointStreamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE)__			snapshotCloseableRegistry.registerCloseable(outStream)__			outputView = new DataOutputViewStreamWrapper(outStream)__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,out,stream,null,output,stream,for,snapshot,is,already,set,out,stream,checkpoint,stream,factory,create,checkpoint,state,output,stream,checkpointed,state,scope,exclusive,snapshot,closeable,registry,register,closeable,out,stream,output,view,new,data,output,view,stream,wrapper,out,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1519567828;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(outStream == null, "Output stream for snapshot is already set.")__			outStream = checkpointStreamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE)__			snapshotCloseableRegistry.registerCloseable(outStream)__			outputView = new DataOutputViewStreamWrapper(outStream)__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,out,stream,null,output,stream,for,snapshot,is,already,set,out,stream,checkpoint,stream,factory,create,checkpoint,state,output,stream,checkpointed,state,scope,exclusive,snapshot,closeable,registry,register,closeable,out,stream,output,view,new,data,output,view,stream,wrapper,out,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1519568061;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(outStream == null, "Output stream for snapshot is already set.")__			outStream = checkpointStreamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE)__			snapshotCloseableRegistry.registerCloseable(outStream)__			outputView = new DataOutputViewStreamWrapper(outStream)__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,out,stream,null,output,stream,for,snapshot,is,already,set,out,stream,checkpoint,stream,factory,create,checkpoint,state,output,stream,checkpointed,state,scope,exclusive,snapshot,closeable,registry,register,closeable,out,stream,output,view,new,data,output,view,stream,wrapper,out,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1519570794;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1519570794;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1519570794;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1519570795;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1520253977;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1520850256;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1520891167;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1521626215;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1522337739;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1523010728;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1523010728;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1523010728;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1524129142;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1524760045;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1524906327;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1525332388;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1525661782;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1526313052;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1526562913;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1527071274;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1528201124;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1529325710;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1530639128;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1531145571;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1531404901;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1531405434;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1531419503;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1531422929;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1531771917;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1531771917;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1533212741;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1533212741;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1533224436;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1533318024;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1533565670;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1533647766;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1533924441;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void openCheckpointStream() throws Exception;1533924476;2) Open CheckpointStateOutputStream through the checkpointStreamFactory into which we will write.__@throws Exception;public void openCheckpointStream() throws Exception {_			Preconditions.checkArgument(checkpointStreamWithResultProvider == null,_				"Output stream for snapshot is already set.")___			checkpointStreamWithResultProvider = checkpointStreamSupplier.get()__			snapshotCloseableRegistry.registerCloseable(checkpointStreamWithResultProvider)__			outputView = new DataOutputViewStreamWrapper(_				checkpointStreamWithResultProvider.getCheckpointOutputStream())__		};2,open,checkpoint,state,output,stream,through,the,checkpoint,stream,factory,into,which,we,will,write,throws,exception;public,void,open,checkpoint,stream,throws,exception,preconditions,check,argument,checkpoint,stream,with,result,provider,null,output,stream,for,snapshot,is,already,set,checkpoint,stream,with,result,provider,checkpoint,stream,supplier,get,snapshot,closeable,registry,register,closeable,checkpoint,stream,with,result,provider,output,view,new,data,output,view,stream,wrapper,checkpoint,stream,with,result,provider,get,checkpoint,output,stream
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1519570794;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1519570794;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1519570794;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1519570795;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1520253977;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1520850256;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1520891167;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1521626215;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1522337739;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1523010728;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1523010728;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1523010728;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1524129142;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1524760045;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1524906327;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1525332388;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1525661782;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1526313052;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1526562913;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1527071274;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1528201124;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1529325710;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1530639128;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1531145571;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1531404901;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1531405434;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1531419503;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1531422929;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1531771917;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1531771917;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1533212741;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1533212741;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1533224436;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1533318024;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1533565670;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1533647766;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1533924441;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1533924476;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1534854671;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1534854671;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1534937605;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1539149054;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1539939663;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1540907751;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1540907751;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1540907751;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1540907751;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1540907751;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1544521602;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1544521602;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void copyStateDataHandleData( 			Path restoreFilePath, 			StreamStateHandle remoteFileHandle) throws IOException;1544521602;Copies the file from a single state handle to the given path.;private void copyStateDataHandleData(_			Path restoreFilePath,_			StreamStateHandle remoteFileHandle) throws IOException {__			FileSystem restoreFileSystem = restoreFilePath.getFileSystem()___			FSDataInputStream inputStream = null__			FSDataOutputStream outputStream = null___			try {_				inputStream = remoteFileHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				outputStream = restoreFileSystem.create(restoreFilePath, FileSystem.WriteMode.OVERWRITE)__				stateBackend.cancelStreamRegistry.registerCloseable(outputStream)___				byte[] buffer = new byte[8 * 1024]__				while (true) {_					int numBytes = inputStream.read(buffer)__					if (numBytes == -1) {_						break__					}__					outputStream.write(buffer, 0, numBytes)__				}_			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}__				if (stateBackend.cancelStreamRegistry.unregisterCloseable(outputStream)) {_					outputStream.close()__				}_			}_		};copies,the,file,from,a,single,state,handle,to,the,given,path;private,void,copy,state,data,handle,data,path,restore,file,path,stream,state,handle,remote,file,handle,throws,ioexception,file,system,restore,file,system,restore,file,path,get,file,system,fsdata,input,stream,input,stream,null,fsdata,output,stream,output,stream,null,try,input,stream,remote,file,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,output,stream,restore,file,system,create,restore,file,path,file,system,write,mode,overwrite,state,backend,cancel,stream,registry,register,closeable,output,stream,byte,buffer,new,byte,8,1024,while,true,int,num,bytes,input,stream,read,buffer,if,num,bytes,1,break,output,stream,write,buffer,0,num,bytes,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close,if,state,backend,cancel,stream,registry,unregister,closeable,output,stream,output,stream,close
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException;1524906327;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,throws,ioexception,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException;1525332388;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,throws,ioexception,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException;1525661782;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,throws,ioexception,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException;1526313052;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,throws,ioexception,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException;1526562913;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,throws,ioexception,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException;1527071274;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,throws,ioexception,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException;1528201124;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,throws,ioexception,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException;1529325710;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,throws,ioexception,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException;1530639128;Creates a column family handle for use with a k/v state.;private ColumnFamilyHandle createColumnFamily(String stateName) throws IOException {_		byte[] nameBytes = stateName.getBytes(ConfigConstants.DEFAULT_CHARSET)__		Preconditions.checkState(!Arrays.equals(RocksDB.DEFAULT_COLUMN_FAMILY, nameBytes),_			"The chosen state name 'default' collides with the name of the default column family!")___		ColumnFamilyDescriptor columnDescriptor = new ColumnFamilyDescriptor(nameBytes, columnOptions)___		try {_			return db.createColumnFamily(columnDescriptor)__		} catch (RocksDBException e) {_			throw new IOException("Error creating ColumnFamilyHandle.", e)__		}_	};creates,a,column,family,handle,for,use,with,a,k,v,state;private,column,family,handle,create,column,family,string,state,name,throws,ioexception,byte,name,bytes,state,name,get,bytes,config,constants,preconditions,check,state,arrays,equals,rocks,db,name,bytes,the,chosen,state,name,default,collides,with,the,name,of,the,default,column,family,column,family,descriptor,column,descriptor,new,column,family,descriptor,name,bytes,column,options,try,return,db,create,column,family,column,descriptor,catch,rocks,dbexception,e,throw,new,ioexception,error,creating,column,family,handle,e
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1531404901;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1531405434;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1531419503;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1531422929;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1531771917;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1531771917;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1533212741;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1533212741;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1533224436;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1533318024;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1533565670;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1533647766;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1533924441;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1533924476;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1534854671;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1534854671;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1534937605;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.getKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,get,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1539149054;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.restoreKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,restore,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1539939663;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (CompatibilityUtil.resolveCompatibilityResult(_					serializationProxy.restoreKeySerializer(),_					UnloadableDummyTypeSerializer.class,_					serializationProxy.getKeySerializerConfigSnapshot(),_					stateBackend.keySerializer)_					.isRequiresMigration()) {__					_					throw new StateMigrationException("The new key serializer is not compatible to read previous keys. " +_						"Aborting now since state migration is currently not available")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,compatibility,util,resolve,compatibility,result,serialization,proxy,restore,key,serializer,unloadable,dummy,type,serializer,class,serialization,proxy,get,key,serializer,config,snapshot,state,backend,key,serializer,is,requires,migration,throw,new,state,migration,exception,the,new,key,serializer,is,not,compatible,to,read,previous,keys,aborting,now,since,state,migration,is,currently,not,available,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1540907751;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader, false)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,false,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1540907751;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1540907751;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1540907751;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1540907751;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1544521602;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1544521602;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1544521602;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1545300278;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1546862341;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1546862378;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				_				_				if (!serializationProxy.getKeySerializerConfigSnapshot()_						.resolveSchemaCompatibility(stateBackend.keySerializer).isCompatibleAsIs()) {_					throw new StateMigrationException("The new key serializer must be compatible.")__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,serialization,proxy,get,key,serializer,config,snapshot,resolve,schema,compatibility,state,backend,key,serializer,is,compatible,as,is,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1546867949;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				if (!isKeySerializerCompatibilityChecked) {_					_					_					TypeSerializerSchemaCompatibility<T> keySerializerSchemaCompat =_						stateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerConfigSnapshot())__					if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_						throw new StateMigrationException("The new key serializer must be compatible.")__					}__					isKeySerializerCompatibilityChecked = true__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,t,key,serializer,schema,compat,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,config,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1546867949;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				if (!isKeySerializerCompatibilityChecked) {_					_					_					TypeSerializerSchemaCompatibility<T> keySerializerSchemaCompat =_						stateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__					if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_						throw new StateMigrationException("The new key serializer must be compatible.")__					}__					isKeySerializerCompatibilityChecked = true__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,t,key,serializer,schema,compat,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1546956357;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				if (!isKeySerializerCompatibilityChecked) {_					_					_					TypeSerializerSchemaCompatibility<T> keySerializerSchemaCompat =_						stateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__					if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_						throw new StateMigrationException("The new key serializer must be compatible.")__					}__					isKeySerializerCompatibilityChecked = true__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,t,key,serializer,schema,compat,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1546956357;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				if (!isKeySerializerCompatibilityChecked) {_					_					_					TypeSerializerSchemaCompatibility<T> keySerializerSchemaCompat =_						stateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__					if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_						throw new StateMigrationException("The new key serializer must be compatible.")__					}__					isKeySerializerCompatibilityChecked = true__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,t,key,serializer,schema,compat,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1548411242;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				if (!isKeySerializerCompatibilityChecked) {_					_					_					TypeSerializerSchemaCompatibility<T> keySerializerSchemaCompat =_						stateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__					if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_						throw new StateMigrationException("The new key serializer must be compatible.")__					}__					isKeySerializerCompatibilityChecked = true__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,t,key,serializer,schema,compat,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1548440094;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				if (!isKeySerializerCompatibilityChecked) {_					_					_					TypeSerializerSchemaCompatibility<T> keySerializerSchemaCompat =_						stateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__					if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_						throw new StateMigrationException("The new key serializer must be compatible.")__					}__					isKeySerializerCompatibilityChecked = true__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,t,key,serializer,schema,compat,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private List<StateMetaInfoSnapshot> readMetaData( 			StreamStateHandle metaStateHandle) throws Exception;1550581511;Reads Flink's state meta data file from the state handle.;private List<StateMetaInfoSnapshot> readMetaData(_			StreamStateHandle metaStateHandle) throws Exception {__			FSDataInputStream inputStream = null___			try {_				inputStream = metaStateHandle.openInputStream()__				stateBackend.cancelStreamRegistry.registerCloseable(inputStream)___				_				_				_				_				KeyedBackendSerializationProxy<T> serializationProxy =_					new KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader)__				DataInputView in = new DataInputViewStreamWrapper(inputStream)__				serializationProxy.read(in)___				if (!isKeySerializerCompatibilityChecked) {_					_					_					TypeSerializerSchemaCompatibility<T> keySerializerSchemaCompat =_						stateBackend.checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot())__					if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {_						throw new StateMigrationException("The new key serializer must be compatible.")__					}__					isKeySerializerCompatibilityChecked = true__				}__				return serializationProxy.getStateMetaInfoSnapshots()__			} finally {_				if (stateBackend.cancelStreamRegistry.unregisterCloseable(inputStream)) {_					inputStream.close()__				}_			}_		};reads,flink,s,state,meta,data,file,from,the,state,handle;private,list,state,meta,info,snapshot,read,meta,data,stream,state,handle,meta,state,handle,throws,exception,fsdata,input,stream,input,stream,null,try,input,stream,meta,state,handle,open,input,stream,state,backend,cancel,stream,registry,register,closeable,input,stream,keyed,backend,serialization,proxy,t,serialization,proxy,new,keyed,backend,serialization,proxy,state,backend,user,code,class,loader,data,input,view,in,new,data,input,view,stream,wrapper,input,stream,serialization,proxy,read,in,if,is,key,serializer,compatibility,checked,type,serializer,schema,compatibility,t,key,serializer,schema,compat,state,backend,check,key,serializer,schema,compatibility,serialization,proxy,get,key,serializer,snapshot,if,key,serializer,schema,compat,is,compatible,after,migration,key,serializer,schema,compat,is,incompatible,throw,new,state,migration,exception,the,new,key,serializer,must,be,compatible,is,key,serializer,compatibility,checked,true,return,serialization,proxy,get,state,meta,info,snapshots,finally,if,state,backend,cancel,stream,registry,unregister,closeable,input,stream,input,stream,close
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1519061869;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1519379856;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1519567828;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1519567828;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1519568061;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1519570794;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1519570794;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1519570794;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1519570795;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1520253977;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1520850256;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1520891167;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1521626215;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1522337739;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1523010728;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1523010728;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1523010728;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1524129142;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1524760045;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1524906327;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1525332388;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1525661782;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1526313052;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1526562913;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1527071274;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1528201124;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1529325710;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1530639128;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1531145571;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1531404901;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1531405434;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1531419503;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1531422929;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1531771917;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1531771917;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1533212741;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1533212741;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1533224436;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1533318024;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1533565670;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> RocksDBMergeIterator -> public boolean isValid();1533647766;Check if the iterator is still valid. Getters like {@link #key()}, {@link #value()}, etc. as well as_{@link #next()} should only be called if valid returned true. Should be checked after each call to_{@link #next()} before accessing iterator state._@return True iff this iterator is valid.;public boolean isValid() {_			return valid__		};check,if,the,iterator,is,still,valid,getters,like,link,key,link,value,etc,as,well,as,link,next,should,only,be,called,if,valid,returned,true,should,be,checked,after,each,call,to,link,next,before,accessing,iterator,state,return,true,iff,this,iterator,is,valid;public,boolean,is,valid,return,valid
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1544521602;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV, S> rocksDBState = (AbstractRocksDBState<?, ?, SV, S>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,s,rocks,dbstate,abstract,rocks,dbstate,sv,s,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1544521602;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV, S> rocksDBState = (AbstractRocksDBState<?, ?, SV, S>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,s,rocks,dbstate,abstract,rocks,dbstate,sv,s,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1545300278;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV, S> rocksDBState = (AbstractRocksDBState<?, ?, SV, S>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,s,rocks,dbstate,abstract,rocks,dbstate,sv,s,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1546862341;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1546862378;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1546867949;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1546867949;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1546956357;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1546956357;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1548411242;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1548440094;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1550581511;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> private <N, S extends State, SV> void migrateStateValues( 		StateDescriptor<S, SV> stateDesc, 		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception;1550863001;Migrate only the state value, that is the "value" that is stored in RocksDB. We don't migrate_the key here, which is made up of key group, key, namespace and map key_(in case of MapState).;private <N, S extends State, SV> void migrateStateValues(_		StateDescriptor<S, SV> stateDesc,_		Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo) throws Exception {__		if (stateDesc.getType() == StateDescriptor.Type.MAP) {_			throw new StateMigrationException("The new serializer for a MapState requires state migration in order for the job to proceed." +_				" However, migration for MapState currently isn't supported.")__		}__		LOG.info(_			"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.",_			stateDesc)___		_		_		_		StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass())__		if (stateFactory == null) {_			String message = String.format("State %s is not supported by %s",_				stateDesc.getClass(), this.getClass())__			throw new FlinkRuntimeException(message)__		}_		State state = stateFactory.createState(_			stateDesc,_			stateMetaInfo,_			RocksDBKeyedStateBackend.this)__		if (!(state instanceof AbstractRocksDBState)) {_			throw new FlinkRuntimeException(_				"State should be an AbstractRocksDBState but is " + state)__		}__		@SuppressWarnings("unchecked")_		AbstractRocksDBState<?, ?, SV> rocksDBState = (AbstractRocksDBState<?, ?, SV>) state___		Snapshot rocksDBSnapshot = db.getSnapshot()__		try (_			RocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(db, stateMetaInfo.f0)__			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())_		) {_			iterator.seekToFirst()___			DataInputDeserializer serializedValueInput = new DataInputDeserializer()__			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512)__			while (iterator.isValid()) {_				serializedValueInput.setBuffer(iterator.value())___				rocksDBState.migrateSerializedValue(_					serializedValueInput,_					migratedSerializedValueOutput,_					stateMetaInfo.f1.getPreviousStateSerializer(),_					stateMetaInfo.f1.getStateSerializer())___				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer())___				migratedSerializedValueOutput.clear()__				iterator.next()__			}_		} finally {_			db.releaseSnapshot(rocksDBSnapshot)__			rocksDBSnapshot.close()__		}_	};migrate,only,the,state,value,that,is,the,value,that,is,stored,in,rocks,db,we,don,t,migrate,the,key,here,which,is,made,up,of,key,group,key,namespace,and,map,key,in,case,of,map,state;private,n,s,extends,state,sv,void,migrate,state,values,state,descriptor,s,sv,state,desc,tuple2,column,family,handle,registered,key,value,state,backend,meta,info,n,sv,state,meta,info,throws,exception,if,state,desc,get,type,state,descriptor,type,map,throw,new,state,migration,exception,the,new,serializer,for,a,map,state,requires,state,migration,in,order,for,the,job,to,proceed,however,migration,for,map,state,currently,isn,t,supported,log,info,performing,state,migration,for,state,because,the,state,serializer,s,schema,i,e,serialization,format,has,changed,state,desc,state,factory,state,factory,get,state,desc,get,class,if,state,factory,null,string,message,string,format,state,s,is,not,supported,by,s,state,desc,get,class,this,get,class,throw,new,flink,runtime,exception,message,state,state,state,factory,create,state,state,desc,state,meta,info,rocks,dbkeyed,state,backend,this,if,state,instanceof,abstract,rocks,dbstate,throw,new,flink,runtime,exception,state,should,be,an,abstract,rocks,dbstate,but,is,state,suppress,warnings,unchecked,abstract,rocks,dbstate,sv,rocks,dbstate,abstract,rocks,dbstate,sv,state,snapshot,rocks,dbsnapshot,db,get,snapshot,try,rocks,iterator,wrapper,iterator,rocks,dboperation,utils,get,rocks,iterator,db,state,meta,info,f0,rocks,dbwrite,batch,wrapper,batch,writer,new,rocks,dbwrite,batch,wrapper,db,get,write,options,iterator,seek,to,first,data,input,deserializer,serialized,value,input,new,data,input,deserializer,data,output,serializer,migrated,serialized,value,output,new,data,output,serializer,512,while,iterator,is,valid,serialized,value,input,set,buffer,iterator,value,rocks,dbstate,migrate,serialized,value,serialized,value,input,migrated,serialized,value,output,state,meta,info,f1,get,previous,state,serializer,state,meta,info,f1,get,state,serializer,batch,writer,put,state,meta,info,f0,iterator,key,migrated,serialized,value,output,get,copy,of,buffer,migrated,serialized,value,output,clear,iterator,next,finally,db,release,snapshot,rocks,dbsnapshot,rocks,dbsnapshot,close
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1519570794;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				try {_					_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {_					_					for (ColumnFamilyHandle columnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(columnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,for,column,family,handle,column,family,handle,column,family,handles,ioutils,close,quietly,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1519570794;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				try {_					_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {_					_					for (ColumnFamilyHandle columnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(columnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,for,column,family,handle,column,family,handle,column,family,handles,ioutils,close,quietly,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1519570794;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1519570795;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1520253977;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										stateBackend.writeOptions,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,state,backend,write,options,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1520850256;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1520891167;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1521626215;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1522337739;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1523010728;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1523010728;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1523010728;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1524129142;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1524760045;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1524906327;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1525332388;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1525661782;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1526313052;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIterator iterator = restoreDb.newIterator(columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,iterator,restore,db,new,iterator,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1526562913;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIteratorWrapper iterator = getRocksIterator(restoreDb, columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									stateBackend.db.put(targetColumnFamilyHandle,_										iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,restore,db,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,state,backend,db,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBIncrementalRestoreOperation -> private void restoreKeyGroupsShardWithTemporaryHelperInstance( 			Path restoreInstancePath, 			List<ColumnFamilyDescriptor> columnFamilyDescriptors, 			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception;1527071274;In case of rescaling, this method creates a temporary RocksDB instance for a key-groups shard. All contents_from the temporary instance are copied into the real restore instance and then the temporary instance is_discarded.;private void restoreKeyGroupsShardWithTemporaryHelperInstance(_			Path restoreInstancePath,_			List<ColumnFamilyDescriptor> columnFamilyDescriptors,_			List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> stateMetaInfoSnapshots) throws Exception {__			List<ColumnFamilyHandle> columnFamilyHandles =_				new ArrayList<>(1 + columnFamilyDescriptors.size())___			try (RocksDB restoreDb = stateBackend.openDB(_				restoreInstancePath.getPath(),_				columnFamilyDescriptors,_				columnFamilyHandles)__				RocksDBWriteBatchWrapper writeBatchWrapper = new RocksDBWriteBatchWrapper(stateBackend.db)) {__				final ColumnFamilyHandle defaultColumnFamily = columnFamilyHandles.remove(0)___				Preconditions.checkState(columnFamilyHandles.size() == columnFamilyDescriptors.size())___				try {_					for (int i = 0_ i < columnFamilyDescriptors.size()_ ++i) {_						ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get(i)__						ColumnFamilyDescriptor columnFamilyDescriptor = columnFamilyDescriptors.get(i)__						RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> stateMetaInfoSnapshot = stateMetaInfoSnapshots.get(i)___						Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredStateMetaInfoEntry =_							stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName())___						if (null == registeredStateMetaInfoEntry) {__							RegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =_								new RegisteredKeyedBackendStateMetaInfo<>(_									stateMetaInfoSnapshot.getStateType(),_									stateMetaInfoSnapshot.getName(),_									stateMetaInfoSnapshot.getNamespaceSerializer(),_									stateMetaInfoSnapshot.getStateSerializer())___							registeredStateMetaInfoEntry =_								new Tuple2<>(_									stateBackend.db.createColumnFamily(columnFamilyDescriptor),_									stateMetaInfo)___							stateBackend.kvStateInformation.put(_								stateMetaInfoSnapshot.getName(),_								registeredStateMetaInfoEntry)__						}__						ColumnFamilyHandle targetColumnFamilyHandle = registeredStateMetaInfoEntry.f0___						try (RocksIteratorWrapper iterator = getRocksIterator(restoreDb, columnFamilyHandle)) {__							int startKeyGroup = stateBackend.getKeyGroupRange().getStartKeyGroup()__							byte[] startKeyGroupPrefixBytes = new byte[stateBackend.keyGroupPrefixBytes]__							for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_								startKeyGroupPrefixBytes[j] = (byte) (startKeyGroup >>> ((stateBackend.keyGroupPrefixBytes - j - 1) * Byte.SIZE))__							}__							iterator.seek(startKeyGroupPrefixBytes)___							while (iterator.isValid()) {__								int keyGroup = 0__								for (int j = 0_ j < stateBackend.keyGroupPrefixBytes_ ++j) {_									keyGroup = (keyGroup << Byte.SIZE) + iterator.key()[j]__								}__								if (stateBackend.keyGroupRange.contains(keyGroup)) {_									writeBatchWrapper.put(targetColumnFamilyHandle, iterator.key(), iterator.value())__								}__								iterator.next()__							}_						} _					}_				} finally {__					_					IOUtils.closeQuietly(defaultColumnFamily)___					for (ColumnFamilyHandle flinkColumnFamilyHandle : columnFamilyHandles) {_						IOUtils.closeQuietly(flinkColumnFamilyHandle)__					}_				}_			} _		};in,case,of,rescaling,this,method,creates,a,temporary,rocks,db,instance,for,a,key,groups,shard,all,contents,from,the,temporary,instance,are,copied,into,the,real,restore,instance,and,then,the,temporary,instance,is,discarded;private,void,restore,key,groups,shard,with,temporary,helper,instance,path,restore,instance,path,list,column,family,descriptor,column,family,descriptors,list,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshots,throws,exception,list,column,family,handle,column,family,handles,new,array,list,1,column,family,descriptors,size,try,rocks,db,restore,db,state,backend,open,db,restore,instance,path,get,path,column,family,descriptors,column,family,handles,rocks,dbwrite,batch,wrapper,write,batch,wrapper,new,rocks,dbwrite,batch,wrapper,state,backend,db,final,column,family,handle,default,column,family,column,family,handles,remove,0,preconditions,check,state,column,family,handles,size,column,family,descriptors,size,try,for,int,i,0,i,column,family,descriptors,size,i,column,family,handle,column,family,handle,column,family,handles,get,i,column,family,descriptor,column,family,descriptor,column,family,descriptors,get,i,registered,keyed,backend,state,meta,info,snapshot,state,meta,info,snapshot,state,meta,info,snapshots,get,i,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,registered,state,meta,info,entry,state,backend,kv,state,information,get,state,meta,info,snapshot,get,name,if,null,registered,state,meta,info,entry,registered,keyed,backend,state,meta,info,state,meta,info,new,registered,keyed,backend,state,meta,info,state,meta,info,snapshot,get,state,type,state,meta,info,snapshot,get,name,state,meta,info,snapshot,get,namespace,serializer,state,meta,info,snapshot,get,state,serializer,registered,state,meta,info,entry,new,tuple2,state,backend,db,create,column,family,column,family,descriptor,state,meta,info,state,backend,kv,state,information,put,state,meta,info,snapshot,get,name,registered,state,meta,info,entry,column,family,handle,target,column,family,handle,registered,state,meta,info,entry,f0,try,rocks,iterator,wrapper,iterator,get,rocks,iterator,restore,db,column,family,handle,int,start,key,group,state,backend,get,key,group,range,get,start,key,group,byte,start,key,group,prefix,bytes,new,byte,state,backend,key,group,prefix,bytes,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,start,key,group,prefix,bytes,j,byte,start,key,group,state,backend,key,group,prefix,bytes,j,1,byte,size,iterator,seek,start,key,group,prefix,bytes,while,iterator,is,valid,int,key,group,0,for,int,j,0,j,state,backend,key,group,prefix,bytes,j,key,group,key,group,byte,size,iterator,key,j,if,state,backend,key,group,range,contains,key,group,write,batch,wrapper,put,target,column,family,handle,iterator,key,iterator,value,iterator,next,finally,ioutils,close,quietly,default,column,family,for,column,family,handle,flink,column,family,handle,column,family,handles,ioutils,close,quietly,flink,column,family,handle
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1519061869;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (currentStateHandleInStream != null_					&& rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,current,state,handle,in,stream,null,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1519379856;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (currentStateHandleInStream != null_					&& rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,current,state,handle,in,stream,null,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1519567828;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1519567828;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1519568061;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1519570794;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1519570794;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1519570794;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1519570795;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1520253977;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1520850256;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1520891167;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1521626215;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1522337739;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1523010728;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1523010728;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1523010728;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1524129142;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1524760045;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1524906327;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1525332388;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1525661782;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1526313052;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1526562913;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1527071274;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1528201124;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1529325710;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1530639128;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1531145571;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1531404901;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1531405434;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1531419503;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1531422929;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1531771917;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1531771917;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1533212741;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1533212741;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1533224436;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1533318024;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1533565670;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1533647766;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1533924441;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1533924476;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1534854671;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1534854671;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1534937605;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1539149054;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1539939663;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1540907751;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1544521602;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1544521602;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1544521602;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1545300278;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1546862341;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1546862378;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1546867949;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1546867949;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1546956357;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1546956357;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1548411242;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1548440094;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> RocksDBFullRestoreOperation -> private void restoreKeyGroupsInStateHandle() 			throws IOException, StateMigrationException, RocksDBException;1550581511;Restore one key groups state handle.;private void restoreKeyGroupsInStateHandle()_			throws IOException, StateMigrationException, RocksDBException {_			try {_				currentStateHandleInStream = currentKeyGroupsStateHandle.openInputStream()__				rocksDBKeyedStateBackend.cancelStreamRegistry.registerCloseable(currentStateHandleInStream)__				currentStateHandleInView = new DataInputViewStreamWrapper(currentStateHandleInStream)__				restoreKVStateMetaData()__				restoreKVStateData()__			} finally {_				if (rocksDBKeyedStateBackend.cancelStreamRegistry.unregisterCloseable(currentStateHandleInStream)) {_					IOUtils.closeQuietly(currentStateHandleInStream)__				}_			}_		};restore,one,key,groups,state,handle;private,void,restore,key,groups,in,state,handle,throws,ioexception,state,migration,exception,rocks,dbexception,try,current,state,handle,in,stream,current,key,groups,state,handle,open,input,stream,rocks,dbkeyed,state,backend,cancel,stream,registry,register,closeable,current,state,handle,in,stream,current,state,handle,in,view,new,data,input,view,stream,wrapper,current,state,handle,in,stream,restore,kvstate,meta,data,restore,kvstate,data,finally,if,rocks,dbkeyed,state,backend,cancel,stream,registry,unregister,closeable,current,state,handle,in,stream,ioutils,close,quietly,current,state,handle,in,stream
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1524906327;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1525332388;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1525661782;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1526313052;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1526562913;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1527071274;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1528201124;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1529325710;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1530639128;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation( 			StateDescriptor<?, S> stateDesc, 			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException;1531145571;Registers a k/v state information, which includes its state id, type, RocksDB column family handle, and serializers.__<p>When restoring from a snapshot, we dont restore the individual k/v states, just the global RocksDB database and_the list of k/v state information. When a k/v state is first requested we check here whether we_already have a registered entry for that and return it (after some necessary state compatibility checks)_or create a new one if it does not exist.;private <N, S> Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<N, S>> tryRegisterKvStateInformation(_			StateDescriptor<?, S> stateDesc,_			TypeSerializer<N> namespaceSerializer) throws StateMigrationException, IOException {__		Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> stateInfo =_			kvStateInformation.get(stateDesc.getName())___		RegisteredKeyedBackendStateMetaInfo<N, S> newMetaInfo__		if (stateInfo != null) {__			@SuppressWarnings("unchecked")_			RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S> restoredMetaInfoSnapshot =_				(RegisteredKeyedBackendStateMetaInfo.Snapshot<N, S>) restoredKvStateMetaInfos.get(stateDesc.getName())___			Preconditions.checkState(_				restoredMetaInfoSnapshot != null,_				"Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo," +_					" but its corresponding restored snapshot cannot be found.")___			newMetaInfo = RegisteredKeyedBackendStateMetaInfo.resolveKvStateCompatibility(_				restoredMetaInfoSnapshot,_				namespaceSerializer,_				stateDesc)___			stateInfo.f1 = newMetaInfo__		} else {_			String stateName = stateDesc.getName()___			newMetaInfo = new RegisteredKeyedBackendStateMetaInfo<>(_				stateDesc.getType(),_				stateName,_				namespaceSerializer,_				stateDesc.getSerializer())___			ColumnFamilyHandle columnFamily = createColumnFamily(stateName, db)___			stateInfo = Tuple2.of(columnFamily, newMetaInfo)__			kvStateInformation.put(stateDesc.getName(), stateInfo)__		}__		return Tuple2.of(stateInfo.f0, newMetaInfo)__	};registers,a,k,v,state,information,which,includes,its,state,id,type,rocks,db,column,family,handle,and,serializers,p,when,restoring,from,a,snapshot,we,don,t,restore,the,individual,k,v,states,just,the,global,rocks,db,database,and,the,list,of,k,v,state,information,when,a,k,v,state,is,first,requested,we,check,here,whether,we,already,have,a,registered,entry,for,that,and,return,it,after,some,necessary,state,compatibility,checks,or,create,a,new,one,if,it,does,not,exist;private,n,s,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,n,s,try,register,kv,state,information,state,descriptor,s,state,desc,type,serializer,n,namespace,serializer,throws,state,migration,exception,ioexception,tuple2,column,family,handle,registered,keyed,backend,state,meta,info,state,info,kv,state,information,get,state,desc,get,name,registered,keyed,backend,state,meta,info,n,s,new,meta,info,if,state,info,null,suppress,warnings,unchecked,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,meta,info,snapshot,registered,keyed,backend,state,meta,info,snapshot,n,s,restored,kv,state,meta,infos,get,state,desc,get,name,preconditions,check,state,restored,meta,info,snapshot,null,requested,to,check,compatibility,of,a,restored,registered,keyed,backend,state,meta,info,but,its,corresponding,restored,snapshot,cannot,be,found,new,meta,info,registered,keyed,backend,state,meta,info,resolve,kv,state,compatibility,restored,meta,info,snapshot,namespace,serializer,state,desc,state,info,f1,new,meta,info,else,string,state,name,state,desc,get,name,new,meta,info,new,registered,keyed,backend,state,meta,info,state,desc,get,type,state,name,namespace,serializer,state,desc,get,serializer,column,family,handle,column,family,create,column,family,state,name,db,state,info,tuple2,of,column,family,new,meta,info,kv,state,information,put,state,desc,get,name,state,info,return,tuple2,of,state,info,f0,new,meta,info
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1526562913;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1527071274;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1528201124;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1529325710;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1530639128;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1531145571;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1531404901;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1531405434;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1531419503;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1531422929;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1531771917;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1531771917;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1533212741;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1533212741;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1533224436;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1533318024;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1533565670;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1533647766;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1533924441;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
RocksDBKeyedStateBackend -> RocksDBFullSnapshotOperation -> public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException;1533924476;3) Write the actual data from RocksDB from the time we took the snapshot object in (1).__@throws IOException;public void writeDBSnapshot() throws IOException, InterruptedException, RocksDBException {__			if (null == snapshot) {_				throw new IOException("No snapshot available. Might be released due to cancellation.")__			}__			Preconditions.checkNotNull(checkpointStreamWithResultProvider, "No output stream to write snapshot.")__			writeKVStateMetaData()__			writeKVStateData()__		};3,write,the,actual,data,from,rocks,db,from,the,time,we,took,the,snapshot,object,in,1,throws,ioexception;public,void,write,dbsnapshot,throws,ioexception,interrupted,exception,rocks,dbexception,if,null,snapshot,throw,new,ioexception,no,snapshot,available,might,be,released,due,to,cancellation,preconditions,check,not,null,checkpoint,stream,with,result,provider,no,output,stream,to,write,snapshot,write,kvstate,meta,data,write,kvstate,data
