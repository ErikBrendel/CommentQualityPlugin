commented;modifiers;parameterAmount;loc;comment;code
false;public;3;17;;public void setAndRegisterCompactFilterIfStateTtl(TtlTimeProvider ttlTimeProvider, @Nonnull StateMetaInfoSnapshot stateMetaInfoSnapshot, @Nonnull ColumnFamilyOptions options) {     boolean keyValueState = stateMetaInfoSnapshot.getBackendStateType() == StateMetaInfoSnapshot.BackendStateType.KEY_VALUE.     if (enableTtlCompactionFilter && keyValueState) {         @SuppressWarnings("unchecked")         TypeSerializerSnapshot<?> stateSerializerSnapshot = Preconditions.checkNotNull((TypeSerializerSnapshot<?>) stateMetaInfoSnapshot.getTypeSerializerSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER)).         TypeSerializer<?> serializer = stateSerializerSnapshot.restoreSerializer().         if (TtlStateFactory.TtlSerializer.isTtlStateSerializer(serializer)) {             createAndSetCompactFilterFactory(stateMetaInfoSnapshot.getName(), ttlTimeProvider, options).         }     } }
false;public;3;12;;public void setAndRegisterCompactFilterIfStateTtl(TtlTimeProvider ttlTimeProvider, @Nonnull RegisteredStateMetaInfoBase metaInfoBase, @Nonnull ColumnFamilyOptions options) {     if (enableTtlCompactionFilter && metaInfoBase instanceof RegisteredKeyValueStateBackendMetaInfo) {         RegisteredKeyValueStateBackendMetaInfo kvMetaInfoBase = (RegisteredKeyValueStateBackendMetaInfo) metaInfoBase.         if (TtlStateFactory.TtlSerializer.isTtlStateSerializer(kvMetaInfoBase.getStateSerializer())) {             createAndSetCompactFilterFactory(metaInfoBase.getName(), ttlTimeProvider, options).         }     } }
false;private;3;9;;private void createAndSetCompactFilterFactory(String stateName, TtlTimeProvider ttlTimeProvider, @Nonnull ColumnFamilyOptions options) {     FlinkCompactionFilterFactory compactionFilterFactory = new FlinkCompactionFilterFactory(new TimeProviderWrapper(ttlTimeProvider), createRocksDbNativeLogger()).     // noinspection resource     options.setCompactionFilterFactory(compactionFilterFactory).     compactionFilterFactories.put(stateName, compactionFilterFactory). }
false;protected;2;4;;@Override protected void log(InfoLogLevel infoLogLevel, String logMsg) {     LOG.debug("RocksDB filter native code log: " + logMsg). }
false;private,static;0;16;;private static org.rocksdb.Logger createRocksDbNativeLogger() {     if (LOG.isDebugEnabled()) {         // the logger level gets configured from the options in native code         try (DBOptions opts = new DBOptions().setInfoLogLevel(InfoLogLevel.DEBUG_LEVEL)) {             return new org.rocksdb.Logger(opts) {                  @Override                 protected void log(InfoLogLevel infoLogLevel, String logMsg) {                     LOG.debug("RocksDB filter native code log: " + logMsg).                 }             }.         }     } else {         return null.     } }
false;public;2;40;;public void configCompactFilter(@Nonnull StateDescriptor<?, ?> stateDesc, TypeSerializer<?> stateSerializer) {     StateTtlConfig ttlConfig = stateDesc.getTtlConfig().     if (ttlConfig.isEnabled() && ttlConfig.getCleanupStrategies().inRocksdbCompactFilter()) {         if (!enableTtlCompactionFilter) {             LOG.warn("Cannot configure RocksDB TTL compaction filter for state <{}>: " + "feature is disabled for the state backend.", stateDesc.getName()).             return.         }         FlinkCompactionFilterFactory compactionFilterFactory = compactionFilterFactories.get(stateDesc.getName()).         Preconditions.checkNotNull(compactionFilterFactory).         long ttl = ttlConfig.getTtl().toMilliseconds().         StateTtlConfig.RocksdbCompactFilterCleanupStrategy rocksdbCompactFilterCleanupStrategy = ttlConfig.getCleanupStrategies().getRocksdbCompactFilterCleanupStrategy().         Preconditions.checkNotNull(rocksdbCompactFilterCleanupStrategy).         long queryTimeAfterNumEntries = rocksdbCompactFilterCleanupStrategy.getQueryTimeAfterNumEntries().         FlinkCompactionFilter.Config config.         if (stateDesc instanceof ListStateDescriptor) {             TypeSerializer<?> elemSerializer = ((ListSerializer<?>) stateSerializer).getElementSerializer().             int len = elemSerializer.getLength().             if (len > 0) {                 config = FlinkCompactionFilter.Config.createForFixedElementList(ttl, queryTimeAfterNumEntries, // plus one byte for list element delimiter                 len + 1).             } else {                 config = FlinkCompactionFilter.Config.createForList(ttl, queryTimeAfterNumEntries, new ListElementFilterFactory<>(elemSerializer.duplicate())).             }         } else if (stateDesc instanceof MapStateDescriptor) {             config = FlinkCompactionFilter.Config.createForMap(ttl, queryTimeAfterNumEntries).         } else {             config = FlinkCompactionFilter.Config.createForValue(ttl, queryTimeAfterNumEntries).         }         compactionFilterFactory.configure(config).     } }
false;public;0;4;;@Override public FlinkCompactionFilter.ListElementFilter createListElementFilter() {     return new ListElementFilter<>(serializer). }
false;public;0;4;;@Override public long currentTimestamp() {     return ttlTimeProvider.currentTimestamp(). }
false;public;3;17;;@Override public int nextUnexpiredOffset(byte[] bytes, long ttl, long currentTimestamp) {     input.setBuffer(bytes).     int lastElementOffset = 0.     while (input.available() > 0) {         try {             long timestamp = nextElementLastAccessTimestamp().             if (!TtlUtils.expired(timestamp, ttl, currentTimestamp)) {                 break.             }             lastElementOffset = input.getPosition().         } catch (IOException e) {             throw new FlinkRuntimeException("Failed to deserialize list element for TTL compaction filter", e).         }     }     return lastElementOffset. }
false;private;0;7;;private long nextElementLastAccessTimestamp() throws IOException {     TtlValue<?> ttlValue = (TtlValue<?>) serializer.deserialize(input).     if (input.available() > 0) {         input.skipBytesToRead(1).     }     return ttlValue.getLastAccessTimestamp(). }
false;public;0;6;;public void disposeAndClearRegisteredCompactionFactories() {     for (FlinkCompactionFilterFactory factory : compactionFilterFactories.values()) {         IOUtils.closeQuietly(factory).     }     compactionFilterFactories.clear(). }
