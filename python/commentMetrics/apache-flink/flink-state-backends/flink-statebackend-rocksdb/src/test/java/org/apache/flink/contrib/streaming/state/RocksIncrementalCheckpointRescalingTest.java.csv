commented;modifiers;parameterAmount;loc;comment;code
false;public;0;33;;@Before public void initRecords() throws Exception {     records = new String[10].     records[0] = "8".     // group 0     Assert.assertEquals(0, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[0]), maxParallelism)).     records[1] = "5".     // group 1     Assert.assertEquals(1, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[1]), maxParallelism)).     records[2] = "25".     // group 2     Assert.assertEquals(2, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[2]), maxParallelism)).     records[3] = "13".     // group 3     Assert.assertEquals(3, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[3]), maxParallelism)).     records[4] = "4".     // group 4     Assert.assertEquals(4, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[4]), maxParallelism)).     records[5] = "7".     // group 5     Assert.assertEquals(5, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[5]), maxParallelism)).     records[6] = "1".     // group 6     Assert.assertEquals(6, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[6]), maxParallelism)).     records[7] = "6".     // group 7     Assert.assertEquals(7, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[7]), maxParallelism)).     records[8] = "9".     // group 8     Assert.assertEquals(8, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[8]), maxParallelism)).     records[9] = "3".     // group 9     Assert.assertEquals(9, KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[9]), maxParallelism)). }
false;public;0;134;;@Test @SuppressWarnings("unchecked") public void testScalingUp() throws Exception {     // -----------------------------------------> test with initial parallelism 1 <---------------------------------------     OperatorSubtaskState snapshot.     try (KeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness = getHarnessTest(keySelector, maxParallelism, 1, 0)) {         harness.setStateBackend(getStateBackend()).         harness.open().         validHarnessResult(harness, 1, records).         snapshot = harness.snapshot(0, 0).     }     // -----------------------------------------> test rescaling from 1 to 2 <---------------------------------------     // init state for new subtask-0     OperatorSubtaskState initState1 = AbstractStreamOperatorTestHarness.repartitionOperatorState(snapshot, maxParallelism, 1, 2, 0).     // init state for new subtask-1     OperatorSubtaskState initState2 = AbstractStreamOperatorTestHarness.repartitionOperatorState(snapshot, maxParallelism, 1, 2, 1).     KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 = new KeyedOneInputStreamOperatorTestHarness[3].     OperatorSubtaskState snapshot2.     try {         List<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 2).         // task's key-group [0, 4]         KeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0).         Assert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20).         harness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0).         harness2[0].setStateBackend(getStateBackend()).         harness2[0].setup().         harness2[0].initializeState(initState1).         harness2[0].open().         // task's key-group [5, 9]         KeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1).         Assert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21).         harness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1).         harness2[1].setStateBackend(getStateBackend()).         harness2[1].setup().         harness2[1].initializeState(initState2).         harness2[1].open().         validHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]).         validHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]).         snapshot2 = AbstractStreamOperatorTestHarness.repackageState(harness2[0].snapshot(0, 0), harness2[1].snapshot(0, 0)).         validHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]).         validHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]).     } finally {         closeHarness(harness2).     }     // -----------------------------------------> test rescaling from 2 to 3 <---------------------------------------     // init state for new subtask-0     initState1 = AbstractStreamOperatorTestHarness.repartitionOperatorState(snapshot2, maxParallelism, 2, 3, 0).     // init state for new subtask-1     initState2 = AbstractStreamOperatorTestHarness.repartitionOperatorState(snapshot2, maxParallelism, 2, 3, 1).     // init state for new subtask-2     OperatorSubtaskState initState3 = AbstractStreamOperatorTestHarness.repartitionOperatorState(snapshot2, maxParallelism, 2, 3, 2).     KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 = new KeyedOneInputStreamOperatorTestHarness[3].     try {         List<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 3).         // task's key-group [0, 3]         // this will choose the state handle to harness2[0] to init the target db with clipping.         KeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0).         Assert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30).         harness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0).         harness3[0].setStateBackend(getStateBackend()).         harness3[0].setup().         harness3[0].initializeState(initState1).         harness3[0].open().         // task's key-group [4, 6]         KeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1).         Assert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31).         harness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1).         harness3[1].setStateBackend(getStateBackend()).         harness3[1].setup().         harness3[1].initializeState(initState2).         harness3[1].open().         // task's key-group [7, 9]         KeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2).         Assert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32).         harness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2).         harness3[2].setStateBackend(getStateBackend()).         harness3[2].setup().         harness3[2].initializeState(initState3).         harness3[2].open().         validHarnessResult(harness3[0], 3, records[0], records[1], records[2], records[3]).         validHarnessResult(harness3[1], 3, records[4], records[5], records[6]).         validHarnessResult(harness3[2], 3, records[7], records[8], records[9]).         validHarnessResult(harness3[0], 1, records[4], records[5], records[6], records[7], records[8], records[9]).         validHarnessResult(harness3[1], 1, records[0], records[1], records[2], records[3], records[7], records[8], records[9]).         validHarnessResult(harness3[2], 1, records[0], records[1], records[2], records[3], records[4], records[5], records[6]).     } finally {         closeHarness(harness3).     } }
false;public;0;123;;@Test @SuppressWarnings("unchecked") public void testScalingDown() throws Exception {     // -----------------------------------------> test with initial parallelism 3 <---------------------------------------     KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 = new KeyedOneInputStreamOperatorTestHarness[3].     OperatorSubtaskState snapshot3.     try {         List<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 3).         // task's key-group [0, 3], this should trigger the condition to use clip         KeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0).         Assert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30).         harness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0).         harness3[0].setStateBackend(getStateBackend()).         harness3[0].open().         // task's key-group [4, 6]         KeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1).         Assert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31).         harness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1).         harness3[1].setStateBackend(getStateBackend()).         harness3[1].open().         // task's key-group [7, 9]         KeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2).         Assert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32).         harness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2).         harness3[2].setStateBackend(getStateBackend()).         harness3[2].open().         validHarnessResult(harness3[0], 1, records[0], records[1], records[2], records[3]).         validHarnessResult(harness3[1], 1, records[4], records[5], records[6]).         validHarnessResult(harness3[2], 1, records[7], records[8], records[9]).         snapshot3 = AbstractStreamOperatorTestHarness.repackageState(harness3[0].snapshot(0, 0), harness3[1].snapshot(0, 0), harness3[2].snapshot(0, 0)).     } finally {         closeHarness(harness3).     }     // -----------------------------------------> test rescaling from 3 to 2 <---------------------------------------     // init state for new subtask-0     OperatorSubtaskState initState1 = AbstractStreamOperatorTestHarness.repartitionOperatorState(snapshot3, maxParallelism, 3, 2, 0).     // init state for new subtask-1     OperatorSubtaskState initState2 = AbstractStreamOperatorTestHarness.repartitionOperatorState(snapshot3, maxParallelism, 3, 2, 1).     KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 = new KeyedOneInputStreamOperatorTestHarness[3].     OperatorSubtaskState snapshot2.     try {         List<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 2).         // task's key-group [0, 4]         // this will choose the state handle generated by harness3[0] to init the target db without any clipping.         KeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0).         Assert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20).         harness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0).         harness2[0].setStateBackend(getStateBackend()).         harness2[0].setup().         harness2[0].initializeState(initState1).         harness2[0].open().         // task's key-group [5, 9], this will open a empty db, and insert records from two state handles.         KeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1).         Assert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21).         harness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1).         harness2[1].setStateBackend(getStateBackend()).         harness2[1].setup().         harness2[1].initializeState(initState2).         harness2[1].open().         validHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]).         validHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]).         snapshot2 = AbstractStreamOperatorTestHarness.repackageState(harness2[0].snapshot(0, 0), harness2[1].snapshot(0, 0)).         validHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]).         validHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]).     } finally {         closeHarness(harness2).     }     // -----------------------------------------> test rescaling from 2 to 1 <---------------------------------------     // init state for new subtask-0     initState1 = AbstractStreamOperatorTestHarness.repartitionOperatorState(snapshot2, maxParallelism, 2, 1, 0).     try (KeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness = getHarnessTest(keySelector, maxParallelism, 1, 0)) {         // this will choose the state handle generated by harness2[0] to init the target db without any clipping.         harness.setStateBackend(getStateBackend()).         harness.setup().         harness.initializeState(initState1).         harness.open().         validHarnessResult(harness, 3, records).     } }
false;private;1;7;;private void closeHarness(KeyedOneInputStreamOperatorTestHarness<?, ?, ?>[] harnessArr) throws Exception {     for (KeyedOneInputStreamOperatorTestHarness<?, ?, ?> harness : harnessArr) {         if (harness != null) {             harness.close().         }     } }
false;private;3;12;;@SuppressWarnings("unchecked") private void validHarnessResult(KeyedOneInputStreamOperatorTestHarness<?, String, ?> harness, Integer expectedValue, String... records) throws Exception {     for (String record : records) {         harness.processElement(new StreamRecord<>(record, 1)).         StreamRecord<Integer> outputRecord = (StreamRecord<Integer>) harness.getOutput().poll().         Assert.assertNotNull(outputRecord).         Assert.assertEquals(expectedValue, outputRecord.getValue()).     } }
false;private;4;13;;private KeyedOneInputStreamOperatorTestHarness<String, String, Integer> getHarnessTest(KeySelector<String, String> keySelector, int maxParallelism, int taskParallelism, int subtaskIdx) throws Exception {     return new KeyedOneInputStreamOperatorTestHarness<>(new KeyedProcessOperator<>(new TestKeyedFunction()), keySelector, BasicTypeInfo.STRING_TYPE_INFO, maxParallelism, taskParallelism, subtaskIdx). }
false;private;0;3;;private StateBackend getStateBackend() throws Exception {     return new RocksDBStateBackend("file://" + rootFolder.newFolder().getAbsolutePath(), true). }
false;public;1;5;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     counterState = this.getRuntimeContext().getState(new ValueStateDescriptor<>("counter", Integer.class)). }
false;public;3;7;;@Override public void processElement(String value, Context ctx, Collector<Integer> out) throws Exception {     Integer oldCount = counterState.value().     Integer newCount = oldCount != null ? oldCount + 1 : 1.     counterState.update(newCount).     out.collect(newCount). }
false;public;1;4;;@Override public String getKey(String value) throws Exception {     return value. }
