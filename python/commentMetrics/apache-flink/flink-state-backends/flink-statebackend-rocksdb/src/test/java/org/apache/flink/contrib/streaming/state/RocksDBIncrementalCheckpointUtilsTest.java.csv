commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;@Test public void testClipDBWithKeyGroupRange() throws Exception {     testClipDBWithKeyGroupRangeHelper(new KeyGroupRange(0, 1), new KeyGroupRange(0, 2), 1).     testClipDBWithKeyGroupRangeHelper(new KeyGroupRange(0, 1), new KeyGroupRange(0, 1), 1).     testClipDBWithKeyGroupRangeHelper(new KeyGroupRange(0, 1), new KeyGroupRange(1, 2), 1).     testClipDBWithKeyGroupRangeHelper(new KeyGroupRange(0, 1), new KeyGroupRange(2, 4), 1).     testClipDBWithKeyGroupRangeHelper(new KeyGroupRange(Byte.MAX_VALUE - 15, Byte.MAX_VALUE), new KeyGroupRange(Byte.MAX_VALUE - 10, Byte.MAX_VALUE), 1).     testClipDBWithKeyGroupRangeHelper(new KeyGroupRange(Short.MAX_VALUE - 15, Short.MAX_VALUE), new KeyGroupRange(Short.MAX_VALUE - 10, Short.MAX_VALUE), 2).     testClipDBWithKeyGroupRangeHelper(new KeyGroupRange(Byte.MAX_VALUE - 15, Byte.MAX_VALUE - 1), new KeyGroupRange(Byte.MAX_VALUE - 10, Byte.MAX_VALUE), 1).     testClipDBWithKeyGroupRangeHelper(new KeyGroupRange(Short.MAX_VALUE - 15, Short.MAX_VALUE - 1), new KeyGroupRange(Short.MAX_VALUE - 10, Short.MAX_VALUE), 2). }
false;public;0;30;;@Test public void testChooseTheBestStateHandleForInitial() {     List<KeyedStateHandle> keyedStateHandles = new ArrayList<>(3).     KeyedStateHandle keyedStateHandle1 = mock(KeyedStateHandle.class).     when(keyedStateHandle1.getKeyGroupRange()).thenReturn(new KeyGroupRange(0, 3)).     keyedStateHandles.add(keyedStateHandle1).     KeyedStateHandle keyedStateHandle2 = mock(KeyedStateHandle.class).     when(keyedStateHandle2.getKeyGroupRange()).thenReturn(new KeyGroupRange(4, 7)).     keyedStateHandles.add(keyedStateHandle2).     KeyedStateHandle keyedStateHandle3 = mock(KeyedStateHandle.class).     when(keyedStateHandle3.getKeyGroupRange()).thenReturn(new KeyGroupRange(8, 12)).     keyedStateHandles.add(keyedStateHandle3).     // this should choose no one handle.     Assert.assertNull(RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(keyedStateHandles, new KeyGroupRange(3, 5))).     // this should choose keyedStateHandle2, because keyedStateHandle2's key-group range satisfies the overlap fraction demand.     Assert.assertEquals(keyedStateHandle2, RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(keyedStateHandles, new KeyGroupRange(3, 6))).     // both keyedStateHandle2 & keyedStateHandle3's key-group range satisfies the overlap fraction, but keyedStateHandle3's overlap fraction is better.     Assert.assertEquals(keyedStateHandle3, RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(keyedStateHandles, new KeyGroupRange(5, 12))).     // both keyedStateHandle2 & keyedStateHandle3's key-group range are covered by [3, 12],     // but this should choose the keyedStateHandle3, because keyedStateHandle3's key-group is bigger than keyedStateHandle2.     Assert.assertEquals(keyedStateHandle3, RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(keyedStateHandles, new KeyGroupRange(3, 12))). }
false;private;3;67;;private void testClipDBWithKeyGroupRangeHelper(KeyGroupRange targetGroupRange, KeyGroupRange currentGroupRange, int keyGroupPrefixBytes) throws RocksDBException, IOException {     try (RocksDB rocksDB = RocksDB.open(tmp.newFolder().getAbsolutePath()).         ColumnFamilyHandle columnFamilyHandle = rocksDB.createColumnFamily(new ColumnFamilyDescriptor("test".getBytes()))) {         int currentGroupRangeStart = currentGroupRange.getStartKeyGroup().         int currentGroupRangeEnd = currentGroupRange.getEndKeyGroup().         DataOutputSerializer outputView = new DataOutputSerializer(32).         for (int i = currentGroupRangeStart. i <= currentGroupRangeEnd. ++i) {             for (int j = 0. j < 100. ++j) {                 outputView.clear().                 RocksDBKeySerializationUtils.writeKeyGroup(i, keyGroupPrefixBytes, outputView).                 RocksDBKeySerializationUtils.writeKey(j, IntSerializer.INSTANCE, outputView, false).                 rocksDB.put(columnFamilyHandle, outputView.getCopyOfBuffer(), String.valueOf(j).getBytes()).             }         }         for (int i = currentGroupRangeStart. i <= currentGroupRangeEnd. ++i) {             for (int j = 0. j < 100. ++j) {                 outputView.clear().                 RocksDBKeySerializationUtils.writeKeyGroup(i, keyGroupPrefixBytes, outputView).                 RocksDBKeySerializationUtils.writeKey(j, IntSerializer.INSTANCE, outputView, false).                 byte[] value = rocksDB.get(columnFamilyHandle, outputView.getCopyOfBuffer()).                 Assert.assertEquals(String.valueOf(j), new String(value)).             }         }         RocksDBIncrementalCheckpointUtils.clipDBWithKeyGroupRange(rocksDB, Collections.singletonList(columnFamilyHandle), targetGroupRange, currentGroupRange, keyGroupPrefixBytes).         for (int i = currentGroupRangeStart. i <= currentGroupRangeEnd. ++i) {             for (int j = 0. j < 100. ++j) {                 outputView.clear().                 RocksDBKeySerializationUtils.writeKeyGroup(i, keyGroupPrefixBytes, outputView).                 RocksDBKeySerializationUtils.writeKey(j, IntSerializer.INSTANCE, outputView, false).                 byte[] value = rocksDB.get(columnFamilyHandle, outputView.getCopyOfBuffer()).                 if (targetGroupRange.contains(i)) {                     Assert.assertEquals(String.valueOf(j), new String(value)).                 } else {                     Assert.assertNull(value).                 }             }         }     } }
