commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@Parameterized.Parameters(name = "Incremental checkpointing: {0}") public static Collection<Boolean> parameters() {     return Arrays.asList(false, true). }
false;public;0;11;;public void prepareRocksDB() throws Exception {     instanceBasePath = tempFolder.newFolder().     instanceBasePath.mkdirs().     String dbPath = new File(instanceBasePath, DB_INSTANCE_DIR_STRING).getAbsolutePath().     columnOptions = PredefinedOptions.DEFAULT.createColumnOptions().     dbOptions = PredefinedOptions.DEFAULT.createDBOptions().setCreateIfMissing(true).     ArrayList<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1).     db = RocksDBOperationUtils.openDB(dbPath, Collections.emptyList(), columnFamilyHandles, columnOptions, dbOptions).     defaultCFHandle = columnFamilyHandles.remove(0). }
false;protected;0;13;;@Override protected RocksDBStateBackend getStateBackend() throws IOException {     dbPath = tempFolder.newFolder().getAbsolutePath().     String checkpointPath = tempFolder.newFolder().toURI().toString().     RocksDBStateBackend backend = new RocksDBStateBackend(new FsStateBackend(checkpointPath), enableIncrementalCheckpointing).     Configuration configuration = new Configuration().     configuration.setString(RocksDBOptions.TIMER_SERVICE_FACTORY, RocksDBStateBackend.PriorityQueueStateType.ROCKSDB.toString()).     backend = backend.configure(configuration, Thread.currentThread().getContextClassLoader()).     backend.setDbStoragePath(dbPath).     return backend. }
false;protected;0;4;;@Override protected boolean isSerializerPresenceRequiredOnRestore() {     return false. }
true;public;0;23;// small safety net for instance cleanups, so that no native objects are left ;// small safety net for instance cleanups, so that no native objects are left @After public void cleanupRocksDB() {     if (keyedStateBackend != null) {         IOUtils.closeQuietly(keyedStateBackend).         keyedStateBackend.dispose().     }     IOUtils.closeQuietly(defaultCFHandle).     IOUtils.closeQuietly(db).     IOUtils.closeQuietly(columnOptions).     IOUtils.closeQuietly(dbOptions).     if (allCreatedCloseables != null) {         for (RocksObject rocksCloseable : allCreatedCloseables) {             verify(rocksCloseable, times(1)).close().         }         allCreatedCloseables = null.     }     try {         org.apache.flink.util.FileUtils.deleteDirectory(instanceBasePath).     } catch (Exception ex) {     // ignored     } }
false;public;1;6;;@Override public Object answer(InvocationOnMock invocationOnMock) throws Throwable {     RocksIterator rocksIterator = spy((RocksIterator) invocationOnMock.callRealMethod()).     allCreatedCloseables.add(rocksIterator).     return rocksIterator. }
false;public;1;6;;@Override public Object answer(InvocationOnMock invocationOnMock) throws Throwable {     Snapshot snapshot = spy((Snapshot) invocationOnMock.callRealMethod()).     allCreatedCloseables.add(snapshot).     return snapshot. }
false;public;1;6;;@Override public Object answer(InvocationOnMock invocationOnMock) throws Throwable {     ColumnFamilyHandle snapshot = spy((ColumnFamilyHandle) invocationOnMock.callRealMethod()).     allCreatedCloseables.add(snapshot).     return snapshot. }
false;public;0;81;;public void setupRocksKeyedStateBackend() throws Exception {     blocker = new OneShotLatch().     waiter = new OneShotLatch().     testStreamFactory = new BlockerCheckpointStreamFactory(1024 * 1024).     testStreamFactory.setBlockerLatch(blocker).     testStreamFactory.setWaiterLatch(waiter).     testStreamFactory.setAfterNumberInvocations(10).     prepareRocksDB().     Environment env = new DummyEnvironment("TestTask", 1, 0).     keyedStateBackend = new RocksDBKeyedStateBackendBuilder<>("Test", Thread.currentThread().getContextClassLoader(), instanceBasePath, dbOptions, stateName -> PredefinedOptions.DEFAULT.createColumnOptions(), mock(TaskKvStateRegistry.class), IntSerializer.INSTANCE, 2, new KeyGroupRange(0, 1), env.getExecutionConfig(), env.getTaskStateManager().createLocalRecoveryConfig(), RocksDBStateBackend.PriorityQueueStateType.ROCKSDB, TtlTimeProvider.DEFAULT, new UnregisteredMetricsGroup(), Collections.emptyList(), RocksDBStateBackend.getCompressionDecorator(env.getExecutionConfig()), spy(db), defaultCFHandle).build().     testState1 = keyedStateBackend.getPartitionedState(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, new ValueStateDescriptor<>("TestState-1", Integer.class, 0)).     testState2 = keyedStateBackend.getPartitionedState(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, new ValueStateDescriptor<>("TestState-2", String.class, "")).     allCreatedCloseables = new ArrayList<>().     doAnswer(new Answer<Object>() {          @Override         public Object answer(InvocationOnMock invocationOnMock) throws Throwable {             RocksIterator rocksIterator = spy((RocksIterator) invocationOnMock.callRealMethod()).             allCreatedCloseables.add(rocksIterator).             return rocksIterator.         }     }).when(keyedStateBackend.db).newIterator(any(ColumnFamilyHandle.class), any(ReadOptions.class)).     doAnswer(new Answer<Object>() {          @Override         public Object answer(InvocationOnMock invocationOnMock) throws Throwable {             Snapshot snapshot = spy((Snapshot) invocationOnMock.callRealMethod()).             allCreatedCloseables.add(snapshot).             return snapshot.         }     }).when(keyedStateBackend.db).getSnapshot().     doAnswer(new Answer<Object>() {          @Override         public Object answer(InvocationOnMock invocationOnMock) throws Throwable {             ColumnFamilyHandle snapshot = spy((ColumnFamilyHandle) invocationOnMock.callRealMethod()).             allCreatedCloseables.add(snapshot).             return snapshot.         }     }).when(keyedStateBackend.db).createColumnFamily(any(ColumnFamilyDescriptor.class)).     for (int i = 0. i < 100. ++i) {         keyedStateBackend.setCurrentKey(i).         testState1.update(4200 + i).         testState2.update("S-" + (4200 + i)).     } }
false;public;0;45;;@Test public void testCorrectMergeOperatorSet() throws Exception {     prepareRocksDB().     final ColumnFamilyOptions columnFamilyOptions = spy(new ColumnFamilyOptions()).     RocksDBKeyedStateBackend<Integer> test = null.     try (DBOptions options = new DBOptions().setCreateIfMissing(true)) {         ExecutionConfig executionConfig = new ExecutionConfig().         test = new RocksDBKeyedStateBackendBuilder<>("test", Thread.currentThread().getContextClassLoader(), tempFolder.newFolder(), options, stateName -> columnFamilyOptions, mock(TaskKvStateRegistry.class), IntSerializer.INSTANCE, 1, new KeyGroupRange(0, 0), executionConfig, mock(LocalRecoveryConfig.class), RocksDBStateBackend.PriorityQueueStateType.HEAP, TtlTimeProvider.DEFAULT, new UnregisteredMetricsGroup(), Collections.emptyList(), RocksDBStateBackend.getCompressionDecorator(executionConfig), db, defaultCFHandle).build().         ValueStateDescriptor<String> stubState1 = new ValueStateDescriptor<>("StubState-1", StringSerializer.INSTANCE).         test.createInternalState(StringSerializer.INSTANCE, stubState1).         ValueStateDescriptor<String> stubState2 = new ValueStateDescriptor<>("StubState-2", StringSerializer.INSTANCE).         test.createInternalState(StringSerializer.INSTANCE, stubState2).         // The default CF is pre-created so sum up to 2 times (once for each stub state)         verify(columnFamilyOptions, Mockito.times(2)).setMergeOperatorName(RocksDBKeyedStateBackend.MERGE_OPERATOR_NAME).     } finally {         if (test != null) {             IOUtils.closeQuietly(test).             test.dispose().         }         columnFamilyOptions.close().     } }
false;public;0;37;;@Test public void testReleasingSnapshotAfterBackendClosed() throws Exception {     setupRocksKeyedStateBackend().     try {         RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot = keyedStateBackend.snapshot(0L, 0L, testStreamFactory, CheckpointOptions.forCheckpointWithDefaultLocation()).         RocksDB spyDB = keyedStateBackend.db.         if (!enableIncrementalCheckpointing) {             verify(spyDB, times(1)).getSnapshot().             verify(spyDB, times(0)).releaseSnapshot(any(Snapshot.class)).         }         // Ensure every RocksObjects not closed yet         for (RocksObject rocksCloseable : allCreatedCloseables) {             verify(rocksCloseable, times(0)).close().         }         snapshot.cancel(true).         this.keyedStateBackend.dispose().         verify(spyDB, times(1)).close().         assertEquals(true, keyedStateBackend.isDisposed()).         // Ensure every RocksObjects was closed exactly once         for (RocksObject rocksCloseable : allCreatedCloseables) {             verify(rocksCloseable, times(1)).close().         }     } finally {         keyedStateBackend.dispose().         keyedStateBackend = null.     } }
false;public;0;13;;@Test public void testDismissingSnapshot() throws Exception {     setupRocksKeyedStateBackend().     try {         RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot = keyedStateBackend.snapshot(0L, 0L, testStreamFactory, CheckpointOptions.forCheckpointWithDefaultLocation()).         snapshot.cancel(true).         verifyRocksObjectsReleased().     } finally {         this.keyedStateBackend.dispose().         this.keyedStateBackend = null.     } }
false;public;0;22;;@Test public void testDismissingSnapshotNotRunnable() throws Exception {     setupRocksKeyedStateBackend().     try {         RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot = keyedStateBackend.snapshot(0L, 0L, testStreamFactory, CheckpointOptions.forCheckpointWithDefaultLocation()).         snapshot.cancel(true).         Thread asyncSnapshotThread = new Thread(snapshot).         asyncSnapshotThread.start().         try {             snapshot.get().             fail().         } catch (Exception ignored) {         }         asyncSnapshotThread.join().         verifyRocksObjectsReleased().     } finally {         this.keyedStateBackend.dispose().         this.keyedStateBackend = null.     } }
false;public;0;31;;@Test public void testCompletingSnapshot() throws Exception {     setupRocksKeyedStateBackend().     try {         RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot = keyedStateBackend.snapshot(0L, 0L, testStreamFactory, CheckpointOptions.forCheckpointWithDefaultLocation()).         Thread asyncSnapshotThread = new Thread(snapshot).         asyncSnapshotThread.start().         // wait for snapshot to run         waiter.await().         waiter.reset().         runStateUpdates().         // allow checkpointing to start writing         blocker.trigger().         // wait for snapshot stream writing to run         waiter.await().         SnapshotResult<KeyedStateHandle> snapshotResult = snapshot.get().         KeyedStateHandle keyedStateHandle = snapshotResult.getJobManagerOwnedSnapshot().         assertNotNull(keyedStateHandle).         assertTrue(keyedStateHandle.getStateSize() > 0).         assertEquals(2, keyedStateHandle.getKeyGroupRange().getNumberOfKeyGroups()).         for (BlockingCheckpointOutputStream stream : testStreamFactory.getAllCreatedStreams()) {             assertTrue(stream.isClosed()).         }         asyncSnapshotThread.join().         verifyRocksObjectsReleased().     } finally {         this.keyedStateBackend.dispose().         this.keyedStateBackend = null.     } }
false;public;0;32;;@Test public void testCancelRunningSnapshot() throws Exception {     setupRocksKeyedStateBackend().     try {         RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot = keyedStateBackend.snapshot(0L, 0L, testStreamFactory, CheckpointOptions.forCheckpointWithDefaultLocation()).         Thread asyncSnapshotThread = new Thread(snapshot).         asyncSnapshotThread.start().         // wait for snapshot to run         waiter.await().         waiter.reset().         runStateUpdates().         snapshot.cancel(true).         // allow checkpointing to start writing         blocker.trigger().         for (BlockingCheckpointOutputStream stream : testStreamFactory.getAllCreatedStreams()) {             assertTrue(stream.isClosed()).         }         // wait for snapshot stream writing to run         waiter.await().         try {             snapshot.get().             fail().         } catch (Exception ignored) {         }         asyncSnapshotThread.join().         verifyRocksObjectsReleased().     } finally {         this.keyedStateBackend.dispose().         this.keyedStateBackend = null.     } }
false;public;0;29;;@Test public void testDisposeDeletesAllDirectories() throws Exception {     AbstractKeyedStateBackend<Integer> backend = createKeyedBackend(IntSerializer.INSTANCE).     Collection<File> allFilesInDbDir = FileUtils.listFilesAndDirs(new File(dbPath), new AcceptAllFilter(), new AcceptAllFilter()).     try {         ValueStateDescriptor<String> kvId = new ValueStateDescriptor<>("id", String.class, null).         kvId.initializeSerializerUnlessSet(new ExecutionConfig()).         ValueState<String> state = backend.getPartitionedState(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId).         backend.setCurrentKey(1).         state.update("Hello").         // more than just the root directory         assertTrue(allFilesInDbDir.size() > 1).     } finally {         IOUtils.closeQuietly(backend).         backend.dispose().     }     allFilesInDbDir = FileUtils.listFilesAndDirs(new File(dbPath), new AcceptAllFilter(), new AcceptAllFilter()).     // just the root directory left     assertEquals(1, allFilesInDbDir.size()). }
false;public;0;68;;@Test public void testSharedIncrementalStateDeRegistration() throws Exception {     if (enableIncrementalCheckpointing) {         AbstractKeyedStateBackend<Integer> backend = createKeyedBackend(IntSerializer.INSTANCE).         try {             ValueStateDescriptor<String> kvId = new ValueStateDescriptor<>("id", String.class, null).             kvId.initializeSerializerUnlessSet(new ExecutionConfig()).             ValueState<String> state = backend.getPartitionedState(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId).             Queue<IncrementalRemoteKeyedStateHandle> previousStateHandles = new LinkedList<>().             SharedStateRegistry sharedStateRegistry = spy(new SharedStateRegistry()).             for (int checkpointId = 0. checkpointId < 3. ++checkpointId) {                 reset(sharedStateRegistry).                 backend.setCurrentKey(checkpointId).                 state.update("Hello-" + checkpointId).                 RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot = backend.snapshot(checkpointId, checkpointId, createStreamFactory(), CheckpointOptions.forCheckpointWithDefaultLocation()).                 snapshot.run().                 SnapshotResult<KeyedStateHandle> snapshotResult = snapshot.get().                 IncrementalRemoteKeyedStateHandle stateHandle = (IncrementalRemoteKeyedStateHandle) snapshotResult.getJobManagerOwnedSnapshot().                 Map<StateHandleID, StreamStateHandle> sharedState = new HashMap<>(stateHandle.getSharedState()).                 stateHandle.registerSharedStates(sharedStateRegistry).                 for (Map.Entry<StateHandleID, StreamStateHandle> e : sharedState.entrySet()) {                     verify(sharedStateRegistry).registerReference(stateHandle.createSharedStateRegistryKeyFromFileName(e.getKey()), e.getValue()).                 }                 previousStateHandles.add(stateHandle).                 backend.notifyCheckpointComplete(checkpointId).                 if (previousStateHandles.size() > 1) {                     checkRemove(previousStateHandles.remove(), sharedStateRegistry).                 }             }             while (!previousStateHandles.isEmpty()) {                 reset(sharedStateRegistry).                 checkRemove(previousStateHandles.remove(), sharedStateRegistry).             }         } finally {             IOUtils.closeQuietly(backend).             backend.dispose().         }     } }
false;private;2;13;;private void checkRemove(IncrementalRemoteKeyedStateHandle remove, SharedStateRegistry registry) throws Exception {     for (StateHandleID id : remove.getSharedState().keySet()) {         verify(registry, times(0)).unregisterReference(remove.createSharedStateRegistryKeyFromFileName(id)).     }     remove.discardState().     for (StateHandleID id : remove.getSharedState().keySet()) {         verify(registry).unregisterReference(remove.createSharedStateRegistryKeyFromFileName(id)).     } }
false;private;0;10;;private void runStateUpdates() throws Exception {     for (int i = 50. i < 150. ++i) {         if (i % 10 == 0) {             Thread.sleep(1).         }         keyedStateBackend.setCurrentKey(i).         testState1.update(4200 + i).         testState2.update("S-" + (4200 + i)).     } }
false;private;0;18;;private void verifyRocksObjectsReleased() {     // Ensure every RocksObject was closed exactly once     for (RocksObject rocksCloseable : allCreatedCloseables) {         verify(rocksCloseable, times(1)).close().     }     assertNotNull(null, keyedStateBackend.db).     RocksDB spyDB = keyedStateBackend.db.     if (!enableIncrementalCheckpointing) {         verify(spyDB, times(1)).getSnapshot().         verify(spyDB, times(1)).releaseSnapshot(any(Snapshot.class)).     }     keyedStateBackend.dispose().     verify(spyDB, times(1)).close().     assertEquals(true, keyedStateBackend.isDisposed()). }
false;public;1;4;;@Override public boolean accept(File file) {     return true. }
false;public;2;4;;@Override public boolean accept(File file, String s) {     return true. }
