commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Test public void testIterator() throws Exception {     // test for keyGroupPrefixBytes == 1 && ambiguousKeyPossible == false     testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -> i).     // test for keyGroupPrefixBytes == 1 && ambiguousKeyPossible == true     testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -> String.valueOf(i)).     // test for keyGroupPrefixBytes == 2 && ambiguousKeyPossible == false     testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -> i).     // test for keyGroupPrefixBytes == 2 && ambiguousKeyPossible == true     testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -> String.valueOf(i)). }
false;;4;81;;<K> void testIteratorHelper(TypeSerializer<K> keySerializer, TypeSerializer namespaceSerializer, int maxKeyGroupNumber, Function<Integer, K> getKeyFunc) throws Exception {     String testStateName = "aha".     String namespace = "ns".     String dbPath = tmp.newFolder().getAbsolutePath().     String checkpointPath = tmp.newFolder().toURI().toString().     RocksDBStateBackend backend = new RocksDBStateBackend(new FsStateBackend(checkpointPath), true).     backend.setDbStoragePath(dbPath).     Environment env = new DummyEnvironment("TestTask", 1, 0).     RocksDBKeyedStateBackend<K> keyedStateBackend = (RocksDBKeyedStateBackend<K>) backend.createKeyedStateBackend(env, new JobID(), "Test", keySerializer, maxKeyGroupNumber, new KeyGroupRange(0, maxKeyGroupNumber - 1), mock(TaskKvStateRegistry.class)).     try {         ValueState<String> testState = keyedStateBackend.getPartitionedState(namespace, namespaceSerializer, new ValueStateDescriptor<String>(testStateName, String.class)).         // insert record         for (int i = 0. i < 1000. ++i) {             keyedStateBackend.setCurrentKey(getKeyFunc.apply(i)).             testState.update(String.valueOf(i)).         }         DataOutputSerializer outputStream = new DataOutputSerializer(8).         boolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(keySerializer, namespaceSerializer).         RocksDBKeySerializationUtils.writeNameSpace(namespace, namespaceSerializer, outputStream, ambiguousKeyPossible).         byte[] nameSpaceBytes = outputStream.getCopyOfBuffer().         // already created with the state, should be closed with the backend         ColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName).         try (RocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(keyedStateBackend.db, handle).             RocksStateKeysIterator<K> iteratorWrapper = new RocksStateKeysIterator<>(iterator, testStateName, keySerializer, keyedStateBackend.getKeyGroupPrefixBytes(), ambiguousKeyPossible, nameSpaceBytes)) {             iterator.seekToFirst().             // valid record             List<Integer> fetchedKeys = new ArrayList<>(1000).             while (iteratorWrapper.hasNext()) {                 fetchedKeys.add(Integer.parseInt(iteratorWrapper.next().toString())).             }             fetchedKeys.sort(Comparator.comparingInt(a -> a)).             Assert.assertEquals(1000, fetchedKeys.size()).             for (int i = 0. i < 1000. ++i) {                 Assert.assertEquals(i, fetchedKeys.get(i).intValue()).             }         }     } finally {         if (keyedStateBackend != null) {             keyedStateBackend.dispose().         }     } }
