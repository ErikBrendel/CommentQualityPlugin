commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected StateBackend createStateBackend() {     return RocksDBTtlStateTestBase.this.createStateBackend(). }
false;protected;1;9;;@Override protected StateBackendTestContext createStateBackendTestContext(TtlTimeProvider timeProvider) {     return new StateBackendTestContext(timeProvider) {          @Override         protected StateBackend createStateBackend() {             return RocksDBTtlStateTestBase.this.createStateBackend().         }     }. }
false;abstract;0;1;;abstract StateBackend createStateBackend().
false;;1;16;;StateBackend createStateBackend(TernaryBoolean enableIncrementalCheckpointing) {     String dbPath.     String checkpointPath.     try {         dbPath = tempFolder.newFolder().getAbsolutePath().         checkpointPath = tempFolder.newFolder().toURI().toString().     } catch (IOException e) {         throw new FlinkRuntimeException("Failed to init rocksdb test state backend").     }     RocksDBStateBackend backend = new RocksDBStateBackend(new FsStateBackend(checkpointPath), enableIncrementalCheckpointing).     Configuration config = new Configuration().     config.setBoolean(TTL_COMPACT_FILTER_ENABLED, true).     backend = backend.configure(config, Thread.currentThread().getContextClassLoader()).     backend.setDbStoragePath(dbPath).     return backend. }
false;public;0;4;;@Test public void testCompactFilter() throws Exception {     testCompactFilter(false, false). }
false;public;0;4;;@Test public void testCompactFilterWithSnapshot() throws Exception {     testCompactFilter(true, false). }
false;public;0;4;;@Test public void testCompactFilterWithSnapshotAndRescalingAfterRestore() throws Exception {     testCompactFilter(true, true). }
false;private;2;77;;@SuppressWarnings("resource") private void testCompactFilter(boolean takeSnapshot, boolean rescaleAfterRestore) throws Exception {     int numberOfKeyGroupsAfterRestore = StateBackendTestContext.NUMBER_OF_KEY_GROUPS.     if (rescaleAfterRestore) {         numberOfKeyGroupsAfterRestore *= 2.     }     StateDescriptor<?, ?> stateDesc = initTest(getConfBuilder(TTL).cleanupInRocksdbCompactFilter().setStateVisibility(StateTtlConfig.StateVisibility.ReturnExpiredIfNotCleanedUp).build()).     if (takeSnapshot) {         takeAndRestoreSnapshot(numberOfKeyGroupsAfterRestore).     }     setTimeAndCompact(stateDesc, 0L).     sbetc.setCurrentKey("k1").     ctx().update(ctx().updateEmpty).     checkUnexpiredOriginalAvailable().     sbetc.setCurrentKey("k2").     ctx().update(ctx().updateEmpty).     checkUnexpiredOriginalAvailable().     if (takeSnapshot) {         takeAndRestoreSnapshot(numberOfKeyGroupsAfterRestore).     }     setTimeAndCompact(stateDesc, 50L).     sbetc.setCurrentKey("k1").     checkUnexpiredOriginalAvailable().     assertEquals(UNEXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()).     ctx().update(ctx().updateUnexpired).     checkUnexpiredOriginalAvailable().     sbetc.setCurrentKey("k2").     checkUnexpiredOriginalAvailable().     assertEquals(UNEXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()).     ctx().update(ctx().updateUnexpired).     checkUnexpiredOriginalAvailable().     if (takeSnapshot) {         takeAndRestoreSnapshot(numberOfKeyGroupsAfterRestore).     }     // compaction which should not touch unexpired data     // and merge list element with different expiration time     setTimeAndCompact(stateDesc, 80L).     // expire oldest data     setTimeAndCompact(stateDesc, 120L).     sbetc.setCurrentKey("k1").     checkUnexpiredOriginalAvailable().     assertEquals(UPDATED_UNEXPIRED_AVAIL, ctx().getUnexpired, ctx().get()).     sbetc.setCurrentKey("k2").     checkUnexpiredOriginalAvailable().     assertEquals(UPDATED_UNEXPIRED_AVAIL, ctx().getUnexpired, ctx().get()).     if (takeSnapshot) {         takeAndRestoreSnapshot(numberOfKeyGroupsAfterRestore).     }     setTimeAndCompact(stateDesc, 170L).     sbetc.setCurrentKey("k1").     assertEquals("Expired original state should be unavailable", ctx().emptyValue, ctx().getOriginal()).     assertEquals(EXPIRED_UNAVAIL, ctx().emptyValue, ctx().get()).     sbetc.setCurrentKey("k2").     assertEquals("Expired original state should be unavailable", ctx().emptyValue, ctx().getOriginal()).     assertEquals("Expired state should be unavailable", ctx().emptyValue, ctx().get()). }
false;private;0;3;;private void checkUnexpiredOriginalAvailable() throws Exception {     assertNotEquals("Unexpired original state should be available", ctx().emptyValue, ctx().getOriginal()). }
false;private;2;6;;private void setTimeAndCompact(StateDescriptor<?, ?> stateDesc, long ts) throws RocksDBException {     @SuppressWarnings("resource")     RocksDBKeyedStateBackend<String> keyedBackend = sbetc.getKeyedStateBackend().     timeProvider.time = ts.     keyedBackend.compactState(stateDesc). }
