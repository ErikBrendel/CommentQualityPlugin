commented;modifiers;parameterAmount;loc;comment;code
true;public;0;19;/**  * Test that the exception arose in the thread pool will rethrow to the main thread.  */ ;/**  * Test that the exception arose in the thread pool will rethrow to the main thread.  */ @Test public void testMultiThreadUploadThreadPoolExceptionRethrow() throws IOException {     SpecifiedException expectedException = new SpecifiedException("throw exception while multi thread upload states.").     CheckpointStreamFactory.CheckpointStateOutputStream outputStream = createFailingCheckpointStateOutputStream(expectedException).     CheckpointStreamFactory checkpointStreamFactory = (CheckpointedStateScope scope) -> outputStream.     File file = temporaryFolder.newFile(String.valueOf(UUID.randomUUID())).     generateRandomFileContent(file.getPath(), 20).     Map<StateHandleID, Path> filePaths = new HashMap<>(1).     filePaths.put(new StateHandleID("mockHandleID"), new Path(file.getPath())).     try (RocksDBStateUploader rocksDBStateUploader = new RocksDBStateUploader(5)) {         rocksDBStateUploader.uploadFilesToCheckpointFs(filePaths, checkpointStreamFactory, new CloseableRegistry()).         fail().     } catch (Exception e) {         assertEquals(expectedException, e).     } }
true;public;0;28;/**  * Test that upload files with multi-thread correctly.  */ ;/**  * Test that upload files with multi-thread correctly.  */ @Test public void testMultiThreadUploadCorrectly() throws Exception {     File checkpointPrivateFolder = temporaryFolder.newFolder("private").     Path checkpointPrivateDirectory = new Path(checkpointPrivateFolder.getPath()).     File checkpointSharedFolder = temporaryFolder.newFolder("shared").     Path checkpointSharedDirectory = new Path(checkpointSharedFolder.getPath()).     FileSystem fileSystem = checkpointPrivateDirectory.getFileSystem().     int fileStateSizeThreshold = 1024.     FsCheckpointStreamFactory checkpointStreamFactory = new FsCheckpointStreamFactory(fileSystem, checkpointPrivateDirectory, checkpointSharedDirectory, fileStateSizeThreshold).     String localFolder = "local".     temporaryFolder.newFolder(localFolder).     int sstFileCount = 6.     Map<StateHandleID, Path> sstFilePaths = generateRandomSstFiles(localFolder, sstFileCount, fileStateSizeThreshold).     try (RocksDBStateUploader rocksDBStateUploader = new RocksDBStateUploader(5)) {         Map<StateHandleID, StreamStateHandle> sstFiles = rocksDBStateUploader.uploadFilesToCheckpointFs(sstFilePaths, checkpointStreamFactory, new CloseableRegistry()).         for (Map.Entry<StateHandleID, Path> entry : sstFilePaths.entrySet()) {             assertStateContentEqual(entry.getValue(), sstFiles.get(entry.getKey()).openInputStream()).         }     } }
false;public;0;5;;@Nullable @Override public StreamStateHandle closeAndGetHandle() {     return new ByteStreamStateHandle("testHandle", "testHandle".getBytes()). }
false;public;0;3;;@Override public void close() { }
false;public;0;4;;@Override public long getPos() {     return 0. }
false;public;0;3;;@Override public void flush() { }
false;public;0;3;;@Override public void sync() { }
false;public;1;4;;@Override public void write(int b) throws IOException {     throw failureException. }
false;private;1;32;;private CheckpointStreamFactory.CheckpointStateOutputStream createFailingCheckpointStateOutputStream(IOException failureException) {     return new CheckpointStreamFactory.CheckpointStateOutputStream() {          @Nullable         @Override         public StreamStateHandle closeAndGetHandle() {             return new ByteStreamStateHandle("testHandle", "testHandle".getBytes()).         }          @Override         public void close() {         }          @Override         public long getPos() {             return 0.         }          @Override         public void flush() {         }          @Override         public void sync() {         }          @Override         public void write(int b) throws IOException {             throw failureException.         }     }. }
false;private;3;14;;private Map<StateHandleID, Path> generateRandomSstFiles(String localFolder, int sstFileCount, int fileStateSizeThreshold) throws IOException {     ThreadLocalRandom random = ThreadLocalRandom.current().     Map<StateHandleID, Path> sstFilePaths = new HashMap<>(sstFileCount).     for (int i = 0. i < sstFileCount. ++i) {         File file = temporaryFolder.newFile(String.format("%s/%d.sst", localFolder, i)).         generateRandomFileContent(file.getPath(), random.nextInt(1_000_000) + fileStateSizeThreshold).         sstFilePaths.put(new StateHandleID(String.valueOf(i)), Path.fromLocalFile(file)).     }     return sstFilePaths. }
false;private;2;7;;private void generateRandomFileContent(String filePath, int fileLength) throws IOException {     FileOutputStream fileStream = new FileOutputStream(filePath).     byte[] contents = new byte[fileLength].     ThreadLocalRandom.current().nextBytes(contents).     fileStream.write(contents).     fileStream.close(). }
false;private;2;7;;private void assertStateContentEqual(Path stateFilePath, FSDataInputStream inputStream) throws IOException {     byte[] excepted = Files.readAllBytes(Paths.get(stateFilePath.toUri())).     byte[] actual = new byte[excepted.length].     IOUtils.readFully(inputStream, actual, 0, actual.length).     assertEquals(-1, inputStream.read()).     assertArrayEquals(excepted, actual). }
