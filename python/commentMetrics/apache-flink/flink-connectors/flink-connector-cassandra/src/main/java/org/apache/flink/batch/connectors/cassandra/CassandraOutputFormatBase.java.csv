commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void configure(Configuration parameters) {     this.cluster = builder.getCluster(). }
false;public;1;4;;@Override public void onSuccess(ResultSet ignored) {     onWriteSuccess(ignored). }
false;public;1;4;;@Override public void onFailure(Throwable t) {     onWriteFailure(t). }
true;public;2;16;/**  * Opens a Session to Cassandra and initializes the prepared statement.  *  * @param taskNumber The number of the parallel instance.  * @throws IOException Thrown, if the output could not be opened due to an  *                     I/O problem.  */ ;/**  * Opens a Session to Cassandra and initializes the prepared statement.  *  * @param taskNumber The number of the parallel instance.  * @throws IOException Thrown, if the output could not be opened due to an  *                     I/O problem.  */ @Override public void open(int taskNumber, int numTasks) throws IOException {     this.session = cluster.connect().     this.prepared = session.prepare(insertQuery).     this.callback = new FutureCallback<ResultSet>() {          @Override         public void onSuccess(ResultSet ignored) {             onWriteSuccess(ignored).         }          @Override         public void onFailure(Throwable t) {             onWriteFailure(t).         }     }. }
false;public;1;10;;@Override public void writeRecord(OUT record) throws IOException {     if (exception != null) {         throw new IOException("write record failed", exception).     }     Object[] fields = extractFields(record).     ResultSetFuture result = session.executeAsync(prepared.bind(fields)).     Futures.addCallback(result, callback). }
false;protected,abstract;1;1;;protected abstract Object[] extractFields(OUT record).
true;protected;1;2;/**  * Callback that is invoked after a record is written to Cassandra successfully.  *  * <p>Subclass can override to provide its own logic.  * @param ignored the result.  */ ;/**  * Callback that is invoked after a record is written to Cassandra successfully.  *  * <p>Subclass can override to provide its own logic.  * @param ignored the result.  */ protected void onWriteSuccess(ResultSet ignored) { }
true;protected;1;3;/**  * Callback that is invoked when failing to write to Cassandra.  * Current implementation will record the exception and fail the job upon next record.  *  * <p>Subclass can override to provide its own failure handling logic.  * @param t the exception  */ ;/**  * Callback that is invoked when failing to write to Cassandra.  * Current implementation will record the exception and fail the job upon next record.  *  * <p>Subclass can override to provide its own failure handling logic.  * @param t the exception  */ protected void onWriteFailure(Throwable t) {     exception = t. }
true;public;0;18;/**  * Closes all resources used.  */ ;/**  * Closes all resources used.  */ @Override public void close() throws IOException {     try {         if (session != null) {             session.close().         }     } catch (Exception e) {         LOG.error("Error while closing session.", e).     }     try {         if (cluster != null) {             cluster.close().         }     } catch (Exception e) {         LOG.error("Error while closing cluster.", e).     } }
