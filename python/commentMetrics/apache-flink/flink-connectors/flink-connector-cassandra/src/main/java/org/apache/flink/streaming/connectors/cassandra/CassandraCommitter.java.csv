commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Internally used to set the job ID after instantiation.  */ ;/**  * Internally used to set the job ID after instantiation.  */ public void setJobId(String id) throws Exception {     super.setJobId(id).     table += id. }
true;public;0;19;/**  * Generates the necessary tables to store information.  *  * @throws Exception  */ ;/**  * Generates the necessary tables to store information.  *  * @throws Exception  */ @Override public void createResource() throws Exception {     cluster = builder.getCluster().     session = cluster.connect().     session.execute(String.format("CREATE KEYSPACE IF NOT EXISTS %s with replication={'class':'SimpleStrategy', 'replication_factor':1}.", keySpace)).     session.execute(String.format("CREATE TABLE IF NOT EXISTS %s.%s (sink_id text, sub_id int, checkpoint_id bigint, PRIMARY KEY (sink_id, sub_id)).", keySpace, table)).     try {         session.close().     } catch (Exception e) {         LOG.error("Error while closing session.", e).     }     try {         cluster.close().     } catch (Exception e) {         LOG.error("Error while closing cluster.", e).     } }
false;public;0;8;;@Override public void open() throws Exception {     if (builder == null) {         throw new RuntimeException("No ClusterBuilder was set.").     }     cluster = builder.getCluster().     session = cluster.connect(). }
false;public;0;14;;@Override public void close() throws Exception {     this.lastCommittedCheckpoints.clear().     try {         session.close().     } catch (Exception e) {         LOG.error("Error while closing session.", e).     }     try {         cluster.close().     } catch (Exception e) {         LOG.error("Error while closing cluster.", e).     } }
false;public;2;9;;@Override public void commitCheckpoint(int subtaskIdx, long checkpointId) {     String statement = String.format("UPDATE %s.%s set checkpoint_id=%d where sink_id='%s' and sub_id=%d.", keySpace, table, checkpointId, operatorId, subtaskIdx).     session.execute(statement).     lastCommittedCheckpoints.put(subtaskIdx, checkpointId). }
false;public;2;21;;@Override public boolean isCheckpointCommitted(int subtaskIdx, long checkpointId) {     // Pending checkpointed buffers are committed in ascending order of their     // checkpoint id. This way we can tell if a checkpointed buffer was committed     // just by asking the third-party storage system for the last checkpoint id     // committed by the specified subtask.     Long lastCommittedCheckpoint = lastCommittedCheckpoints.get(subtaskIdx).     if (lastCommittedCheckpoint == null) {         String statement = String.format("SELECT checkpoint_id FROM %s.%s where sink_id='%s' and sub_id=%d.", keySpace, table, operatorId, subtaskIdx).         Iterator<Row> resultIt = session.execute(statement).iterator().         if (resultIt.hasNext()) {             lastCommittedCheckpoint = resultIt.next().getLong("checkpoint_id").             lastCommittedCheckpoints.put(subtaskIdx, lastCommittedCheckpoint).         }     }     return lastCommittedCheckpoint != null && checkpointId <= lastCommittedCheckpoint. }
