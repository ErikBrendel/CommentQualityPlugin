commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;public void open() throws Exception {     super.open().     if (!getRuntimeContext().isCheckpointingEnabled()) {         throw new IllegalStateException("The write-ahead log requires checkpointing to be enabled.").     }     cluster = builder.getCluster().     session = cluster.connect().     preparedStatement = session.prepare(insertQuery).     arity = ((RowSerializer) serializer).getArity().     fields = new Object[arity]. }
false;public;0;18;;@Override public void close() throws Exception {     super.close().     try {         if (session != null) {             session.close().         }     } catch (Exception e) {         LOG.error("Error while closing session.", e).     }     try {         if (cluster != null) {             cluster.close().         }     } catch (Exception e) {         LOG.error("Error while closing cluster.", e).     } }
false;public;1;11;;@Override public void onSuccess(ResultSet resultSet) {     updatesConfirmed.incrementAndGet().     if (updatesCount.get() > 0) {         // only set if all updates have been sent         if (updatesCount.get() == updatesConfirmed.get()) {             synchronized (updatesConfirmed) {                 updatesConfirmed.notifyAll().             }         }     } }
false;public;1;9;;@Override public void onFailure(Throwable throwable) {     if (exception.compareAndSet(null, throwable)) {         LOG.error("Error while sending value.", throwable).         synchronized (updatesConfirmed) {             updatesConfirmed.notifyAll().         }     } }
false;protected;3;62;;@Override protected boolean sendValues(Iterable<Row> values, long checkpointId, long timestamp) throws Exception {     final AtomicInteger updatesCount = new AtomicInteger(0).     final AtomicInteger updatesConfirmed = new AtomicInteger(0).     final AtomicReference<Throwable> exception = new AtomicReference<>().     FutureCallback<ResultSet> callback = new FutureCallback<ResultSet>() {          @Override         public void onSuccess(ResultSet resultSet) {             updatesConfirmed.incrementAndGet().             if (updatesCount.get() > 0) {                 // only set if all updates have been sent                 if (updatesCount.get() == updatesConfirmed.get()) {                     synchronized (updatesConfirmed) {                         updatesConfirmed.notifyAll().                     }                 }             }         }          @Override         public void onFailure(Throwable throwable) {             if (exception.compareAndSet(null, throwable)) {                 LOG.error("Error while sending value.", throwable).                 synchronized (updatesConfirmed) {                     updatesConfirmed.notifyAll().                 }             }         }     }.     // set values for prepared statement     int updatesSent = 0.     for (Row value : values) {         for (int x = 0. x < arity. x++) {             fields[x] = value.getField(x).         }         // insert values and send to cassandra         BoundStatement s = preparedStatement.bind(fields).         s.setDefaultTimestamp(timestamp).         ResultSetFuture result = session.executeAsync(s).         updatesSent++.         if (result != null) {             // add callback to detect errors             Futures.addCallback(result, callback).         }     }     updatesCount.set(updatesSent).     synchronized (updatesConfirmed) {         while (exception.get() == null && updatesSent != updatesConfirmed.get()) {             updatesConfirmed.wait().         }     }     if (exception.get() != null) {         LOG.warn("Sending a value failed.", exception.get()).         return false.     } else {         return true.     } }
