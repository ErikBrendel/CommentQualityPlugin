commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public ListenableFuture send(Object value) {     return null. }
false;protected;1;7;;@Override protected Cluster buildCluster(Cluster.Builder builder) {     return builder.addContactPoint("127.0.0.1").withoutJMXReporting().withoutMetrics().build(). }
false;public;0;19;;@Test(expected = NoHostAvailableException.class) public void testHostNotFoundErrorHandling() throws Exception {     CassandraSinkBase base = new CassandraSinkBase(new ClusterBuilder() {          @Override         protected Cluster buildCluster(Cluster.Builder builder) {             return builder.addContactPoint("127.0.0.1").withoutJMXReporting().withoutMetrics().build().         }     }, CassandraSinkBaseConfig.newBuilder().build(), new NoOpCassandraFailureHandler()) {          @Override         public ListenableFuture send(Object value) {             return null.         }     }.     base.open(new Configuration()). }
false;public;0;15;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testSuccessfulPath() throws Exception {     try (TestCassandraSink casSinkFunc = createOpenedTestCassandraSink()) {         casSinkFunc.enqueueCompletableFuture(CompletableFuture.completedFuture(null)).         final int originalPermits = casSinkFunc.getAvailablePermits().         Assert.assertThat(originalPermits, greaterThan(0)).         Assert.assertEquals(0, casSinkFunc.getAcquiredPermits()).         casSinkFunc.invoke("hello").         Assert.assertEquals(originalPermits, casSinkFunc.getAvailablePermits()).         Assert.assertEquals(0, casSinkFunc.getAcquiredPermits()).     } }
false;public;0;18;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testThrowErrorOnClose() throws Exception {     TestCassandraSink casSinkFunc = new TestCassandraSink().     casSinkFunc.open(new Configuration()).     Exception cause = new RuntimeException().     casSinkFunc.enqueueCompletableFuture(FutureUtils.getFailedFuture(cause)).     casSinkFunc.invoke("hello").     try {         casSinkFunc.close().         Assert.fail("Close should have thrown an exception.").     } catch (IOException e) {         ExceptionUtils.findThrowable(e, candidate -> candidate == cause).orElseThrow(() -> e).     } }
false;public;0;17;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testThrowErrorOnInvoke() throws Exception {     try (TestCassandraSink casSinkFunc = createOpenedTestCassandraSink()) {         Exception cause = new RuntimeException().         casSinkFunc.enqueueCompletableFuture(FutureUtils.getFailedFuture(cause)).         casSinkFunc.invoke("hello").         try {             casSinkFunc.invoke("world").             Assert.fail("Sending of second value should have failed.").         } catch (IOException e) {             Assert.assertEquals(cause, e.getCause()).             Assert.assertEquals(0, casSinkFunc.getAcquiredPermits()).         }     } }
false;public;0;14;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testIgnoreError() throws Exception {     Exception cause = new RuntimeException().     CassandraFailureHandler failureHandler = failure -> Assert.assertEquals(cause, failure).     try (TestCassandraSink casSinkFunc = createOpenedTestCassandraSink(failureHandler)) {         casSinkFunc.enqueueCompletableFuture(FutureUtils.getFailedFuture(cause)).         casSinkFunc.enqueueCompletableFuture(FutureUtils.getFailedFuture(cause)).         casSinkFunc.invoke("hello").         casSinkFunc.invoke("world").     } }
false;public;0;19;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testThrowErrorOnSnapshot() throws Exception {     TestCassandraSink casSinkFunc = new TestCassandraSink().     try (OneInputStreamOperatorTestHarness<String, Object> testHarness = createOpenedTestHarness(casSinkFunc)) {         Exception cause = new RuntimeException().         casSinkFunc.enqueueCompletableFuture(FutureUtils.getFailedFuture(cause)).         casSinkFunc.invoke("hello").         try {             testHarness.snapshot(123L, 123L).             Assert.fail().         } catch (Exception e) {             Assert.assertTrue(e.getCause() instanceof IOException).         }     } }
false;public;0;5;;@Override public void go() throws Exception {     testHarness.snapshot(123L, 123L).     latch.countDown(). }
false;public;0;30;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testWaitForPendingUpdatesOnSnapshot() throws Exception {     final TestCassandraSink casSinkFunc = new TestCassandraSink().     try (OneInputStreamOperatorTestHarness<String, Object> testHarness = createOpenedTestHarness(casSinkFunc)) {         CompletableFuture<ResultSet> completableFuture = new CompletableFuture<>().         casSinkFunc.enqueueCompletableFuture(completableFuture).         casSinkFunc.invoke("hello").         Assert.assertEquals(1, casSinkFunc.getAcquiredPermits()).         final CountDownLatch latch = new CountDownLatch(1).         Thread t = new CheckedThread("Flink-CassandraSinkBaseTest") {              @Override             public void go() throws Exception {                 testHarness.snapshot(123L, 123L).                 latch.countDown().             }         }.         t.start().         while (t.getState() != Thread.State.WAITING) {             Thread.sleep(5).         }         Assert.assertEquals(1, casSinkFunc.getAcquiredPermits()).         completableFuture.complete(null).         latch.await().         Assert.assertEquals(0, casSinkFunc.getAcquiredPermits()).     } }
false;public;0;5;;@Override public void go() throws Exception {     testHarness.close().     latch.countDown(). }
false;public;0;31;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testWaitForPendingUpdatesOnClose() throws Exception {     TestCassandraSink casSinkFunc = new TestCassandraSink().     try (OneInputStreamOperatorTestHarness<String, Object> testHarness = createOpenedTestHarness(casSinkFunc)) {         CompletableFuture<ResultSet> completableFuture = new CompletableFuture<>().         casSinkFunc.enqueueCompletableFuture(completableFuture).         casSinkFunc.invoke("hello").         Assert.assertEquals(1, casSinkFunc.getAcquiredPermits()).         final CountDownLatch latch = new CountDownLatch(1).         Thread t = new CheckedThread("Flink-CassandraSinkBaseTest") {              @Override             public void go() throws Exception {                 testHarness.close().                 latch.countDown().             }         }.         t.start().         while (t.getState() != Thread.State.WAITING) {             Thread.sleep(5).         }         Assert.assertEquals(1, casSinkFunc.getAcquiredPermits()).         completableFuture.complete(null).         latch.await().         Assert.assertEquals(0, casSinkFunc.getAcquiredPermits()).     } }
false;public;0;23;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testReleaseOnSuccess() throws Exception {     final CassandraSinkBaseConfig config = CassandraSinkBaseConfig.newBuilder().setMaxConcurrentRequests(1).build().     try (TestCassandraSink testCassandraSink = createOpenedTestCassandraSink(config)) {         Assert.assertEquals(1, testCassandraSink.getAvailablePermits()).         Assert.assertEquals(0, testCassandraSink.getAcquiredPermits()).         CompletableFuture<ResultSet> completableFuture = new CompletableFuture<>().         testCassandraSink.enqueueCompletableFuture(completableFuture).         testCassandraSink.invoke("N/A").         Assert.assertEquals(0, testCassandraSink.getAvailablePermits()).         Assert.assertEquals(1, testCassandraSink.getAcquiredPermits()).         completableFuture.complete(null).         Assert.assertEquals(1, testCassandraSink.getAvailablePermits()).         Assert.assertEquals(0, testCassandraSink.getAcquiredPermits()).     } }
false;public;0;24;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testReleaseOnFailure() throws Exception {     final CassandraSinkBaseConfig config = CassandraSinkBaseConfig.newBuilder().setMaxConcurrentRequests(1).build().     final CassandraFailureHandler failureHandler = ignored -> {     }.     try (TestCassandraSink testCassandraSink = createOpenedTestCassandraSink(config, failureHandler)) {         Assert.assertEquals(1, testCassandraSink.getAvailablePermits()).         Assert.assertEquals(0, testCassandraSink.getAcquiredPermits()).         CompletableFuture<ResultSet> completableFuture = new CompletableFuture<>().         testCassandraSink.enqueueCompletableFuture(completableFuture).         testCassandraSink.invoke("N/A").         Assert.assertEquals(0, testCassandraSink.getAvailablePermits()).         Assert.assertEquals(1, testCassandraSink.getAcquiredPermits()).         completableFuture.completeExceptionally(new RuntimeException()).         Assert.assertEquals(1, testCassandraSink.getAvailablePermits()).         Assert.assertEquals(0, testCassandraSink.getAcquiredPermits()).     } }
false;public;0;23;;@Test(timeout = DEFAULT_TEST_TIMEOUT) public void testTimeoutExceptionOnInvoke() throws Exception {     final CassandraSinkBaseConfig config = CassandraSinkBaseConfig.newBuilder().setMaxConcurrentRequests(1).setMaxConcurrentRequestsTimeout(Duration.ofMillis(1)).build().     try (TestCassandraSink testCassandraSink = createOpenedTestCassandraSink(config)) {         CompletableFuture<ResultSet> completableFuture = new CompletableFuture<>().         testCassandraSink.enqueueCompletableFuture(completableFuture).         testCassandraSink.enqueueCompletableFuture(completableFuture).         testCassandraSink.invoke("Invoke #1").         try {             testCassandraSink.invoke("Invoke #2").             Assert.fail("Sending value should have experienced a TimeoutException").         } catch (Exception e) {             Assert.assertTrue(e instanceof TimeoutException).         } finally {             completableFuture.complete(null).         }     } }
false;private;0;5;;private TestCassandraSink createOpenedTestCassandraSink() {     final TestCassandraSink testCassandraSink = new TestCassandraSink().     testCassandraSink.open(new Configuration()).     return testCassandraSink. }
false;private;1;5;;private TestCassandraSink createOpenedTestCassandraSink(CassandraFailureHandler failureHandler) {     final TestCassandraSink testCassandraSink = new TestCassandraSink(failureHandler).     testCassandraSink.open(new Configuration()).     return testCassandraSink. }
false;private;1;5;;private TestCassandraSink createOpenedTestCassandraSink(CassandraSinkBaseConfig config) {     final TestCassandraSink testCassandraSink = new TestCassandraSink(config).     testCassandraSink.open(new Configuration()).     return testCassandraSink. }
false;private;2;7;;private TestCassandraSink createOpenedTestCassandraSink(CassandraSinkBaseConfig config, CassandraFailureHandler failureHandler) {     final TestCassandraSink testCassandraSink = new TestCassandraSink(config, failureHandler).     testCassandraSink.open(new Configuration()).     return testCassandraSink. }
false;private;1;8;;private OneInputStreamOperatorTestHarness<String, Object> createOpenedTestHarness(TestCassandraSink testCassandraSink) throws Exception {     final StreamSink<String> testStreamSink = new StreamSink<>(testCassandraSink).     final OneInputStreamOperatorTestHarness<String, Object> testHarness = new OneInputStreamOperatorTestHarness<>(testStreamSink).     testHarness.open().     return testHarness. }
false;protected;1;4;;@Override protected Cluster buildCluster(Cluster.Builder builder) {     return cluster. }
false;public;1;4;;@Override public ListenableFuture<ResultSet> send(String value) {     return resultSetFutures.poll(). }
false;;1;4;;void enqueueCompletableFuture(CompletableFuture<ResultSet> completableFuture) {     Preconditions.checkNotNull(completableFuture).     resultSetFutures.offer(ResultSetFutures.fromCompletableFuture(completableFuture)). }
