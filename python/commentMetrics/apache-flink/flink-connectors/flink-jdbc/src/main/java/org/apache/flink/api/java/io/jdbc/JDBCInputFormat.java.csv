commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public RowTypeInfo getProducedType() {     return rowTypeInfo. }
false;public;1;4;;@Override public void configure(Configuration parameters) { // do nothing here }
false;public;0;20;;@Override public void openInputFormat() {     // called once per inputFormat (on open)     try {         Class.forName(drivername).         if (username == null) {             dbConn = DriverManager.getConnection(dbURL).         } else {             dbConn = DriverManager.getConnection(dbURL, username, password).         }         statement = dbConn.prepareStatement(queryTemplate, resultSetType, resultSetConcurrency).         if (fetchSize == Integer.MIN_VALUE || fetchSize > 0) {             statement.setFetchSize(fetchSize).         }     } catch (SQLException se) {         throw new IllegalArgumentException("open() failed." + se.getMessage(), se).     } catch (ClassNotFoundException cnfe) {         throw new IllegalArgumentException("JDBC-Class not found. - " + cnfe.getMessage(), cnfe).     } }
false;public;0;25;;@Override public void closeInputFormat() {     // called once per inputFormat (on close)     try {         if (statement != null) {             statement.close().         }     } catch (SQLException se) {         LOG.info("Inputformat Statement couldn't be closed - " + se.getMessage()).     } finally {         statement = null.     }     try {         if (dbConn != null) {             dbConn.close().         }     } catch (SQLException se) {         LOG.info("Inputformat couldn't be closed - " + se.getMessage()).     } finally {         dbConn = null.     }     parameterValues = null. }
true;public;1;47;/**  * Connects to the source database and executes the query in a <b>parallel  * fashion</b> if  * this {@link InputFormat} is built using a parameterized query (i.e. using  * a {@link PreparedStatement})  * and a proper {@link ParameterValuesProvider}, in a <b>non-parallel  * fashion</b> otherwise.  *  * @param inputSplit which is ignored if this InputFormat is executed as a  *        non-parallel source,  *        a "hook" to the query parameters otherwise (using its  *        <i>splitNumber</i>)  * @throws IOException if there's an error during the execution of the query  */ ;/**  * Connects to the source database and executes the query in a <b>parallel  * fashion</b> if  * this {@link InputFormat} is built using a parameterized query (i.e. using  * a {@link PreparedStatement})  * and a proper {@link ParameterValuesProvider}, in a <b>non-parallel  * fashion</b> otherwise.  *  * @param inputSplit which is ignored if this InputFormat is executed as a  *        non-parallel source,  *        a "hook" to the query parameters otherwise (using its  *        <i>splitNumber</i>)  * @throws IOException if there's an error during the execution of the query  */ @Override public void open(InputSplit inputSplit) throws IOException {     try {         if (inputSplit != null && parameterValues != null) {             for (int i = 0. i < parameterValues[inputSplit.getSplitNumber()].length. i++) {                 Object param = parameterValues[inputSplit.getSplitNumber()][i].                 if (param instanceof String) {                     statement.setString(i + 1, (String) param).                 } else if (param instanceof Long) {                     statement.setLong(i + 1, (Long) param).                 } else if (param instanceof Integer) {                     statement.setInt(i + 1, (Integer) param).                 } else if (param instanceof Double) {                     statement.setDouble(i + 1, (Double) param).                 } else if (param instanceof Boolean) {                     statement.setBoolean(i + 1, (Boolean) param).                 } else if (param instanceof Float) {                     statement.setFloat(i + 1, (Float) param).                 } else if (param instanceof BigDecimal) {                     statement.setBigDecimal(i + 1, (BigDecimal) param).                 } else if (param instanceof Byte) {                     statement.setByte(i + 1, (Byte) param).                 } else if (param instanceof Short) {                     statement.setShort(i + 1, (Short) param).                 } else if (param instanceof Date) {                     statement.setDate(i + 1, (Date) param).                 } else if (param instanceof Time) {                     statement.setTime(i + 1, (Time) param).                 } else if (param instanceof Timestamp) {                     statement.setTimestamp(i + 1, (Timestamp) param).                 } else if (param instanceof Array) {                     statement.setArray(i + 1, (Array) param).                 } else {                     // extends with other types if needed                     throw new IllegalArgumentException("open() failed. Parameter " + i + " of type " + param.getClass() + " is not handled (yet).").                 }             }             if (LOG.isDebugEnabled()) {                 LOG.debug(String.format("Executing '%s' with parameters %s", queryTemplate, Arrays.deepToString(parameterValues[inputSplit.getSplitNumber()]))).             }         }         resultSet = statement.executeQuery().         hasNext = resultSet.next().     } catch (SQLException se) {         throw new IllegalArgumentException("open() failed." + se.getMessage(), se).     } }
true;public;0;11;/**  * Closes all resources used.  *  * @throws IOException Indicates that a resource could not be closed.  */ ;/**  * Closes all resources used.  *  * @throws IOException Indicates that a resource could not be closed.  */ @Override public void close() throws IOException {     if (resultSet == null) {         return.     }     try {         resultSet.close().     } catch (SQLException se) {         LOG.info("Inputformat ResultSet couldn't be closed - " + se.getMessage()).     } }
true;public;0;4;/**  * Checks whether all data has been read.  *  * @return boolean value indication whether all data has been read.  * @throws IOException  */ ;/**  * Checks whether all data has been read.  *  * @return boolean value indication whether all data has been read.  * @throws IOException  */ @Override public boolean reachedEnd() throws IOException {     return !hasNext. }
true;public;1;18;/**  * Stores the next resultSet row in a tuple.  *  * @param row row to be reused.  * @return row containing next {@link Row}  * @throws java.io.IOException  */ ;/**  * Stores the next resultSet row in a tuple.  *  * @param row row to be reused.  * @return row containing next {@link Row}  * @throws java.io.IOException  */ @Override public Row nextRecord(Row row) throws IOException {     try {         if (!hasNext) {             return null.         }         for (int pos = 0. pos < row.getArity(). pos++) {             row.setField(pos, resultSet.getObject(pos + 1)).         }         // update hasNext after we've read the record         hasNext = resultSet.next().         return row.     } catch (SQLException se) {         throw new IOException("Couldn't read data - " + se.getMessage(), se).     } catch (NullPointerException npe) {         throw new IOException("Couldn't access resultSet", npe).     } }
false;public;1;4;;@Override public BaseStatistics getStatistics(BaseStatistics cachedStatistics) throws IOException {     return cachedStatistics. }
false;public;1;11;;@Override public InputSplit[] createInputSplits(int minNumSplits) throws IOException {     if (parameterValues == null) {         return new GenericInputSplit[] { new GenericInputSplit(0, 1) }.     }     GenericInputSplit[] ret = new GenericInputSplit[parameterValues.length].     for (int i = 0. i < ret.length. i++) {         ret[i] = new GenericInputSplit(i, ret.length).     }     return ret. }
false;public;1;4;;@Override public InputSplitAssigner getInputSplitAssigner(InputSplit[] inputSplits) {     return new DefaultInputSplitAssigner(inputSplits). }
false;;0;4;;@VisibleForTesting PreparedStatement getStatement() {     return statement. }
true;public,static;0;3;/**  * A builder used to set parameters to the output format's configuration in a fluent way.  * @return builder  */ ;/**  * A builder used to set parameters to the output format's configuration in a fluent way.  * @return builder  */ public static JDBCInputFormatBuilder buildJDBCInputFormat() {     return new JDBCInputFormatBuilder(). }
false;public;1;4;;public JDBCInputFormatBuilder setUsername(String username) {     format.username = username.     return this. }
false;public;1;4;;public JDBCInputFormatBuilder setPassword(String password) {     format.password = password.     return this. }
false;public;1;4;;public JDBCInputFormatBuilder setDrivername(String drivername) {     format.drivername = drivername.     return this. }
false;public;1;4;;public JDBCInputFormatBuilder setDBUrl(String dbURL) {     format.dbURL = dbURL.     return this. }
false;public;1;4;;public JDBCInputFormatBuilder setQuery(String query) {     format.queryTemplate = query.     return this. }
false;public;1;4;;public JDBCInputFormatBuilder setResultSetType(int resultSetType) {     format.resultSetType = resultSetType.     return this. }
false;public;1;4;;public JDBCInputFormatBuilder setResultSetConcurrency(int resultSetConcurrency) {     format.resultSetConcurrency = resultSetConcurrency.     return this. }
false;public;1;4;;public JDBCInputFormatBuilder setParametersProvider(ParameterValuesProvider parameterValuesProvider) {     format.parameterValues = parameterValuesProvider.getParameterValues().     return this. }
false;public;1;4;;public JDBCInputFormatBuilder setRowTypeInfo(RowTypeInfo rowTypeInfo) {     format.rowTypeInfo = rowTypeInfo.     return this. }
false;public;1;6;;public JDBCInputFormatBuilder setFetchSize(int fetchSize) {     Preconditions.checkArgument(fetchSize == Integer.MIN_VALUE || fetchSize > 0, "Illegal value %s for fetchSize, has to be positive or Integer.MIN_VALUE.", fetchSize).     format.fetchSize = fetchSize.     return this. }
false;public;0;24;;public JDBCInputFormat finish() {     if (format.username == null) {         LOG.info("Username was not supplied separately.").     }     if (format.password == null) {         LOG.info("Password was not supplied separately.").     }     if (format.dbURL == null) {         throw new IllegalArgumentException("No database URL supplied").     }     if (format.queryTemplate == null) {         throw new IllegalArgumentException("No query supplied").     }     if (format.drivername == null) {         throw new IllegalArgumentException("No driver supplied").     }     if (format.rowTypeInfo == null) {         throw new IllegalArgumentException("No " + RowTypeInfo.class.getSimpleName() + " supplied").     }     if (format.parameterValues == null) {         LOG.debug("No input splitting configured (data will be read with parallelism 1).").     }     return format. }
