commented;modifiers;parameterAmount;loc;comment;code
false;public;0;24;;@Test public void testAppendTableSink() throws IOException {     JDBCAppendTableSink sink = JDBCAppendTableSink.builder().setDrivername("foo").setDBUrl("bar").setQuery("insert into %s (id) values (?)").setParameterTypes(FIELD_TYPES).build().     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     DataStream<Row> ds = env.fromCollection(Collections.singleton(Row.of("foo")), ROW_TYPE).     sink.emitDataStream(ds).     Collection<Integer> sinkIds = env.getStreamGraph().getSinkIDs().     assertEquals(1, sinkIds.size()).     int sinkId = sinkIds.iterator().next().     StreamSink planSink = (StreamSink) env.getStreamGraph().getStreamNode(sinkId).getOperator().     assertTrue(planSink.getUserFunction() instanceof JDBCSinkFunction).     JDBCSinkFunction sinkFunction = (JDBCSinkFunction) planSink.getUserFunction().     assertSame(sink.getOutputFormat(), sinkFunction.outputFormat). }
false;public;0;14;;@Test(expected = IllegalArgumentException.class) public void testTypeCompatibilityCheck() throws IOException {     JDBCAppendTableSink sink = JDBCAppendTableSink.builder().setDrivername("foo").setDBUrl("bar").setQuery("INSERT INTO foobar (id) VALUES (?)").setParameterTypes(Types.LONG, Types.STRING, Types.INT).build().     sink.configure(new String[] { "Hello" }, new TypeInformation<?>[] { Types.STRING, Types.INT, Types.LONG }). }
