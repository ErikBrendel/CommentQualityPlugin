commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected void initializeConnections() {     URL contactUrl = NetUtils.getCorrectHostnamePort(seedBrokerAddresses[currentContactSeedBrokerIndex]).     this.consumer = new SimpleConsumer(contactUrl.getHost(), contactUrl.getPort(), soTimeout, bufferSize, dummyClientId). }
false;protected;0;47;;@Override protected List<String> getAllTopics() {     List<String> topics = new LinkedList<>().     retryLoop: for (int retry = 0. retry < numRetries. retry++) {         brokersLoop: for (int arrIdx = 0. arrIdx < seedBrokerAddresses.length. arrIdx++) {             LOG.info("Trying to get topic metadata from broker {} in try {}/{}", seedBrokerAddresses[currentContactSeedBrokerIndex], retry, numRetries).             try {                 // clear in case we have an incomplete list from previous tries                 topics.clear().                 for (TopicMetadata item : consumer.send(new TopicMetadataRequest(Collections.<String>emptyList())).topicsMetadata()) {                     if (item.errorCode() != ErrorMapping.NoError()) {                         // warn and try more brokers                         LOG.warn("Error while getting metadata from broker {} to find partitions for {}. Error: {}.", seedBrokerAddresses[currentContactSeedBrokerIndex], topics.toString(), ErrorMapping.exceptionFor(item.errorCode()).getMessage()).                         useNextAddressAsNewContactSeedBroker().                         continue brokersLoop.                     }                     topics.add(item.topic()).                 }                 // leave the loop through the brokers                 break retryLoop.             } catch (Exception e) {                 // validates seed brokers in case of a ClosedChannelException                 validateSeedBrokers(seedBrokerAddresses, e).                 LOG.warn("Error communicating with broker {} to find partitions for {}. {} Message: {}", seedBrokerAddresses[currentContactSeedBrokerIndex], topics, e.getClass().getName(), e.getMessage()).                 LOG.debug("Detailed trace", e).                 // we sleep a bit. Retrying immediately doesn't make sense in cases where Kafka is reorganizing the leader metadata                 try {                     Thread.sleep(500).                 } catch (InterruptedException e1) {                 // sleep shorter.                 }                 useNextAddressAsNewContactSeedBroker().             }         }     // brokers loop     }     return topics. }
false;public;1;4;;@Override public List<KafkaTopicPartition> getAllPartitionsForTopics(List<String> topics) {     return KafkaTopicPartition.dropLeaderData(getPartitionLeadersForTopics(topics)). }
false;protected;0;4;;@Override protected void wakeupConnections() { // nothing to do, as Kafka 0.8's SimpleConsumer does not support wakeup }
false;protected;0;10;;@Override protected void closeConnections() throws Exception {     if (consumer != null) {         SimpleConsumer consumer = this.consumer.         consumer.close().         // de-reference the consumer to avoid closing multiple times         this.consumer = null.     } }
true;public;1;58;/**  * Send request to Kafka to get partitions for topics.  *  * @param topics The name of the topics.  */ ;/**  * Send request to Kafka to get partitions for topics.  *  * @param topics The name of the topics.  */ public List<KafkaTopicPartitionLeader> getPartitionLeadersForTopics(List<String> topics) {     List<KafkaTopicPartitionLeader> partitions = new LinkedList<>().     retryLoop: for (int retry = 0. retry < numRetries. retry++) {         brokersLoop: for (int arrIdx = 0. arrIdx < seedBrokerAddresses.length. arrIdx++) {             LOG.info("Trying to get topic metadata from broker {} in try {}/{}", seedBrokerAddresses[currentContactSeedBrokerIndex], retry, numRetries).             try {                 // clear in case we have an incomplete list from previous tries                 partitions.clear().                 for (TopicMetadata item : consumer.send(new TopicMetadataRequest(topics)).topicsMetadata()) {                     if (item.errorCode() != ErrorMapping.NoError()) {                         // warn and try more brokers                         LOG.warn("Error while getting metadata from broker {} to find partitions for {}. Error: {}.", seedBrokerAddresses[currentContactSeedBrokerIndex], topics.toString(), ErrorMapping.exceptionFor(item.errorCode()).getMessage()).                         useNextAddressAsNewContactSeedBroker().                         continue brokersLoop.                     }                     if (!topics.contains(item.topic())) {                         LOG.warn("Received metadata from topic " + item.topic() + " even though it was not requested. Skipping ...").                         useNextAddressAsNewContactSeedBroker().                         continue brokersLoop.                     }                     for (PartitionMetadata part : item.partitionsMetadata()) {                         Node leader = brokerToNode(part.leader()).                         KafkaTopicPartition ktp = new KafkaTopicPartition(item.topic(), part.partitionId()).                         KafkaTopicPartitionLeader pInfo = new KafkaTopicPartitionLeader(ktp, leader).                         partitions.add(pInfo).                     }                 }                 // leave the loop through the brokers                 break retryLoop.             } catch (Exception e) {                 // validates seed brokers in case of a ClosedChannelException                 validateSeedBrokers(seedBrokerAddresses, e).                 LOG.warn("Error communicating with broker {} to find partitions for {}. {} Message: {}", seedBrokerAddresses[currentContactSeedBrokerIndex], topics, e.getClass().getName(), e.getMessage()).                 LOG.debug("Detailed trace", e).                 // we sleep a bit. Retrying immediately doesn't make sense in cases where Kafka is reorganizing the leader metadata                 try {                     Thread.sleep(500).                 } catch (InterruptedException e1) {                 // sleep shorter.                 }                 useNextAddressAsNewContactSeedBroker().             }         }     // brokers loop     }     return partitions. }
true;private;0;8;/**  * Re-establish broker connection using the next available seed broker address.  */ ;/**  * Re-establish broker connection using the next available seed broker address.  */ private void useNextAddressAsNewContactSeedBroker() {     if (++currentContactSeedBrokerIndex == seedBrokerAddresses.length) {         currentContactSeedBrokerIndex = 0.     }     URL newContactUrl = NetUtils.getCorrectHostnamePort(seedBrokerAddresses[currentContactSeedBrokerIndex]).     this.consumer = new SimpleConsumer(newContactUrl.getHost(), newContactUrl.getPort(), soTimeout, bufferSize, dummyClientId). }
true;private,static;1;3;/**  * Turn a broker instance into a node instance.  *  * @param broker broker instance  * @return Node representing the given broker  */ ;/**  * Turn a broker instance into a node instance.  *  * @param broker broker instance  * @return Node representing the given broker  */ private static Node brokerToNode(Broker broker) {     return new Node(broker.id(), broker.host(), broker.port()). }
true;private,static;2;19;/**  * Validate that at least one seed broker is valid in case of a  * ClosedChannelException.  *  * @param seedBrokers  *            array containing the seed brokers e.g. ["host1:port1",  *            "host2:port2"]  * @param exception  *            instance  */ ;/**  * Validate that at least one seed broker is valid in case of a  * ClosedChannelException.  *  * @param seedBrokers  *            array containing the seed brokers e.g. ["host1:port1",  *            "host2:port2"]  * @param exception  *            instance  */ private static void validateSeedBrokers(String[] seedBrokers, Exception exception) {     if (!(exception instanceof ClosedChannelException)) {         return.     }     int unknownHosts = 0.     for (String broker : seedBrokers) {         URL brokerUrl = NetUtils.getCorrectHostnamePort(broker.trim()).         try {             InetAddress.getByName(brokerUrl.getHost()).         } catch (UnknownHostException e) {             unknownHosts++.         }     }     // throw meaningful exception if all the provided hosts are invalid     if (unknownHosts == seedBrokers.length) {         throw new IllegalArgumentException("All the servers provided in: '" + ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + "' config are invalid. (unknown hosts)").     } }
