# id;timestamp;commentText;codeText;commentWords;codeWords
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1487173364;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1488214488;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1495923077;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1498894422;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1501249950;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1501249950;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1509597235;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1515757408;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1515757409;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1517943538;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1520598638;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static long getInvalidOffsetBehavior(Properties config);1550834396;Retrieve the behaviour of "auto.offset.reset" from the config properties._A partition needs to fallback to "auto.offset.reset" as default offset when_we can't find offsets in ZK to start from in {@link StartupMode#GROUP_OFFSETS} startup mode.__@param config kafka consumer properties_@return either OffsetRequest.LatestTime() or OffsetRequest.EarliestTime();private static long getInvalidOffsetBehavior(Properties config) {_		final String val = config.getProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "largest")__		if (val.equals("largest") || val.equals("latest")) { _			return OffsetRequest.LatestTime()__		} else {_			return OffsetRequest.EarliestTime()__		}_	};retrieve,the,behaviour,of,auto,offset,reset,from,the,config,properties,a,partition,needs,to,fallback,to,auto,offset,reset,as,default,offset,when,we,can,t,find,offsets,in,zk,to,start,from,in,link,startup,mode,startup,mode,param,config,kafka,consumer,properties,return,either,offset,request,latest,time,or,offset,request,earliest,time;private,static,long,get,invalid,offset,behavior,properties,config,final,string,val,config,get,property,consumer,config,largest,if,val,equals,largest,val,equals,latest,return,offset,request,latest,time,else,return,offset,request,earliest,time
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1480685315;Returns a list of unique topics from for the given partitions__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1485274811;Returns a list of unique topics from for the given partitions__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1487173364;Returns a list of unique topics from for the given partitions__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1488214488;Returns a list of unique topics from for the given partitions__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1495923077;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1498894422;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1501249950;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1501249950;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1509597235;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1515757408;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1515757409;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1517943538;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1520598638;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions);1550834396;Returns a list of unique topics from for the given partitions.__@param partitions A the partitions_@return A list of unique topics;private static List<String> getTopics(List<KafkaTopicPartitionState<TopicAndPartition>> partitions) {_		HashSet<String> uniqueTopics = new HashSet<>()__		for (KafkaTopicPartitionState<TopicAndPartition> fp: partitions) {_			uniqueTopics.add(fp.getTopic())__		}_		return new ArrayList<>(uniqueTopics)__	};returns,a,list,of,unique,topics,from,for,the,given,partitions,param,partitions,a,the,partitions,return,a,list,of,unique,topics;private,static,list,string,get,topics,list,kafka,topic,partition,state,topic,and,partition,partitions,hash,set,string,unique,topics,new,hash,set,for,kafka,topic,partition,state,topic,and,partition,fp,partitions,unique,topics,add,fp,get,topic,return,new,array,list,unique,topics
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1480685315;Find leaders for the partitions__From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map<Leader, List<FetchPartition>> where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception_	{_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)__		_		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for(KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,leader,list,fetch,partition,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1485274811;Find leaders for the partitions__From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map<Leader, List<FetchPartition>> where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception_	{_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)__		_		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for(KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,leader,list,fetch,partition,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1487173364;Find leaders for the partitions__From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map<Leader, List<FetchPartition>> where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception_	{_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)__		_		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for(KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,leader,list,fetch,partition,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1488214488;Find leaders for the partitions__From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map<Leader, List<FetchPartition>> where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception_	{_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)__		_		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for(KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,leader,list,fetch,partition,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1495923077;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1498894422;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1501249950;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1501249950;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1509597235;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1515757408;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1515757409;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1517943538;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1520598638;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
Kafka08Fetcher -> private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions( 			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign, 			Properties kafkaProperties) throws Exception;1550834396;Find leaders for the partitions.__<p>From a high level, the method does the following:_- Get a list of FetchPartitions (usually only a few partitions)_- Get the list of topics from the FetchPartitions list and request the partitions for the topics. (Kafka doesn't support getting leaders for a set of partitions)_- Build a Map&lt_Leader, List&lt_FetchPartition&gt_&gt_ where only the requested partitions are contained.__@param partitionsToAssign fetch partitions list_@return leader to partitions map;private static Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> findLeaderForPartitions(_			List<KafkaTopicPartitionState<TopicAndPartition>> partitionsToAssign,_			Properties kafkaProperties) throws Exception {_		if (partitionsToAssign.isEmpty()) {_			throw new IllegalArgumentException("Leader request for empty partitions list")__		}__		LOG.info("Refreshing leader information for partitions {}", partitionsToAssign)___		_		PartitionInfoFetcher infoFetcher = new PartitionInfoFetcher(getTopics(partitionsToAssign), kafkaProperties)__		infoFetcher.start()___		_		_		_		_		KillerWatchDog watchDog = new KillerWatchDog(infoFetcher, 60000)__		watchDog.start()___		_		List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList = infoFetcher.getPartitions()___		_		List<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitions = new ArrayList<>(partitionsToAssign)___		_		Map<Node, List<KafkaTopicPartitionState<TopicAndPartition>>> leaderToPartitions = new HashMap<>()___		for (KafkaTopicPartitionLeader partitionLeader: topicPartitionWithLeaderList) {_			if (unassignedPartitions.size() == 0) {_				_				break__			}__			Iterator<KafkaTopicPartitionState<TopicAndPartition>> unassignedPartitionsIterator = unassignedPartitions.iterator()__			while (unassignedPartitionsIterator.hasNext()) {_				KafkaTopicPartitionState<TopicAndPartition> unassignedPartition = unassignedPartitionsIterator.next()___				if (unassignedPartition.getKafkaTopicPartition().equals(partitionLeader.getTopicPartition())) {_					_					Node leader = partitionLeader.getLeader()___					List<KafkaTopicPartitionState<TopicAndPartition>> partitionsOfLeader = leaderToPartitions.get(leader)__					if (partitionsOfLeader == null) {_						partitionsOfLeader = new ArrayList<>()__						leaderToPartitions.put(leader, partitionsOfLeader)__					}_					partitionsOfLeader.add(unassignedPartition)__					unassignedPartitionsIterator.remove()_ _					break__				}_			}_		}__		if (unassignedPartitions.size() > 0) {_			throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions)__		}__		LOG.debug("Partitions with assigned leaders {}", leaderToPartitions)___		return leaderToPartitions__	};find,leaders,for,the,partitions,p,from,a,high,level,the,method,does,the,following,get,a,list,of,fetch,partitions,usually,only,a,few,partitions,get,the,list,of,topics,from,the,fetch,partitions,list,and,request,the,partitions,for,the,topics,kafka,doesn,t,support,getting,leaders,for,a,set,of,partitions,build,a,map,lt,leader,list,lt,fetch,partition,gt,gt,where,only,the,requested,partitions,are,contained,param,partitions,to,assign,fetch,partitions,list,return,leader,to,partitions,map;private,static,map,node,list,kafka,topic,partition,state,topic,and,partition,find,leader,for,partitions,list,kafka,topic,partition,state,topic,and,partition,partitions,to,assign,properties,kafka,properties,throws,exception,if,partitions,to,assign,is,empty,throw,new,illegal,argument,exception,leader,request,for,empty,partitions,list,log,info,refreshing,leader,information,for,partitions,partitions,to,assign,partition,info,fetcher,info,fetcher,new,partition,info,fetcher,get,topics,partitions,to,assign,kafka,properties,info,fetcher,start,killer,watch,dog,watch,dog,new,killer,watch,dog,info,fetcher,60000,watch,dog,start,list,kafka,topic,partition,leader,topic,partition,with,leader,list,info,fetcher,get,partitions,list,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,new,array,list,partitions,to,assign,map,node,list,kafka,topic,partition,state,topic,and,partition,leader,to,partitions,new,hash,map,for,kafka,topic,partition,leader,partition,leader,topic,partition,with,leader,list,if,unassigned,partitions,size,0,break,iterator,kafka,topic,partition,state,topic,and,partition,unassigned,partitions,iterator,unassigned,partitions,iterator,while,unassigned,partitions,iterator,has,next,kafka,topic,partition,state,topic,and,partition,unassigned,partition,unassigned,partitions,iterator,next,if,unassigned,partition,get,kafka,topic,partition,equals,partition,leader,get,topic,partition,node,leader,partition,leader,get,leader,list,kafka,topic,partition,state,topic,and,partition,partitions,of,leader,leader,to,partitions,get,leader,if,partitions,of,leader,null,partitions,of,leader,new,array,list,leader,to,partitions,put,leader,partitions,of,leader,partitions,of,leader,add,unassigned,partition,unassigned,partitions,iterator,remove,break,if,unassigned,partitions,size,0,throw,new,runtime,exception,unable,to,find,a,leader,for,partitions,unassigned,partitions,log,debug,partitions,with,assigned,leaders,leader,to,partitions,return,leader,to,partitions
