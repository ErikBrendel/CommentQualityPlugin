commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;5;/**  * Sets up the queue. The default implementation just declares the queue. The user may override  * this method to have a custom setup for the queue (i.e. binding the queue to an exchange or  * defining custom queue parameters)  */ ;/**  * Sets up the queue. The default implementation just declares the queue. The user may override  * this method to have a custom setup for the queue (i.e. binding the queue to an exchange or  * defining custom queue parameters)  */ protected void setupQueue() throws IOException {     if (queueName != null) {         channel.queueDeclare(queueName, false, false, false, null).     } }
true;public;1;3;/**  * Defines whether the producer should fail on errors, or only log them.  * If this is set to true, then exceptions will be only logged, if set to false,  * exceptions will be eventually thrown and cause the streaming program to  * fail (and enter recovery).  *  * @param logFailuresOnly The flag to indicate logging-only on exceptions.  */ ;/**  * Defines whether the producer should fail on errors, or only log them.  * If this is set to true, then exceptions will be only logged, if set to false,  * exceptions will be eventually thrown and cause the streaming program to  * fail (and enter recovery).  *  * @param logFailuresOnly The flag to indicate logging-only on exceptions.  */ public void setLogFailuresOnly(boolean logFailuresOnly) {     this.logFailuresOnly = logFailuresOnly. }
false;public;1;17;;@Override public void open(Configuration config) throws Exception {     ConnectionFactory factory = rmqConnectionConfig.getConnectionFactory().     try {         connection = factory.newConnection().         channel = connection.createChannel().         if (channel == null) {             throw new RuntimeException("None of RabbitMQ channels are available").         }         setupQueue().         if (returnListener != null) {             channel.addReturnListener(returnListener).         }     } catch (IOException e) {         throw new RuntimeException("Error while creating the channel", e).     } }
true;public;1;29;/**  * Called when new data arrives to the sink, and forwards it to RMQ.  *  * @param value  *            The incoming data  */ ;/**  * Called when new data arrives to the sink, and forwards it to RMQ.  *  * @param value  *            The incoming data  */ @Override public void invoke(IN value) {     try {         byte[] msg = schema.serialize(value).         if (publishOptions == null) {             channel.basicPublish("", queueName, null, msg).         } else {             boolean mandatory = publishOptions.computeMandatory(value).             boolean immediate = publishOptions.computeImmediate(value).             Preconditions.checkState(!(returnListener == null && (mandatory || immediate)), "Setting mandatory and/or immediate flags to true requires a ReturnListener.").             String rk = publishOptions.computeRoutingKey(value).             String exchange = publishOptions.computeExchange(value).             channel.basicPublish(exchange, rk, mandatory, immediate, publishOptions.computeProperties(value), msg).         }     } catch (IOException e) {         if (logFailuresOnly) {             LOG.error("Cannot send RMQ message {} at {}", queueName, rmqConnectionConfig.getHost(), e).         } else {             throw new RuntimeException("Cannot send RMQ message " + queueName + " at " + rmqConnectionConfig.getHost(), e).         }     } }
false;public;0;26;;@Override public void close() {     Exception t = null.     try {         if (channel != null) {             channel.close().         }     } catch (IOException | TimeoutException e) {         t = e.     }     try {         if (connection != null) {             connection.close().         }     } catch (IOException e) {         if (t != null) {             LOG.warn("Both channel and connection closing failed. Logging channel exception and failing with connection exception", t).         }         t = e.     }     if (t != null) {         throw new RuntimeException("Error while closing RMQ connection with " + queueName + " at " + rmqConnectionConfig.getHost(), t).     } }
