commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;3;/**  * Initializes the connection to RMQ with a default connection factory. The user may override  * this method to setup and configure their own ConnectionFactory.  */ ;/**  * Initializes the connection to RMQ with a default connection factory. The user may override  * this method to setup and configure their own ConnectionFactory.  */ protected ConnectionFactory setupConnectionFactory() throws Exception {     return rmqConnectionConfig.getConnectionFactory(). }
true;protected;0;3;/**  * Sets up the queue. The default implementation just declares the queue. The user may override  * this method to have a custom setup for the queue (i.e. binding the queue to an exchange or  * defining custom queue parameters)  */ ;/**  * Sets up the queue. The default implementation just declares the queue. The user may override  * this method to have a custom setup for the queue (i.e. binding the queue to an exchange or  * defining custom queue parameters)  */ protected void setupQueue() throws IOException {     channel.queueDeclare(queueName, true, false, false, null). }
false;public;1;32;;@Override public void open(Configuration config) throws Exception {     super.open(config).     ConnectionFactory factory = setupConnectionFactory().     try {         connection = factory.newConnection().         channel = connection.createChannel().         if (channel == null) {             throw new RuntimeException("None of RabbitMQ channels are available").         }         setupQueue().         consumer = new QueueingConsumer(channel).         RuntimeContext runtimeContext = getRuntimeContext().         if (runtimeContext instanceof StreamingRuntimeContext && ((StreamingRuntimeContext) runtimeContext).isCheckpointingEnabled()) {             autoAck = false.             // enables transaction mode             channel.txSelect().         } else {             autoAck = true.         }         LOG.debug("Starting RabbitMQ source with autoAck status: " + autoAck).         channel.basicConsume(queueName, autoAck, consumer).     } catch (IOException e) {         throw new RuntimeException("Cannot create RMQ connection with " + queueName + " at " + rmqConnectionConfig.getHost(), e).     }     running = true. }
false;public;0;12;;@Override public void close() throws Exception {     super.close().     try {         if (connection != null) {             connection.close().         }     } catch (IOException e) {         throw new RuntimeException("Error while closing RMQ connection with " + queueName + " at " + rmqConnectionConfig.getHost(), e).     } }
false;public;1;32;;@Override public void run(SourceContext<OUT> ctx) throws Exception {     while (running) {         QueueingConsumer.Delivery delivery = consumer.nextDelivery().         synchronized (ctx.getCheckpointLock()) {             OUT result = schema.deserialize(delivery.getBody()).             if (schema.isEndOfStream(result)) {                 break.             }             if (!autoAck) {                 final long deliveryTag = delivery.getEnvelope().getDeliveryTag().                 if (usesCorrelationId) {                     final String correlationId = delivery.getProperties().getCorrelationId().                     Preconditions.checkNotNull(correlationId, "RabbitMQ source was instantiated " + "with usesCorrelationId set to true but a message was received with " + "correlation id set to null!").                     if (!addId(correlationId)) {                         // we have already processed this message                         continue.                     }                 }                 sessionIds.add(deliveryTag).             }             ctx.collect(result).         }     } }
false;public;0;4;;@Override public void cancel() {     running = false. }
false;protected;1;11;;@Override protected void acknowledgeSessionIDs(List<Long> sessionIds) {     try {         for (long id : sessionIds) {             channel.basicAck(id, false).         }         channel.txCommit().     } catch (IOException e) {         throw new RuntimeException("Messages could not be acknowledged during checkpoint creation.", e).     } }
false;public;0;4;;@Override public TypeInformation<OUT> getProducedType() {     return schema.getProducedType(). }
