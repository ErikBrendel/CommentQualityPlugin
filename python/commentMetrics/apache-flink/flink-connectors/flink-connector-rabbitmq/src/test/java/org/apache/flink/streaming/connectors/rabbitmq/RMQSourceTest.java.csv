commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public void run() {     try {         source.run(new DummySourceContext()).     } catch (Exception e) {         exception = e.     } }
false;public;0;26;;@Before public void beforeTest() throws Exception {     OperatorStateStore mockStore = Mockito.mock(OperatorStateStore.class).     FunctionInitializationContext mockContext = Mockito.mock(FunctionInitializationContext.class).     Mockito.when(mockContext.getOperatorStateStore()).thenReturn(mockStore).     Mockito.when(mockStore.getSerializableListState(any(String.class))).thenReturn(null).     source = new RMQTestSource().     source.initializeState(mockContext).     source.open(config).     messageId = 0.     generateCorrelationIds = true.     sourceThread = new Thread(new Runnable() {          @Override         public void run() {             try {                 source.run(new DummySourceContext()).             } catch (Exception e) {                 exception = e.             }         }     }). }
false;public;0;5;;@After public void afterTest() throws Exception {     source.cancel().     sourceThread.join(). }
false;public;0;17;;@Test public void throwExceptionIfConnectionFactoryReturnNull() throws Exception {     RMQConnectionConfig connectionConfig = Mockito.mock(RMQConnectionConfig.class).     ConnectionFactory connectionFactory = Mockito.mock(ConnectionFactory.class).     Connection connection = Mockito.mock(Connection.class).     Mockito.when(connectionConfig.getConnectionFactory()).thenReturn(connectionFactory).     Mockito.when(connectionFactory.newConnection()).thenReturn(connection).     Mockito.when(connection.createChannel()).thenReturn(null).     RMQSource<String> rmqSource = new RMQSource<>(connectionConfig, "queueDummy", true, new StringDeserializationScheme()).     try {         rmqSource.open(new Configuration()).     } catch (RuntimeException ex) {         assertEquals("None of RabbitMQ channels are available", ex.getMessage()).     } }
false;public;0;64;;@Test public void testCheckpointing() throws Exception {     source.autoAck = false.     StreamSource<String, RMQSource<String>> src = new StreamSource<>(source).     AbstractStreamOperatorTestHarness<String> testHarness = new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0).     testHarness.open().     sourceThread.start().     Thread.sleep(5).     final Random random = new Random(System.currentTimeMillis()).     int numSnapshots = 50.     long previousSnapshotId.     long lastSnapshotId = 0.     long totalNumberOfAcks = 0.     for (int i = 0. i < numSnapshots. i++) {         long snapshotId = random.nextLong().         OperatorSubtaskState data.         synchronized (DummySourceContext.lock) {             data = testHarness.snapshot(snapshotId, System.currentTimeMillis()).             previousSnapshotId = lastSnapshotId.             lastSnapshotId = messageId.         }         // let some time pass         Thread.sleep(5).         // check if the correct number of messages have been snapshotted         final long numIds = lastSnapshotId - previousSnapshotId.         RMQTestSource sourceCopy = new RMQTestSource().         StreamSource<String, RMQTestSource> srcCopy = new StreamSource<>(sourceCopy).         AbstractStreamOperatorTestHarness<String> testHarnessCopy = new AbstractStreamOperatorTestHarness<>(srcCopy, 1, 1, 0).         testHarnessCopy.setup().         testHarnessCopy.initializeState(data).         testHarnessCopy.open().         ArrayDeque<Tuple2<Long, Set<String>>> deque = sourceCopy.getRestoredState().         Set<String> messageIds = deque.getLast().f1.         assertEquals(numIds, messageIds.size()).         if (messageIds.size() > 0) {             assertTrue(messageIds.contains(Long.toString(lastSnapshotId))).         }         // check if the messages are being acknowledged and the transaction committed         synchronized (DummySourceContext.lock) {             source.notifyCheckpointComplete(snapshotId).         }         totalNumberOfAcks += numIds.     }     Mockito.verify(source.channel, Mockito.times((int) totalNumberOfAcks)).basicAck(Mockito.anyLong(), Mockito.eq(false)).     Mockito.verify(source.channel, Mockito.times(numSnapshots)).txCommit(). }
true;public;0;25;/**  * Checks whether recurring ids are processed again (they shouldn't be).  */ ;/**  * Checks whether recurring ids are processed again (they shouldn't be).  */ @Test public void testDuplicateId() throws Exception {     source.autoAck = false.     sourceThread.start().     while (messageId < 10) {         // wait until messages have been processed         Thread.sleep(5).     }     long oldMessageId.     synchronized (DummySourceContext.lock) {         oldMessageId = messageId.         messageId = 0.     }     while (messageId < 10) {         // process again         Thread.sleep(5).     }     synchronized (DummySourceContext.lock) {         assertEquals(Math.max(messageId, oldMessageId), DummySourceContext.numElementsCollected).     } }
true;public;0;12;/**  * The source should not acknowledge ids in auto-commit mode or check for previously acknowledged ids.  */ ;/**  * The source should not acknowledge ids in auto-commit mode or check for previously acknowledged ids.  */ @Test public void testCheckpointingDisabled() throws Exception {     source.autoAck = true.     sourceThread.start().     while (DummySourceContext.numElementsCollected < 50) {         // wait until messages have been processed         Thread.sleep(5).     } // see addId in RMQTestSource.addId for the assert }
true;public;0;11;/**  * Tests error reporting in case of invalid correlation ids.  */ ;/**  * Tests error reporting in case of invalid correlation ids.  */ @Test public void testCorrelationIdNotSet() throws InterruptedException {     generateCorrelationIds = false.     source.autoAck = false.     sourceThread.start().     sourceThread.join().     assertNotNull(exception).     assertTrue(exception instanceof NullPointerException). }
true;public;0;19;/**  * Tests whether constructor params are passed correctly.  */ ;/**  * Tests whether constructor params are passed correctly.  */ @Test public void testConstructorParams() throws Exception {     // verify construction params     RMQConnectionConfig.Builder builder = new RMQConnectionConfig.Builder().     builder.setHost("hostTest").setPort(999).setUserName("userTest").setPassword("passTest").setVirtualHost("/").     ConstructorTestClass testObj = new ConstructorTestClass(builder.build(), "queueTest", false, new StringDeserializationScheme()).     try {         testObj.open(new Configuration()).     } catch (Exception e) {     // connection fails but check if args have been passed correctly     }     assertEquals("hostTest", testObj.getFactory().getHost()).     assertEquals(999, testObj.getFactory().getPort()).     assertEquals("userTest", testObj.getFactory().getUsername()).     assertEquals("passTest", testObj.getFactory().getPassword()). }
false;protected;0;4;;@Override protected ConnectionFactory setupConnectionFactory() {     return factory. }
false;public;0;3;;public ConnectionFactory getFactory() {     return factory. }
false;public;1;10;;@Override public String deserialize(byte[] message) throws IOException {     try {         // wait a bit to not cause too much cpu load         Thread.sleep(1).     } catch (InterruptedException e) {         e.printStackTrace().     }     return new String(message, ConfigConstants.DEFAULT_CHARSET). }
false;public;1;4;;@Override public boolean isEndOfStream(String nextElement) {     return false. }
false;public;0;4;;@Override public TypeInformation<String> getProducedType() {     return TypeExtractor.getForClass(String.class). }
false;public;1;5;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     super.initializeState(context).     this.restoredState = this.pendingCheckpoints. }
false;public;0;3;;public ArrayDeque<Tuple2<Long, Set<String>>> getRestoredState() {     return this.restoredState. }
false;public;1;4;;@Override public Long answer(InvocationOnMock invocation) throws Throwable {     return ++messageId. }
false;public;1;4;;@Override public String answer(InvocationOnMock invocation) throws Throwable {     return generateCorrelationIds ? "" + messageId : null. }
false;public;1;39;;@Override public void open(Configuration config) throws Exception {     super.open(config).     consumer = Mockito.mock(QueueingConsumer.class).     // Mock for delivery     final QueueingConsumer.Delivery deliveryMock = Mockito.mock(QueueingConsumer.Delivery.class).     Mockito.when(deliveryMock.getBody()).thenReturn("test".getBytes(ConfigConstants.DEFAULT_CHARSET)).     try {         Mockito.when(consumer.nextDelivery()).thenReturn(deliveryMock).     } catch (InterruptedException e) {         fail("Couldn't setup up deliveryMock").     }     // Mock for envelope     Envelope envelope = Mockito.mock(Envelope.class).     Mockito.when(deliveryMock.getEnvelope()).thenReturn(envelope).     Mockito.when(envelope.getDeliveryTag()).thenAnswer(new Answer<Long>() {          @Override         public Long answer(InvocationOnMock invocation) throws Throwable {             return ++messageId.         }     }).     // Mock for properties     AMQP.BasicProperties props = Mockito.mock(AMQP.BasicProperties.class).     Mockito.when(deliveryMock.getProperties()).thenReturn(props).     Mockito.when(props.getCorrelationId()).thenAnswer(new Answer<String>() {          @Override         public String answer(InvocationOnMock invocation) throws Throwable {             return generateCorrelationIds ? "" + messageId : null.         }     }). }
false;protected;0;12;;@Override protected ConnectionFactory setupConnectionFactory() {     ConnectionFactory connectionFactory = Mockito.mock(ConnectionFactory.class).     Connection connection = Mockito.mock(Connection.class).     try {         Mockito.when(connectionFactory.newConnection()).thenReturn(connection).         Mockito.when(connection.createChannel()).thenReturn(Mockito.mock(Channel.class)).     } catch (IOException | TimeoutException e) {         fail("Test environment couldn't be created.").     }     return connectionFactory. }
false;public;0;4;;@Override public RuntimeContext getRuntimeContext() {     return Mockito.mock(StreamingRuntimeContext.class). }
false;protected;1;5;;@Override protected boolean addId(String uid) {     assertEquals(false, autoAck).     return super.addId(uid). }
false;public;1;4;;@Override public void collect(String element) {     numElementsCollected++. }
false;public;2;3;;@Override public void collectWithTimestamp(java.lang.String element, long timestamp) { }
false;public;1;4;;@Override public void emitWatermark(Watermark mark) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public void markAsTemporarilyIdle() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Object getCheckpointLock() {     return lock. }
false;public;0;3;;@Override public void close() { }
