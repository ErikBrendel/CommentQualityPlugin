commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;@Before public void before() throws Exception {     serializationSchema = spy(new DummySerializationSchema()).     rmqConnectionConfig = mock(RMQConnectionConfig.class).     connectionFactory = mock(ConnectionFactory.class).     connection = mock(Connection.class).     channel = mock(Channel.class).     when(rmqConnectionConfig.getConnectionFactory()).thenReturn(connectionFactory).     when(connectionFactory.newConnection()).thenReturn(connection).     when(connection.createChannel()).thenReturn(channel). }
false;public;0;6;;@Test public void openCallDeclaresQueueInStandardMode() throws Exception {     createRMQSink().     verify(channel).queueDeclare(QUEUE_NAME, false, false, false, null). }
false;public;0;6;;@Test public void openCallDontDeclaresQueueInWithOptionsMode() throws Exception {     createRMQSinkWithOptions(false, false).     verify(channel, never()).queueDeclare(null, false, false, false, null). }
false;public;0;9;;@Test public void throwExceptionIfChannelIsNull() throws Exception {     when(connection.createChannel()).thenReturn(null).     try {         createRMQSink().     } catch (RuntimeException ex) {         assertEquals("None of RabbitMQ channels are available", ex.getMessage()).     } }
false;private;0;5;;private RMQSink<String> createRMQSink() throws Exception {     RMQSink<String> rmqSink = new RMQSink<>(rmqConnectionConfig, QUEUE_NAME, serializationSchema).     rmqSink.open(new Configuration()).     return rmqSink. }
false;private;2;6;;private RMQSink<String> createRMQSinkWithOptions(boolean mandatory, boolean immediate) throws Exception {     publishOptions = new DummyPublishOptions(mandatory, immediate).     RMQSink<String> rmqSink = new RMQSink<>(rmqConnectionConfig, serializationSchema, publishOptions).     rmqSink.open(new Configuration()).     return rmqSink. }
false;private;2;7;;private RMQSink<String> createRMQSinkWithOptionsAndReturnHandler(boolean mandatory, boolean immediate) throws Exception {     publishOptions = new DummyPublishOptions(mandatory, immediate).     returnListener = new DummyReturnHandler().     RMQSink<String> rmqSink = new RMQSink<>(rmqConnectionConfig, serializationSchema, publishOptions, returnListener).     rmqSink.open(new Configuration()).     return rmqSink. }
false;public;0;8;;@Test public void invokePublishBytesToQueue() throws Exception {     RMQSink<String> rmqSink = createRMQSink().     rmqSink.invoke(MESSAGE_STR, SinkContextUtil.forTimestamp(0)).     verify(serializationSchema).serialize(MESSAGE_STR).     verify(channel).basicPublish("", QUEUE_NAME, null, MESSAGE). }
false;public;0;7;;@Test(expected = RuntimeException.class) public void exceptionDuringPublishingIsNotIgnored() throws Exception {     RMQSink<String> rmqSink = createRMQSink().     doThrow(IOException.class).when(channel).basicPublish("", QUEUE_NAME, null, MESSAGE).     rmqSink.invoke("msg", SinkContextUtil.forTimestamp(0)). }
false;public;0;8;;@Test public void exceptionDuringPublishingIsIgnoredIfLogFailuresOnly() throws Exception {     RMQSink<String> rmqSink = createRMQSink().     rmqSink.setLogFailuresOnly(true).     doThrow(IOException.class).when(channel).basicPublish("", QUEUE_NAME, null, MESSAGE).     rmqSink.invoke("msg", SinkContextUtil.forTimestamp(0)). }
false;public;0;9;;@Test public void closeAllResources() throws Exception {     RMQSink<String> rmqSink = createRMQSink().     rmqSink.close().     verify(channel).close().     verify(connection).close(). }
false;public;0;9;;@Test public void invokePublishBytesToQueueWithOptions() throws Exception {     RMQSink<String> rmqSink = createRMQSinkWithOptions(false, false).     rmqSink.invoke(MESSAGE_STR, SinkContextUtil.forTimestamp(0)).     verify(serializationSchema).serialize(MESSAGE_STR).     verify(channel).basicPublish(EXCHANGE, ROUTING_KEY, false, false, publishOptions.computeProperties(""), MESSAGE). }
false;public;0;6;;@Test(expected = IllegalStateException.class) public void invokePublishBytesToQueueWithOptionsMandatory() throws Exception {     RMQSink<String> rmqSink = createRMQSinkWithOptions(true, false).     rmqSink.invoke(MESSAGE_STR, SinkContextUtil.forTimestamp(0)). }
false;public;0;6;;@Test(expected = IllegalStateException.class) public void invokePublishBytesToQueueWithOptionsImmediate() throws Exception {     RMQSink<String> rmqSink = createRMQSinkWithOptions(false, true).     rmqSink.invoke(MESSAGE_STR, SinkContextUtil.forTimestamp(0)). }
false;public;0;9;;@Test public void invokePublishBytesToQueueWithOptionsMandatoryReturnHandler() throws Exception {     RMQSink<String> rmqSink = createRMQSinkWithOptionsAndReturnHandler(true, false).     rmqSink.invoke(MESSAGE_STR, SinkContextUtil.forTimestamp(0)).     verify(serializationSchema).serialize(MESSAGE_STR).     verify(channel).basicPublish(EXCHANGE, ROUTING_KEY, true, false, publishOptions.computeProperties(""), MESSAGE). }
false;public;0;9;;@Test public void invokePublishBytesToQueueWithOptionsImmediateReturnHandler() throws Exception {     RMQSink<String> rmqSink = createRMQSinkWithOptionsAndReturnHandler(false, true).     rmqSink.invoke(MESSAGE_STR, SinkContextUtil.forTimestamp(0)).     verify(serializationSchema).serialize(MESSAGE_STR).     verify(channel).basicPublish(EXCHANGE, ROUTING_KEY, false, true, publishOptions.computeProperties(""), MESSAGE). }
false;public;0;8;;@Test(expected = RuntimeException.class) public void exceptionDuringWithOptionsPublishingIsNotIgnored() throws Exception {     RMQSink<String> rmqSink = createRMQSinkWithOptions(false, false).     doThrow(IOException.class).when(channel).basicPublish(EXCHANGE, ROUTING_KEY, false, false, publishOptions.computeProperties(""), MESSAGE).     rmqSink.invoke("msg", SinkContextUtil.forTimestamp(0)). }
false;public;0;9;;@Test public void exceptionDuringWithOptionsPublishingIsIgnoredIfLogFailuresOnly() throws Exception {     RMQSink<String> rmqSink = createRMQSinkWithOptions(false, false).     rmqSink.setLogFailuresOnly(true).     doThrow(IOException.class).when(channel).basicPublish(EXCHANGE, ROUTING_KEY, false, false, publishOptions.computeProperties(""), MESSAGE).     rmqSink.invoke("msg", SinkContextUtil.forTimestamp(0)). }
false;public;1;4;;@Override public String computeRoutingKey(String a) {     return ROUTING_KEY. }
false;public;1;4;;@Override public BasicProperties computeProperties(String a) {     return props. }
false;public;1;4;;@Override public String computeExchange(String a) {     return EXCHANGE. }
false;public;1;4;;@Override public boolean computeMandatory(String a) {     return mandatory. }
false;public;1;4;;@Override public boolean computeImmediate(String a) {     return immediate. }
false;public;6;3;;@Override public void handleReturn(final int replyCode, final String replyText, final String exchange, final String routingKey, final BasicProperties properties, final byte[] body) { }
false;public;1;4;;@Override public byte[] serialize(String element) {     return MESSAGE. }
