# id;timestamp;commentText;codeText;commentWords;codeWords
FlinkKafkaProducer -> private void flushNewPartitions();1509597800;Besides committing {@link org.apache.kafka.clients.producer.KafkaProducer#commitTransaction} is also adding new_partitions to the transaction. flushNewPartitions method is moving this logic to pre-commit/flush, to make_resumeTransaction simpler. Otherwise resumeTransaction would require to restore state of the not yet added/"in-flight"_partitions.;private void flushNewPartitions() {_		LOG.info("Flushing new partitions")__		TransactionalRequestResult result = enqueueNewPartitions()__		Object sender = getValue(kafkaProducer, "sender")__		invoke(sender, "wakeup")__		result.await()__	};besides,committing,link,org,apache,kafka,clients,producer,kafka,producer,commit,transaction,is,also,adding,new,partitions,to,the,transaction,flush,new,partitions,method,is,moving,this,logic,to,pre,commit,flush,to,make,resume,transaction,simpler,otherwise,resume,transaction,would,require,to,restore,state,of,the,not,yet,added,in,flight,partitions;private,void,flush,new,partitions,log,info,flushing,new,partitions,transactional,request,result,result,enqueue,new,partitions,object,sender,get,value,kafka,producer,sender,invoke,sender,wakeup,result,await
FlinkKafkaProducer -> private void flushNewPartitions();1511180690;Besides committing {@link org.apache.kafka.clients.producer.KafkaProducer#commitTransaction} is also adding new_partitions to the transaction. flushNewPartitions method is moving this logic to pre-commit/flush, to make_resumeTransaction simpler. Otherwise resumeTransaction would require to restore state of the not yet added/"in-flight"_partitions.;private void flushNewPartitions() {_		LOG.info("Flushing new partitions")__		TransactionalRequestResult result = enqueueNewPartitions()__		Object sender = getValue(kafkaProducer, "sender")__		invoke(sender, "wakeup")__		result.await()__	};besides,committing,link,org,apache,kafka,clients,producer,kafka,producer,commit,transaction,is,also,adding,new,partitions,to,the,transaction,flush,new,partitions,method,is,moving,this,logic,to,pre,commit,flush,to,make,resume,transaction,simpler,otherwise,resume,transaction,would,require,to,restore,state,of,the,not,yet,added,in,flight,partitions;private,void,flush,new,partitions,log,info,flushing,new,partitions,transactional,request,result,result,enqueue,new,partitions,object,sender,get,value,kafka,producer,sender,invoke,sender,wakeup,result,await
FlinkKafkaProducer -> private void flushNewPartitions();1515757409;Besides committing {@link org.apache.kafka.clients.producer.KafkaProducer#commitTransaction} is also adding new_partitions to the transaction. flushNewPartitions method is moving this logic to pre-commit/flush, to make_resumeTransaction simpler. Otherwise resumeTransaction would require to restore state of the not yet added/"in-flight"_partitions.;private void flushNewPartitions() {_		LOG.info("Flushing new partitions")__		TransactionalRequestResult result = enqueueNewPartitions()__		Object sender = getValue(kafkaProducer, "sender")__		invoke(sender, "wakeup")__		result.await()__	};besides,committing,link,org,apache,kafka,clients,producer,kafka,producer,commit,transaction,is,also,adding,new,partitions,to,the,transaction,flush,new,partitions,method,is,moving,this,logic,to,pre,commit,flush,to,make,resume,transaction,simpler,otherwise,resume,transaction,would,require,to,restore,state,of,the,not,yet,added,in,flight,partitions;private,void,flush,new,partitions,log,info,flushing,new,partitions,transactional,request,result,result,enqueue,new,partitions,object,sender,get,value,kafka,producer,sender,invoke,sender,wakeup,result,await
FlinkKafkaProducer -> private void flushNewPartitions();1541587130;Besides committing {@link org.apache.kafka.clients.producer.KafkaProducer#commitTransaction} is also adding new_partitions to the transaction. flushNewPartitions method is moving this logic to pre-commit/flush, to make_resumeTransaction simpler. Otherwise resumeTransaction would require to restore state of the not yet added/"in-flight"_partitions.;private void flushNewPartitions() {_		LOG.info("Flushing new partitions")__		TransactionalRequestResult result = enqueueNewPartitions()__		Object sender = getValue(kafkaProducer, "sender")__		invoke(sender, "wakeup")__		result.await()__	};besides,committing,link,org,apache,kafka,clients,producer,kafka,producer,commit,transaction,is,also,adding,new,partitions,to,the,transaction,flush,new,partitions,method,is,moving,this,logic,to,pre,commit,flush,to,make,resume,transaction,simpler,otherwise,resume,transaction,would,require,to,restore,state,of,the,not,yet,added,in,flight,partitions;private,void,flush,new,partitions,log,info,flushing,new,partitions,transactional,request,result,result,enqueue,new,partitions,object,sender,get,value,kafka,producer,sender,invoke,sender,wakeup,result,await
FlinkKafkaProducer -> public void resumeTransaction(long producerId, short epoch);1509597800;Instead of obtaining producerId and epoch from the transaction coordinator, re-use previously obtained ones,_so that we can resume transaction after a restart. Implementation of this method is based on_{@link org.apache.kafka.clients.producer.KafkaProducer#initTransactions}.;public void resumeTransaction(long producerId, short epoch) {_		Preconditions.checkState(producerId >= 0 && epoch >= 0, "Incorrect values for producerId {} and epoch {}", producerId, epoch)__		LOG.info("Attempting to resume transaction with producerId {} and epoch {}", producerId, epoch)___		Object transactionManager = getValue(kafkaProducer, "transactionManager")__		synchronized (transactionManager) {_			Object sequenceNumbers = getValue(transactionManager, "sequenceNumbers")___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.INITIALIZING"))__			invoke(sequenceNumbers, "clear")___			Object producerIdAndEpoch = getValue(transactionManager, "producerIdAndEpoch")__			setValue(producerIdAndEpoch, "producerId", producerId)__			setValue(producerIdAndEpoch, "epoch", epoch)___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.READY"))___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.IN_TRANSACTION"))__			setValue(transactionManager, "transactionStarted", true)__		}_	};instead,of,obtaining,producer,id,and,epoch,from,the,transaction,coordinator,re,use,previously,obtained,ones,so,that,we,can,resume,transaction,after,a,restart,implementation,of,this,method,is,based,on,link,org,apache,kafka,clients,producer,kafka,producer,init,transactions;public,void,resume,transaction,long,producer,id,short,epoch,preconditions,check,state,producer,id,0,epoch,0,incorrect,values,for,producer,id,and,epoch,producer,id,epoch,log,info,attempting,to,resume,transaction,with,producer,id,and,epoch,producer,id,epoch,object,transaction,manager,get,value,kafka,producer,transaction,manager,synchronized,transaction,manager,object,sequence,numbers,get,value,transaction,manager,sequence,numbers,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,initializing,invoke,sequence,numbers,clear,object,producer,id,and,epoch,get,value,transaction,manager,producer,id,and,epoch,set,value,producer,id,and,epoch,producer,id,producer,id,set,value,producer,id,and,epoch,epoch,epoch,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,ready,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,set,value,transaction,manager,transaction,started,true
FlinkKafkaProducer -> public void resumeTransaction(long producerId, short epoch);1511180690;Instead of obtaining producerId and epoch from the transaction coordinator, re-use previously obtained ones,_so that we can resume transaction after a restart. Implementation of this method is based on_{@link org.apache.kafka.clients.producer.KafkaProducer#initTransactions}.;public void resumeTransaction(long producerId, short epoch) {_		Preconditions.checkState(producerId >= 0 && epoch >= 0, "Incorrect values for producerId {} and epoch {}", producerId, epoch)__		LOG.info("Attempting to resume transaction {} with producerId {} and epoch {}", transactionalId, producerId, epoch)___		Object transactionManager = getValue(kafkaProducer, "transactionManager")__		synchronized (transactionManager) {_			Object sequenceNumbers = getValue(transactionManager, "sequenceNumbers")___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.INITIALIZING"))__			invoke(sequenceNumbers, "clear")___			Object producerIdAndEpoch = getValue(transactionManager, "producerIdAndEpoch")__			setValue(producerIdAndEpoch, "producerId", producerId)__			setValue(producerIdAndEpoch, "epoch", epoch)___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.READY"))___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.IN_TRANSACTION"))__			setValue(transactionManager, "transactionStarted", true)__		}_	};instead,of,obtaining,producer,id,and,epoch,from,the,transaction,coordinator,re,use,previously,obtained,ones,so,that,we,can,resume,transaction,after,a,restart,implementation,of,this,method,is,based,on,link,org,apache,kafka,clients,producer,kafka,producer,init,transactions;public,void,resume,transaction,long,producer,id,short,epoch,preconditions,check,state,producer,id,0,epoch,0,incorrect,values,for,producer,id,and,epoch,producer,id,epoch,log,info,attempting,to,resume,transaction,with,producer,id,and,epoch,transactional,id,producer,id,epoch,object,transaction,manager,get,value,kafka,producer,transaction,manager,synchronized,transaction,manager,object,sequence,numbers,get,value,transaction,manager,sequence,numbers,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,initializing,invoke,sequence,numbers,clear,object,producer,id,and,epoch,get,value,transaction,manager,producer,id,and,epoch,set,value,producer,id,and,epoch,producer,id,producer,id,set,value,producer,id,and,epoch,epoch,epoch,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,ready,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,set,value,transaction,manager,transaction,started,true
FlinkKafkaProducer -> public void resumeTransaction(long producerId, short epoch);1515757409;Instead of obtaining producerId and epoch from the transaction coordinator, re-use previously obtained ones,_so that we can resume transaction after a restart. Implementation of this method is based on_{@link org.apache.kafka.clients.producer.KafkaProducer#initTransactions}.;public void resumeTransaction(long producerId, short epoch) {_		Preconditions.checkState(producerId >= 0 && epoch >= 0, "Incorrect values for producerId {} and epoch {}", producerId, epoch)__		LOG.info("Attempting to resume transaction {} with producerId {} and epoch {}", transactionalId, producerId, epoch)___		Object transactionManager = getValue(kafkaProducer, "transactionManager")__		synchronized (transactionManager) {_			Object sequenceNumbers = getValue(transactionManager, "sequenceNumbers")___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.INITIALIZING"))__			invoke(sequenceNumbers, "clear")___			Object producerIdAndEpoch = getValue(transactionManager, "producerIdAndEpoch")__			setValue(producerIdAndEpoch, "producerId", producerId)__			setValue(producerIdAndEpoch, "epoch", epoch)___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.READY"))___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.IN_TRANSACTION"))__			setValue(transactionManager, "transactionStarted", true)__		}_	};instead,of,obtaining,producer,id,and,epoch,from,the,transaction,coordinator,re,use,previously,obtained,ones,so,that,we,can,resume,transaction,after,a,restart,implementation,of,this,method,is,based,on,link,org,apache,kafka,clients,producer,kafka,producer,init,transactions;public,void,resume,transaction,long,producer,id,short,epoch,preconditions,check,state,producer,id,0,epoch,0,incorrect,values,for,producer,id,and,epoch,producer,id,epoch,log,info,attempting,to,resume,transaction,with,producer,id,and,epoch,transactional,id,producer,id,epoch,object,transaction,manager,get,value,kafka,producer,transaction,manager,synchronized,transaction,manager,object,sequence,numbers,get,value,transaction,manager,sequence,numbers,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,initializing,invoke,sequence,numbers,clear,object,producer,id,and,epoch,get,value,transaction,manager,producer,id,and,epoch,set,value,producer,id,and,epoch,producer,id,producer,id,set,value,producer,id,and,epoch,epoch,epoch,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,ready,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,set,value,transaction,manager,transaction,started,true
FlinkKafkaProducer -> public void resumeTransaction(long producerId, short epoch);1541587130;Instead of obtaining producerId and epoch from the transaction coordinator, re-use previously obtained ones,_so that we can resume transaction after a restart. Implementation of this method is based on_{@link org.apache.kafka.clients.producer.KafkaProducer#initTransactions}.;public void resumeTransaction(long producerId, short epoch) {_		Preconditions.checkState(producerId >= 0 && epoch >= 0, "Incorrect values for producerId {} and epoch {}", producerId, epoch)__		LOG.info("Attempting to resume transaction {} with producerId {} and epoch {}", transactionalId, producerId, epoch)___		Object transactionManager = getValue(kafkaProducer, "transactionManager")__		synchronized (transactionManager) {_			Object sequenceNumbers = getValue(transactionManager, "sequenceNumbers")___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.INITIALIZING"))__			invoke(sequenceNumbers, "clear")___			Object producerIdAndEpoch = getValue(transactionManager, "producerIdAndEpoch")__			setValue(producerIdAndEpoch, "producerId", producerId)__			setValue(producerIdAndEpoch, "epoch", epoch)___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.READY"))___			invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.IN_TRANSACTION"))__			setValue(transactionManager, "transactionStarted", true)__		}_	};instead,of,obtaining,producer,id,and,epoch,from,the,transaction,coordinator,re,use,previously,obtained,ones,so,that,we,can,resume,transaction,after,a,restart,implementation,of,this,method,is,based,on,link,org,apache,kafka,clients,producer,kafka,producer,init,transactions;public,void,resume,transaction,long,producer,id,short,epoch,preconditions,check,state,producer,id,0,epoch,0,incorrect,values,for,producer,id,and,epoch,producer,id,epoch,log,info,attempting,to,resume,transaction,with,producer,id,and,epoch,transactional,id,producer,id,epoch,object,transaction,manager,get,value,kafka,producer,transaction,manager,synchronized,transaction,manager,object,sequence,numbers,get,value,transaction,manager,sequence,numbers,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,initializing,invoke,sequence,numbers,clear,object,producer,id,and,epoch,get,value,transaction,manager,producer,id,and,epoch,set,value,producer,id,and,epoch,producer,id,producer,id,set,value,producer,id,and,epoch,epoch,epoch,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,ready,invoke,transaction,manager,transition,to,get,enum,org,apache,kafka,clients,producer,internals,transaction,manager,state,set,value,transaction,manager,transaction,started,true
