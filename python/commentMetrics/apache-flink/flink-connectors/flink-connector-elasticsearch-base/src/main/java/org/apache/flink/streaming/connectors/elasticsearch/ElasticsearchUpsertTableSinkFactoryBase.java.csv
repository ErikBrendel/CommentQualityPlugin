commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public Map<String, String> requiredContext() {     final Map<String, String> context = new HashMap<>().     context.put(CONNECTOR_TYPE, CONNECTOR_TYPE_VALUE_ELASTICSEARCH).     context.put(CONNECTOR_VERSION, elasticsearchVersion()).     context.put(CONNECTOR_PROPERTY_VERSION, "1").     return context. }
false;public;0;36;;@Override public List<String> supportedProperties() {     final List<String> properties = new ArrayList<>().     // streaming properties     properties.add(UPDATE_MODE()).     // Elasticsearch     properties.add(CONNECTOR_HOSTS + ".#." + CONNECTOR_HOSTS_HOSTNAME).     properties.add(CONNECTOR_HOSTS + ".#." + CONNECTOR_HOSTS_PORT).     properties.add(CONNECTOR_HOSTS + ".#." + CONNECTOR_HOSTS_PROTOCOL).     properties.add(CONNECTOR_INDEX).     properties.add(CONNECTOR_DOCUMENT_TYPE).     properties.add(CONNECTOR_KEY_DELIMITER).     properties.add(CONNECTOR_KEY_NULL_LITERAL).     properties.add(CONNECTOR_FAILURE_HANDLER).     properties.add(CONNECTOR_FAILURE_HANDLER_CLASS).     properties.add(CONNECTOR_FLUSH_ON_CHECKPOINT).     properties.add(CONNECTOR_BULK_FLUSH_MAX_ACTIONS).     properties.add(CONNECTOR_BULK_FLUSH_MAX_SIZE).     properties.add(CONNECTOR_BULK_FLUSH_INTERVAL).     properties.add(CONNECTOR_BULK_FLUSH_BACKOFF_TYPE).     properties.add(CONNECTOR_BULK_FLUSH_BACKOFF_MAX_RETRIES).     properties.add(CONNECTOR_BULK_FLUSH_BACKOFF_DELAY).     properties.add(CONNECTOR_CONNECTION_MAX_RETRY_TIMEOUT).     properties.add(CONNECTOR_CONNECTION_PATH_PREFIX).     // schema     properties.add(SCHEMA() + ".#." + SCHEMA_TYPE()).     properties.add(SCHEMA() + ".#." + SCHEMA_NAME()).     // format wildcard     properties.add(FORMAT + ".*").     return properties. }
false;public;1;17;;@Override public StreamTableSink<Tuple2<Boolean, Row>> createStreamTableSink(Map<String, String> properties) {     final DescriptorProperties descriptorProperties = getValidatedProperties(properties).     return createElasticsearchUpsertTableSink(descriptorProperties.isValue(UPDATE_MODE(), UPDATE_MODE_VALUE_APPEND()), descriptorProperties.getTableSchema(SCHEMA()), getHosts(descriptorProperties), descriptorProperties.getString(CONNECTOR_INDEX), descriptorProperties.getString(CONNECTOR_DOCUMENT_TYPE), descriptorProperties.getOptionalString(CONNECTOR_KEY_DELIMITER).orElse(DEFAULT_KEY_DELIMITER), descriptorProperties.getOptionalString(CONNECTOR_KEY_NULL_LITERAL).orElse(DEFAULT_KEY_NULL_LITERAL), getSerializationSchema(properties), SUPPORTED_CONTENT_TYPE, getFailureHandler(descriptorProperties), getSinkOptions(descriptorProperties)). }
false;protected,abstract;0;1;;// -------------------------------------------------------------------------------------------- // For version-specific factories // -------------------------------------------------------------------------------------------- protected abstract String elasticsearchVersion().
false;protected,abstract;11;12;;protected abstract ElasticsearchUpsertTableSinkBase createElasticsearchUpsertTableSink(boolean isAppendOnly, TableSchema schema, List<Host> hosts, String index, String docType, String keyDelimiter, String keyNullLiteral, SerializationSchema<Row> serializationSchema, XContentType contentType, ActionRequestFailureHandler failureHandler, Map<SinkOption, String> sinkOptions).
false;private;1;10;;// -------------------------------------------------------------------------------------------- // Helper methods // -------------------------------------------------------------------------------------------- private DescriptorProperties getValidatedProperties(Map<String, String> properties) {     final DescriptorProperties descriptorProperties = new DescriptorProperties(true).     descriptorProperties.putProperties(properties).     new StreamTableDescriptorValidator(true, false, true).validate(descriptorProperties).     new SchemaValidator(true, false, false).validate(descriptorProperties).     new ElasticsearchValidator().validate(descriptorProperties).     return descriptorProperties. }
false;private;1;11;;private List<Host> getHosts(DescriptorProperties descriptorProperties) {     final List<Map<String, String>> hosts = descriptorProperties.getFixedIndexedProperties(CONNECTOR_HOSTS, Arrays.asList(CONNECTOR_HOSTS_HOSTNAME, CONNECTOR_HOSTS_PORT, CONNECTOR_HOSTS_PROTOCOL)).     return hosts.stream().map(host -> new Host(descriptorProperties.getString(host.get(CONNECTOR_HOSTS_HOSTNAME)), descriptorProperties.getInt(host.get(CONNECTOR_HOSTS_PORT)), descriptorProperties.getString(host.get(CONNECTOR_HOSTS_PROTOCOL)))).collect(Collectors.toList()). }
false;private;1;17;;private SerializationSchema<Row> getSerializationSchema(Map<String, String> properties) {     final String formatType = properties.get(FORMAT_TYPE).     // if the supported format has not been added     if (formatType == null || !formatType.equals(SUPPORTED_FORMAT_TYPE)) {         throw new ValidationException("The Elasticsearch sink requires a '" + SUPPORTED_FORMAT_TYPE + "' format.").     }     @SuppressWarnings("unchecked")     final SerializationSchemaFactory<Row> formatFactory = TableFactoryService.find(SerializationSchemaFactory.class, properties, this.getClass().getClassLoader()).     return formatFactory.createSerializationSchema(properties). }
false;private;1;19;;private ActionRequestFailureHandler getFailureHandler(DescriptorProperties descriptorProperties) {     final String failureHandler = descriptorProperties.getOptionalString(CONNECTOR_FAILURE_HANDLER).orElse(DEFAULT_FAILURE_HANDLER).     switch(failureHandler) {         case CONNECTOR_FAILURE_HANDLER_VALUE_FAIL:             return new NoOpFailureHandler().         case CONNECTOR_FAILURE_HANDLER_VALUE_IGNORE:             return new IgnoringFailureHandler().         case CONNECTOR_FAILURE_HANDLER_VALUE_RETRY:             return new RetryRejectedExecutionFailureHandler().         case CONNECTOR_FAILURE_HANDLER_VALUE_CUSTOM:             final Class<? extends ActionRequestFailureHandler> clazz = descriptorProperties.getClass(CONNECTOR_FAILURE_HANDLER_CLASS, ActionRequestFailureHandler.class).             return InstantiationUtil.instantiate(clazz).         default:             throw new IllegalArgumentException("Unknown failure handler.").     } }
false;private;1;38;;private Map<SinkOption, String> getSinkOptions(DescriptorProperties descriptorProperties) {     final Map<SinkOption, String> options = new HashMap<>().     descriptorProperties.getOptionalBoolean(CONNECTOR_FLUSH_ON_CHECKPOINT).ifPresent(v -> options.put(SinkOption.DISABLE_FLUSH_ON_CHECKPOINT, String.valueOf(!v))).     mapSinkOption(descriptorProperties, options, CONNECTOR_BULK_FLUSH_MAX_ACTIONS, SinkOption.BULK_FLUSH_MAX_ACTIONS).     mapSinkOption(descriptorProperties, options, CONNECTOR_BULK_FLUSH_MAX_SIZE, SinkOption.BULK_FLUSH_MAX_SIZE).     mapSinkOption(descriptorProperties, options, CONNECTOR_BULK_FLUSH_INTERVAL, SinkOption.BULK_FLUSH_INTERVAL).     descriptorProperties.getOptionalString(CONNECTOR_BULK_FLUSH_BACKOFF_TYPE).ifPresent(v -> {         options.put(SinkOption.BULK_FLUSH_BACKOFF_ENABLED, String.valueOf(!v.equals(CONNECTOR_BULK_FLUSH_BACKOFF_TYPE_VALUE_DISABLED))).         switch(v) {             case CONNECTOR_BULK_FLUSH_BACKOFF_TYPE_VALUE_CONSTANT:                 options.put(SinkOption.BULK_FLUSH_BACKOFF_TYPE, ElasticsearchSinkBase.FlushBackoffType.CONSTANT.toString()).                 break.             case CONNECTOR_BULK_FLUSH_BACKOFF_TYPE_VALUE_EXPONENTIAL:                 options.put(SinkOption.BULK_FLUSH_BACKOFF_TYPE, ElasticsearchSinkBase.FlushBackoffType.EXPONENTIAL.toString()).                 break.             default:                 throw new IllegalArgumentException("Unknown backoff type.").         }     }).     mapSinkOption(descriptorProperties, options, CONNECTOR_BULK_FLUSH_BACKOFF_MAX_RETRIES, SinkOption.BULK_FLUSH_BACKOFF_RETRIES).     mapSinkOption(descriptorProperties, options, CONNECTOR_BULK_FLUSH_BACKOFF_DELAY, SinkOption.BULK_FLUSH_BACKOFF_DELAY).     mapSinkOption(descriptorProperties, options, CONNECTOR_CONNECTION_MAX_RETRY_TIMEOUT, SinkOption.REST_MAX_RETRY_TIMEOUT).     mapSinkOption(descriptorProperties, options, CONNECTOR_CONNECTION_PATH_PREFIX, SinkOption.REST_PATH_PREFIX).     return options. }
false;private;4;7;;private void mapSinkOption(DescriptorProperties descriptorProperties, Map<SinkOption, String> options, String fromKey, SinkOption toKey) {     descriptorProperties.getOptionalString(fromKey).ifPresent(v -> options.put(toKey, v)). }
