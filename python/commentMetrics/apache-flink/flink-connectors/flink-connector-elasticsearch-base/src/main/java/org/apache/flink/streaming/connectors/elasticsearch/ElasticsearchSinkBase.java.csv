commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public FlushBackoffType getBackoffType() {     return backoffType. }
false;public;0;3;;public int getMaxRetryCount() {     return maxRetryCount. }
false;public;0;3;;public long getDelayMillis() {     return delayMillis. }
false;public;1;3;;public void setBackoffType(FlushBackoffType backoffType) {     this.backoffType = checkNotNull(backoffType). }
false;public;1;4;;public void setMaxRetryCount(int maxRetryCount) {     checkArgument(maxRetryCount >= 0).     this.maxRetryCount = maxRetryCount. }
false;public;1;4;;public void setDelayMillis(long delayMillis) {     checkArgument(delayMillis >= 0).     this.delayMillis = delayMillis. }
true;public;0;3;/**  * Disable flushing on checkpoint. When disabled, the sink will not wait for all  * pending action requests to be acknowledged by Elasticsearch on checkpoints.  *  * <p>NOTE: If flushing on checkpoint is disabled, the Flink Elasticsearch Sink does NOT  * provide any strong guarantees for at-least-once delivery of action requests.  */ ;/**  * Disable flushing on checkpoint. When disabled, the sink will not wait for all  * pending action requests to be acknowledged by Elasticsearch on checkpoints.  *  * <p>NOTE: If flushing on checkpoint is disabled, the Flink Elasticsearch Sink does NOT  * provide any strong guarantees for at-least-once delivery of action requests.  */ public void disableFlushOnCheckpoint() {     this.flushOnCheckpoint = false. }
false;public;1;7;;@Override public void open(Configuration parameters) throws Exception {     client = callBridge.createClient(userConfig).     bulkProcessor = buildBulkProcessor(new BulkProcessorListener()).     requestIndexer = callBridge.createBulkProcessorIndexer(bulkProcessor, flushOnCheckpoint, numPendingRequests).     failureRequestIndexer = new BufferingNoOpRequestIndexer(). }
false;public;2;5;;@Override public void invoke(T value, Context context) throws Exception {     checkAsyncErrorsAndRequests().     elasticsearchSinkFunction.process(value, getRuntimeContext(), requestIndexer). }
false;public;1;4;;@Override public void initializeState(FunctionInitializationContext context) throws Exception { // no initialization needed }
false;public;1;11;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     checkAsyncErrorsAndRequests().     if (flushOnCheckpoint) {         while (numPendingRequests.get() != 0) {             bulkProcessor.flush().             checkAsyncErrorsAndRequests().         }     } }
false;public;0;17;;@Override public void close() throws Exception {     if (bulkProcessor != null) {         bulkProcessor.close().         bulkProcessor = null.     }     if (client != null) {         client.close().         client = null.     }     callBridge.cleanup().     // make sure any errors from callbacks are rethrown     checkErrorAndRethrow(). }
true;protected;1;26;/**  * Build the {@link BulkProcessor}.  *  * <p>Note: this is exposed for testing purposes.  */ ;/**  * Build the {@link BulkProcessor}.  *  * <p>Note: this is exposed for testing purposes.  */ @VisibleForTesting protected BulkProcessor buildBulkProcessor(BulkProcessor.Listener listener) {     checkNotNull(listener).     BulkProcessor.Builder bulkProcessorBuilder = callBridge.createBulkProcessorBuilder(client, listener).     // This makes flush() blocking     bulkProcessorBuilder.setConcurrentRequests(0).     if (bulkProcessorFlushMaxActions != null) {         bulkProcessorBuilder.setBulkActions(bulkProcessorFlushMaxActions).     }     if (bulkProcessorFlushMaxSizeMb != null) {         bulkProcessorBuilder.setBulkSize(new ByteSizeValue(bulkProcessorFlushMaxSizeMb, ByteSizeUnit.MB)).     }     if (bulkProcessorFlushIntervalMillis != null) {         bulkProcessorBuilder.setFlushInterval(TimeValue.timeValueMillis(bulkProcessorFlushIntervalMillis)).     }     // if backoff retrying is disabled, bulkProcessorFlushBackoffPolicy will be null     callBridge.configureBulkProcessorBackoff(bulkProcessorBuilder, bulkProcessorFlushBackoffPolicy).     return bulkProcessorBuilder.build(). }
false;private;0;6;;private void checkErrorAndRethrow() {     Throwable cause = failureThrowable.get().     if (cause != null) {         throw new RuntimeException("An error occurred in ElasticsearchSink.", cause).     } }
false;private;0;4;;private void checkAsyncErrorsAndRequests() {     checkErrorAndRethrow().     failureRequestIndexer.processBufferedRequests(requestIndexer). }
false;public;2;2;;@Override public void beforeBulk(long executionId, BulkRequest request) { }
false;public;3;33;;@Override public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {     if (response.hasFailures()) {         BulkItemResponse itemResponse.         Throwable failure.         RestStatus restStatus.         try {             for (int i = 0. i < response.getItems().length. i++) {                 itemResponse = response.getItems()[i].                 failure = callBridge.extractFailureCauseFromBulkItemResponse(itemResponse).                 if (failure != null) {                     LOG.error("Failed Elasticsearch item request: {}", itemResponse.getFailureMessage(), failure).                     restStatus = itemResponse.getFailure().getStatus().                     if (restStatus == null) {                         failureHandler.onFailure(request.requests().get(i), failure, -1, failureRequestIndexer).                     } else {                         failureHandler.onFailure(request.requests().get(i), failure, restStatus.getStatus(), failureRequestIndexer).                     }                 }             }         } catch (Throwable t) {             // fail the sink and skip the rest of the items             // if the failure handler decides to throw an exception             failureThrowable.compareAndSet(null, t).         }     }     if (flushOnCheckpoint) {         numPendingRequests.getAndAdd(-request.numberOfActions()).     } }
false;public;3;18;;@Override public void afterBulk(long executionId, BulkRequest request, Throwable failure) {     LOG.error("Failed Elasticsearch bulk request: {}", failure.getMessage(), failure.getCause()).     try {         for (ActionRequest action : request.requests()) {             failureHandler.onFailure(action, failure, -1, failureRequestIndexer).         }     } catch (Throwable t) {         // fail the sink and skip the rest of the items         // if the failure handler decides to throw an exception         failureThrowable.compareAndSet(null, t).     }     if (flushOnCheckpoint) {         numPendingRequests.getAndAdd(-request.numberOfActions()).     } }
false;;0;9;;@VisibleForTesting long getNumPendingRequests() {     if (flushOnCheckpoint) {         return numPendingRequests.get().     } else {         throw new UnsupportedOperationException("The number of pending requests is not maintained when flushing on checkpoint is disabled.").     } }
