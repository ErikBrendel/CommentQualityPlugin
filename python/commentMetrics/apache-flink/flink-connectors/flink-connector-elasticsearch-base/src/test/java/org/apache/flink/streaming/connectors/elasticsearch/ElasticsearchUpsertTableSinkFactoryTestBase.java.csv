commented;modifiers;parameterAmount;loc;comment;code
false;public;0;55;;@Test public void testTableSink() {     // prepare parameters for Elasticsearch table sink     final TableSchema schema = createTestSchema().     final ElasticsearchUpsertTableSinkBase expectedSink = getExpectedTableSink(false, schema, Collections.singletonList(new Host(HOSTNAME, PORT, SCHEMA)), INDEX, DOC_TYPE, KEY_DELIMITER, KEY_NULL_LITERAL, new JsonRowSerializationSchema(schema.toRowType()), XContentType.JSON, new DummyFailureHandler(), createTestSinkOptions()).     // construct table sink using descriptors and table sink factory     final TestTableDescriptor testDesc = new TestTableDescriptor(new Elasticsearch().version(getElasticsearchVersion()).host(HOSTNAME, PORT, SCHEMA).index(INDEX).documentType(DOC_TYPE).keyDelimiter(KEY_DELIMITER).keyNullLiteral(KEY_NULL_LITERAL).bulkFlushBackoffExponential().bulkFlushBackoffDelay(123L).bulkFlushBackoffMaxRetries(3).bulkFlushInterval(100L).bulkFlushMaxActions(1000).bulkFlushMaxSize("1 MB").failureHandlerCustom(DummyFailureHandler.class).connectionMaxRetryTimeout(100).connectionPathPrefix("/myapp")).withFormat(new Json().deriveSchema()).withSchema(new Schema().field(FIELD_KEY, Types.LONG()).field(FIELD_FRUIT_NAME, Types.STRING()).field(FIELD_COUNT, Types.DECIMAL()).field(FIELD_TS, Types.SQL_TIMESTAMP())).inUpsertMode().     final Map<String, String> propertiesMap = testDesc.toProperties().     final TableSink<?> actualSink = TableFactoryService.find(StreamTableSinkFactory.class, propertiesMap).createStreamTableSink(propertiesMap).     assertEquals(expectedSink, actualSink). }
false;protected;0;8;;protected TableSchema createTestSchema() {     return TableSchema.builder().field(FIELD_KEY, Types.LONG()).field(FIELD_FRUIT_NAME, Types.STRING()).field(FIELD_COUNT, Types.DECIMAL()).field(FIELD_TS, Types.SQL_TIMESTAMP()).build(). }
false;protected;0;13;;protected Map<SinkOption, String> createTestSinkOptions() {     final Map<SinkOption, String> sinkOptions = new HashMap<>().     sinkOptions.put(SinkOption.BULK_FLUSH_BACKOFF_ENABLED, "true").     sinkOptions.put(SinkOption.BULK_FLUSH_BACKOFF_TYPE, "EXPONENTIAL").     sinkOptions.put(SinkOption.BULK_FLUSH_BACKOFF_DELAY, "123").     sinkOptions.put(SinkOption.BULK_FLUSH_BACKOFF_RETRIES, "3").     sinkOptions.put(SinkOption.BULK_FLUSH_INTERVAL, "100").     sinkOptions.put(SinkOption.BULK_FLUSH_MAX_ACTIONS, "1000").     sinkOptions.put(SinkOption.BULK_FLUSH_MAX_SIZE, "1048576 bytes").     sinkOptions.put(SinkOption.REST_MAX_RETRY_TIMEOUT, "100").     sinkOptions.put(SinkOption.REST_PATH_PREFIX, "/myapp").     return sinkOptions. }
false;protected,abstract;0;1;;// -------------------------------------------------------------------------------------------- // For version-specific tests // -------------------------------------------------------------------------------------------- protected abstract String getElasticsearchVersion().
false;protected,abstract;11;12;;protected abstract ElasticsearchUpsertTableSinkBase getExpectedTableSink(boolean isAppendOnly, TableSchema schema, List<Host> hosts, String index, String docType, String keyDelimiter, String keyNullLiteral, SerializationSchema<Row> serializationSchema, XContentType contentType, ActionRequestFailureHandler failureHandler, Map<SinkOption, String> sinkOptions).
false;public;4;4;;@Override public void onFailure(ActionRequest action, Throwable failure, int restStatusCode, RequestIndexer indexer) { // do nothing }
false;public;1;4;;@Override public boolean equals(Object o) {     return this == o || o instanceof DummyFailureHandler. }
false;public;0;4;;@Override public int hashCode() {     return DummyFailureHandler.class.hashCode(). }
