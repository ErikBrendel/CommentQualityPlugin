commented;modifiers;parameterAmount;loc;comment;code
false;public;2;12;;@SuppressWarnings({ "rawtypes", "unchecked" }) @Override @PublicEvolving public TypeComparator<T> createComparator(boolean sortOrderAscending, ExecutionConfig executionConfig) {     if (Comparable.class.isAssignableFrom(typeClass)) {         return new WritableComparator(sortOrderAscending, typeClass).     } else {         throw new UnsupportedOperationException("Cannot create Comparator for " + typeClass.getCanonicalName() + ". " + "Class does not implement Comparable interface.").     } }
false;public;0;5;;@Override @PublicEvolving public boolean isBasicType() {     return false. }
false;public;0;5;;@Override @PublicEvolving public boolean isTupleType() {     return false. }
false;public;0;5;;@Override @PublicEvolving public int getArity() {     return 1. }
false;public;0;5;;@Override @PublicEvolving public int getTotalFields() {     return 1. }
false;public;0;5;;@Override @PublicEvolving public Class<T> getTypeClass() {     return this.typeClass. }
false;public;0;5;;@Override @PublicEvolving public boolean isKeyType() {     return Comparable.class.isAssignableFrom(typeClass). }
false;public;1;5;;@Override @PublicEvolving public TypeSerializer<T> createSerializer(ExecutionConfig executionConfig) {     return new WritableSerializer<T>(typeClass). }
false;public;0;4;;@Override public String toString() {     return "WritableType<" + typeClass.getName() + ">". }
false;public;0;4;;@Override public int hashCode() {     return typeClass.hashCode(). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj instanceof WritableTypeInfo) {         @SuppressWarnings("unchecked")         WritableTypeInfo<T> writableTypeInfo = (WritableTypeInfo<T>) obj.         return writableTypeInfo.canEqual(this) && typeClass == writableTypeInfo.typeClass.     } else {         return false.     } }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return obj instanceof WritableTypeInfo. }
false;static;1;9;;// -------------------------------------------------------------------------------------------- @PublicEvolving static <T extends Writable> TypeInformation<T> getWritableTypeInfo(Class<T> typeClass) {     if (Writable.class.isAssignableFrom(typeClass) && !typeClass.equals(Writable.class)) {         return new WritableTypeInfo<T>(typeClass).     } else {         throw new InvalidTypesException("The given class is no subclass of " + Writable.class.getName()).     } }
