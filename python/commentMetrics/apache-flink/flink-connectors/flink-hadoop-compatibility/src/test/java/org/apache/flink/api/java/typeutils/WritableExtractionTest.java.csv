commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Test public void testDetectWritable() {     // writable interface itself must not be writable     assertFalse(TypeExtractor.isHadoopWritable(Writable.class)).     // various forms of extension     assertTrue(TypeExtractor.isHadoopWritable(DirectWritable.class)).     assertTrue(TypeExtractor.isHadoopWritable(ViaInterfaceExtension.class)).     assertTrue(TypeExtractor.isHadoopWritable(ViaAbstractClassExtension.class)).     // some non-writables     assertFalse(TypeExtractor.isHadoopWritable(String.class)).     assertFalse(TypeExtractor.isHadoopWritable(List.class)).     assertFalse(TypeExtractor.isHadoopWritable(WritableComparator.class)). }
false;public;0;14;;@Test public void testCreateWritableInfo() {     TypeInformation<DirectWritable> info1 = TypeExtractor.createHadoopWritableTypeInfo(DirectWritable.class).     assertEquals(DirectWritable.class, info1.getTypeClass()).     TypeInformation<ViaInterfaceExtension> info2 = TypeExtractor.createHadoopWritableTypeInfo(ViaInterfaceExtension.class).     assertEquals(ViaInterfaceExtension.class, info2.getTypeClass()).     TypeInformation<ViaAbstractClassExtension> info3 = TypeExtractor.createHadoopWritableTypeInfo(ViaAbstractClassExtension.class).     assertEquals(ViaAbstractClassExtension.class, info3.getTypeClass()). }
false;public;0;31;;@Test public void testValidateTypeInfo() {     // validate unrelated type info     TypeExtractor.validateIfWritable(BasicTypeInfo.STRING_TYPE_INFO, String.class).     // validate writable type info correctly     TypeExtractor.validateIfWritable(new WritableTypeInfo<>(DirectWritable.class), DirectWritable.class).     TypeExtractor.validateIfWritable(new WritableTypeInfo<>(ViaInterfaceExtension.class), ViaInterfaceExtension.class).     TypeExtractor.validateIfWritable(new WritableTypeInfo<>(ViaAbstractClassExtension.class), ViaAbstractClassExtension.class).     // incorrect case: not writable at all     try {         TypeExtractor.validateIfWritable(new WritableTypeInfo<>(DirectWritable.class), String.class).         fail("should have failed with an exception").     } catch (InvalidTypesException e) {     // expected     }     // incorrect case: wrong writable     try {         TypeExtractor.validateIfWritable(new WritableTypeInfo<>(ViaInterfaceExtension.class), DirectWritable.class).         fail("should have failed with an exception").     } catch (InvalidTypesException e) {     // expected     } }
false;public;1;4;;@Override public DirectWritable map(DirectWritable value) throws Exception {     return null. }
false;public;0;15;;@Test public void testExtractFromFunction() {     RichMapFunction<DirectWritable, DirectWritable> function = new RichMapFunction<DirectWritable, DirectWritable>() {          @Override         public DirectWritable map(DirectWritable value) throws Exception {             return null.         }     }.     TypeInformation<DirectWritable> outType = TypeExtractor.getMapReturnTypes(function, new WritableTypeInfo<>(DirectWritable.class)).     assertTrue(outType instanceof WritableTypeInfo).     assertEquals(DirectWritable.class, outType.getTypeClass()). }
false;public;0;23;;@Test public void testExtractAsPartOfPojo() {     PojoTypeInfo<PojoWithWritable> pojoInfo = (PojoTypeInfo<PojoWithWritable>) TypeExtractor.getForClass(PojoWithWritable.class).     boolean foundWritable = false.     for (int i = 0. i < pojoInfo.getArity(). i++) {         PojoField field = pojoInfo.getPojoFieldAt(i).         String name = field.getField().getName().         if (name.equals("hadoopCitizen")) {             if (foundWritable) {                 fail("already seen").             }             foundWritable = true.             assertEquals(new WritableTypeInfo<>(DirectWritable.class), field.getTypeInformation()).             assertEquals(DirectWritable.class, field.getTypeInformation().getTypeClass()).         }     }     assertTrue("missed the writable type", foundWritable). }
false;public;1;4;;@Override public String map(Writable value) throws Exception {     return null. }
false;public;0;22;;@Test public void testInputValidationError() {     RichMapFunction<Writable, String> function = new RichMapFunction<Writable, String>() {          @Override         public String map(Writable value) throws Exception {             return null.         }     }.     @SuppressWarnings("unchecked")     TypeInformation<Writable> inType = (TypeInformation<Writable>) (TypeInformation<?>) new WritableTypeInfo<>(DirectWritable.class).     try {         TypeExtractor.getMapReturnTypes(function, inType).         fail("exception expected").     } catch (InvalidTypesException e) {     // right     } }
false;public;1;2;;@Override public void write(DataOutput dataOutput) throws IOException { }
false;public;1;2;;@Override public void readFields(DataInput dataInput) throws IOException { }
false;public;1;2;;@Override public void write(DataOutput dataOutput) throws IOException { }
false;public;1;2;;@Override public void readFields(DataInput dataInput) throws IOException { }
false;public;1;2;;@Override public void write(DataOutput dataOutput) throws IOException { }
false;public;1;2;;@Override public void readFields(DataInput dataInput) throws IOException { }
