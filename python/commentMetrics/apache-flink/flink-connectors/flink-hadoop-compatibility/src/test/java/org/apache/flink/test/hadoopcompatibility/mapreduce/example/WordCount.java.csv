commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;38;;public static void main(String[] args) throws Exception {     if (args.length < 2) {         System.err.println("Usage: WordCount <input path> <result path>").         return.     }     final String inputPath = args[0].     final String outputPath = args[1].     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     // Set up the Hadoop Input Format     Job job = Job.getInstance().     HadoopInputFormat<LongWritable, Text> hadoopInputFormat = new HadoopInputFormat<LongWritable, Text>(new TextInputFormat(), LongWritable.class, Text.class, job).     TextInputFormat.addInputPath(job, new Path(inputPath)).     // Create a Flink job with it     DataSet<Tuple2<LongWritable, Text>> text = env.createInput(hadoopInputFormat).     // Tokenize the line and convert from Writable "Text" to String for better handling     DataSet<Tuple2<String, Integer>> words = text.flatMap(new Tokenizer()).     // Sum up the words     DataSet<Tuple2<String, Integer>> result = words.groupBy(0).aggregate(Aggregations.SUM, 1).     // Convert String back to Writable "Text" for use with Hadoop Output Format     DataSet<Tuple2<Text, IntWritable>> hadoopResult = result.map(new HadoopDatatypeMapper()).     // Set up Hadoop Output Format     HadoopOutputFormat<Text, IntWritable> hadoopOutputFormat = new HadoopOutputFormat<Text, IntWritable>(new TextOutputFormat<Text, IntWritable>(), job).     hadoopOutputFormat.getConfiguration().set("mapreduce.output.textoutputformat.separator", " ").     // set the value for both, since this test     hadoopOutputFormat.getConfiguration().set("mapred.textoutputformat.separator", " ").     TextOutputFormat.setOutputPath(job, new Path(outputPath)).     // Output & Execute     hadoopResult.output(hadoopOutputFormat).     env.execute("Word Count"). }
false;public;2;13;;@Override public void flatMap(Tuple2<LongWritable, Text> value, Collector<Tuple2<String, Integer>> out) {     // normalize and split the line     String line = value.f1.toString().     String[] tokens = line.toLowerCase().split("\\W+").     // emit the pairs     for (String token : tokens) {         if (token.length() > 0) {             out.collect(new Tuple2<String, Integer>(token, 1)).         }     } }
false;public;1;4;;@Override public Tuple2<Text, IntWritable> map(Tuple2<String, Integer> value) throws Exception {     return new Tuple2<Text, IntWritable>(new Text(value.f0), new IntWritable(value.f1)). }
