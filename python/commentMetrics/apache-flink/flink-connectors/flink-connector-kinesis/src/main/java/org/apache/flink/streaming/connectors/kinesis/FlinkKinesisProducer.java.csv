commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public ByteBuffer serialize(OUT element) {     // wrap into ByteBuffer     return ByteBuffer.wrap(schema.serialize(element)). }
false;public;1;4;;// use default stream and hash key @Override public String getTargetStream(OUT element) {     return null. }
true;public;1;3;/**  * If set to true, the producer will immediately fail with an exception on any error.  * Otherwise, the errors are logged and the producer goes on.  *  * @param failOnError Error behavior flag  */ ;/**  * If set to true, the producer will immediately fail with an exception on any error.  * Otherwise, the errors are logged and the producer goes on.  *  * @param failOnError Error behavior flag  */ public void setFailOnError(boolean failOnError) {     this.failOnError = failOnError. }
true;public;1;4;/**  * The {@link KinesisProducer} holds an unbounded queue internally. To avoid memory  * problems under high loads, a limit can be employed above which the internal queue  * will be flushed, thereby applying backpressure.  *  * @param queueLimit The maximum length of the internal queue before backpressuring  */ ;/**  * The {@link KinesisProducer} holds an unbounded queue internally. To avoid memory  * problems under high loads, a limit can be employed above which the internal queue  * will be flushed, thereby applying backpressure.  *  * @param queueLimit The maximum length of the internal queue before backpressuring  */ public void setQueueLimit(int queueLimit) {     checkArgument(queueLimit > 0, "queueLimit must be a positive number").     this.queueLimit = queueLimit. }
true;public;1;3;/**  * Set a default stream name.  * @param defaultStream Name of the default Kinesis stream  */ ;/**  * Set a default stream name.  * @param defaultStream Name of the default Kinesis stream  */ public void setDefaultStream(String defaultStream) {     this.defaultStream = defaultStream. }
true;public;1;3;/**  * Set default partition id.  * @param defaultPartition Name of the default partition  */ ;/**  * Set default partition id.  * @param defaultPartition Name of the default partition  */ public void setDefaultPartition(String defaultPartition) {     this.defaultPartition = defaultPartition. }
false;public;1;9;;public void setCustomPartitioner(KinesisPartitioner<OUT> partitioner) {     checkNotNull(partitioner, "partitioner cannot be null").     checkArgument(InstantiationUtil.isSerializable(partitioner), "The provided custom partitioner is not serializable: " + partitioner.getClass().getName() + ". " + "Please check that it does not contain references to non-serializable instances.").     this.customPartitioner = partitioner. }
false;public;1;14;;@Override public void onSuccess(UserRecordResult result) {     backpressureLatch.trigger().     if (!result.isSuccessful()) {         if (failOnError) {             // only remember the first thrown exception             if (thrownException == null) {                 thrownException = new RuntimeException("Record was not sent successful").             }         } else {             LOG.warn("Record was not sent successful").         }     } }
false;public;1;9;;@Override public void onFailure(Throwable t) {     backpressureLatch.trigger().     if (failOnError) {         thrownException = t.     } else {         LOG.warn("An exception occurred while processing a record", t).     } }
false;public;1;47;;// --------------------------- Lifecycle methods --------------------------- @Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     // check and pass the configuration properties     KinesisProducerConfiguration producerConfig = KinesisConfigUtil.getValidatedProducerConfiguration(configProps).     producer = getKinesisProducer(producerConfig).     final MetricGroup kinesisMectricGroup = getRuntimeContext().getMetricGroup().addGroup(KINESIS_PRODUCER_METRIC_GROUP).     this.backpressureCycles = kinesisMectricGroup.counter(METRIC_BACKPRESSURE_CYCLES).     kinesisMectricGroup.gauge(METRIC_OUTSTANDING_RECORDS_COUNT, producer::getOutstandingRecordsCount).     backpressureLatch = new TimeoutLatch().     callback = new FutureCallback<UserRecordResult>() {          @Override         public void onSuccess(UserRecordResult result) {             backpressureLatch.trigger().             if (!result.isSuccessful()) {                 if (failOnError) {                     // only remember the first thrown exception                     if (thrownException == null) {                         thrownException = new RuntimeException("Record was not sent successful").                     }                 } else {                     LOG.warn("Record was not sent successful").                 }             }         }          @Override         public void onFailure(Throwable t) {             backpressureLatch.trigger().             if (failOnError) {                 thrownException = t.             } else {                 LOG.warn("An exception occurred while processing a record", t).             }         }     }.     if (this.customPartitioner != null) {         this.customPartitioner.initialize(getRuntimeContext().getIndexOfThisSubtask(), getRuntimeContext().getNumberOfParallelSubtasks()).     }     LOG.info("Started Kinesis producer instance for region '{}'", producerConfig.getRegion()). }
false;public;2;43;;@Override public void invoke(OUT value, Context context) throws Exception {     if (this.producer == null) {         throw new RuntimeException("Kinesis producer has been closed").     }     checkAndPropagateAsyncError().     boolean didWaitForFlush = enforceQueueLimit().     if (didWaitForFlush) {         checkAndPropagateAsyncError().     }     String stream = defaultStream.     String partition = defaultPartition.     ByteBuffer serialized = schema.serialize(value).     // maybe set custom stream     String customStream = schema.getTargetStream(value).     if (customStream != null) {         stream = customStream.     }     String explicitHashkey = null.     // maybe set custom partition     if (customPartitioner != null) {         partition = customPartitioner.getPartitionId(value).         explicitHashkey = customPartitioner.getExplicitHashKey(value).     }     if (stream == null) {         if (failOnError) {             throw new RuntimeException("No target stream set").         } else {             LOG.warn("No target stream set. Skipping record").             return.         }     }     ListenableFuture<UserRecordResult> cb = producer.addUserRecord(stream, partition, explicitHashkey, serialized).     Futures.addCallback(cb, callback). }
false;public;0;18;;@Override public void close() throws Exception {     LOG.info("Closing producer").     super.close().     if (producer != null) {         LOG.info("Flushing outstanding {} records", producer.getOutstandingRecordsCount()).         // try to flush all outstanding records         flushSync().         LOG.info("Flushing done. Destroying producer instance.").         producer.destroy().         producer = null.     }     // make sure we propagate pending errors     checkAndPropagateAsyncError(). }
false;public;1;4;;@Override public void initializeState(FunctionInitializationContext context) throws Exception { // nothing to do }
false;public;1;14;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     // check for asynchronous errors and fail the checkpoint if necessary     checkAndPropagateAsyncError().     flushSync().     if (producer.getOutstandingRecordsCount() > 0) {         throw new IllegalStateException("Number of outstanding records must be zero at this point: " + producer.getOutstandingRecordsCount()).     }     // if the flushed requests has errors, we should propagate it also and fail the checkpoint     checkAndPropagateAsyncError(). }
true;protected;1;4;/**  * Creates a {@link KinesisProducer}.  * Exposed so that tests can inject mock producers easily.  */ ;// --------------------------- Utilities --------------------------- /**  * Creates a {@link KinesisProducer}.  * Exposed so that tests can inject mock producers easily.  */ @VisibleForTesting protected KinesisProducer getKinesisProducer(KinesisProducerConfiguration producerConfig) {     return new KinesisProducer(producerConfig). }
true;private;0;21;/**  * Check if there are any asynchronous exceptions. If so, rethrow the exception.  */ ;/**  * Check if there are any asynchronous exceptions. If so, rethrow the exception.  */ private void checkAndPropagateAsyncError() throws Exception {     if (thrownException != null) {         String errorMessages = "".         if (thrownException instanceof UserRecordFailedException) {             List<Attempt> attempts = ((UserRecordFailedException) thrownException).getResult().getAttempts().             for (Attempt attempt : attempts) {                 if (attempt.getErrorMessage() != null) {                     errorMessages += attempt.getErrorMessage() + "\n".                 }             }         }         if (failOnError) {             throw new RuntimeException("An exception was thrown while processing a record: " + errorMessages, thrownException).         } else {             LOG.warn("An exception was thrown while processing a record: {}", thrownException, errorMessages).             // reset, prevent double throwing             thrownException = null.         }     } }
true;private;0;17;/**  * If the internal queue of the {@link KinesisProducer} gets too long,  * flush some of the records until we are below the limit again.  * We don't want to flush _all_ records at this point since that would  * break record aggregation.  *  * @return boolean whether flushing occurred or not  */ ;/**  * If the internal queue of the {@link KinesisProducer} gets too long,  * flush some of the records until we are below the limit again.  * We don't want to flush _all_ records at this point since that would  * break record aggregation.  *  * @return boolean whether flushing occurred or not  */ private boolean enforceQueueLimit() {     int attempt = 0.     while (producer.getOutstandingRecordsCount() >= queueLimit) {         backpressureCycles.inc().         if (attempt >= 10) {             LOG.warn("Waiting for the queue length to drop below the limit takes unusually long, still not done after {} attempts.", attempt).         }         attempt++.         try {             backpressureLatch.await(100).         } catch (InterruptedException e) {             LOG.warn("Flushing was interrupted.").             break.         }     }     return attempt > 0. }
true;private;0;11;/**  * A reimplementation of {@link KinesisProducer#flushSync()}.  * This implementation releases the block on flushing if an interruption occurred.  */ ;/**  * A reimplementation of {@link KinesisProducer#flushSync()}.  * This implementation releases the block on flushing if an interruption occurred.  */ private void flushSync() throws Exception {     while (producer.getOutstandingRecordsCount() > 0) {         producer.flush().         try {             Thread.sleep(500).         } catch (InterruptedException e) {             LOG.warn("Flushing was interrupted.").             break.         }     } }
