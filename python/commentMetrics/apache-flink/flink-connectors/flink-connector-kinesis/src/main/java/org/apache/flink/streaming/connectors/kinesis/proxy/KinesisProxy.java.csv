# id;timestamp;commentText;codeText;commentWords;codeWords
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1480685315;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1484926180;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1485238807;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1495787238;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1495923079;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1515177485;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1515757408;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1515757408;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1521204705;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1524053374;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1525262671;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1529652657;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1534479479;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1545495597;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> public static KinesisProxyInterface create(Properties configProps);1549739849;Creates a Kinesis proxy.__@param configProps configuration properties_@return the created kinesis proxy;public static KinesisProxyInterface create(Properties configProps) {_		return new KinesisProxy(configProps)__	};creates,a,kinesis,proxy,param,config,props,configuration,properties,return,the,created,kinesis,proxy;public,static,kinesis,proxy,interface,create,properties,config,props,return,new,kinesis,proxy,config,props
KinesisProxy -> protected KinesisProxy(Properties configProps);1521204705;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;protected KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = AWSUtil.createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;protected,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,awsutil,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> protected KinesisProxy(Properties configProps);1524053374;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;protected KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;protected,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> protected KinesisProxy(Properties configProps);1525262671;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;protected KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;protected,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> protected KinesisProxy(Properties configProps);1529652657;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;protected KinesisProxy(Properties configProps) {_		checkNotNull(configProps)__		KinesisConfigUtil.replaceDeprecatedConsumerKeys(configProps)___		this.kinesisClient = createKinesisClient(configProps)___		this.listShardsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_BASE)))__		this.listShardsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_MAX)))__		this.listShardsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;protected,kinesis,proxy,properties,config,props,check,not,null,config,props,kinesis,config,util,replace,deprecated,consumer,keys,config,props,this,kinesis,client,create,kinesis,client,config,props,this,list,shards,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,list,shards,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,list,shards,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> protected KinesisProxy(Properties configProps);1534479479;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;protected KinesisProxy(Properties configProps) {_		checkNotNull(configProps)__		KinesisConfigUtil.replaceDeprecatedConsumerKeys(configProps)___		this.kinesisClient = createKinesisClient(configProps)___		this.listShardsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_BASE)))__		this.listShardsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_MAX)))__		this.listShardsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.listShardsMaxRetries = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_RETRIES)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxRetries = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxRetries = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;protected,kinesis,proxy,properties,config,props,check,not,null,config,props,kinesis,config,util,replace,deprecated,consumer,keys,config,props,this,kinesis,client,create,kinesis,client,config,props,this,list,shards,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,list,shards,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,list,shards,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,list,shards,max,retries,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,retries,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,retries,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> protected KinesisProxy(Properties configProps);1545495597;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;protected KinesisProxy(Properties configProps) {_		checkNotNull(configProps)__		KinesisConfigUtil.backfillConsumerKeys(configProps)___		this.kinesisClient = createKinesisClient(configProps)___		this.listShardsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_BASE)))__		this.listShardsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_MAX)))__		this.listShardsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.listShardsMaxRetries = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_RETRIES)))__		this.describeStreamBaseBackoffMillis = Long.valueOf(_				configProps.getProperty(ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_						Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_				configProps.getProperty(ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_						Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_				configProps.getProperty(ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_						Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxRetries = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxRetries = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;protected,kinesis,proxy,properties,config,props,check,not,null,config,props,kinesis,config,util,backfill,consumer,keys,config,props,this,kinesis,client,create,kinesis,client,config,props,this,list,shards,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,list,shards,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,list,shards,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,list,shards,max,retries,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,retries,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,retries,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> protected KinesisProxy(Properties configProps);1549739849;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;protected KinesisProxy(Properties configProps) {_		checkNotNull(configProps)__		KinesisConfigUtil.backfillConsumerKeys(configProps)___		this.kinesisClient = createKinesisClient(configProps)___		this.listShardsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_BASE)))__		this.listShardsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_MAX)))__		this.listShardsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.listShardsMaxRetries = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.LIST_SHARDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_LIST_SHARDS_RETRIES)))__		this.describeStreamBaseBackoffMillis = Long.valueOf(_				configProps.getProperty(ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_						Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_				configProps.getProperty(ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_						Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_				configProps.getProperty(ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_						Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxRetries = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxRetries = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;protected,kinesis,proxy,properties,config,props,check,not,null,config,props,kinesis,config,util,backfill,consumer,keys,config,props,this,kinesis,client,create,kinesis,client,config,props,this,list,shards,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,list,shards,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,list,shards,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,list,shards,max,retries,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,retries,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,retries,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1480685315;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (KinesisStreamShard.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,kinesis,stream,shard,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1484926180;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (KinesisStreamShard.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,kinesis,stream,shard,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1485238807;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (KinesisStreamShard.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,kinesis,stream,shard,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1495787238;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1495923079;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1515177485;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1515757408;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1515757408;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1521204705;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1524053374;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException;1525262671;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_					describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++)__				LOG.warn("Got LimitExceededException when describing stream " + streamName + ". Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn("The status of stream " + streamName + " is " + streamStatus + "_ result of the current " +_					"describeStream operation will not contain any shard information.")__			}_		}__		_		_		if (startShardId != null) {_			List<Shard> shards = describeStreamResult.getStreamDescription().getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,describing,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,the,status,of,stream,stream,name,is,stream,status,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,if,start,shard,id,null,list,shard,shards,describe,stream,result,get,stream,description,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,describe,stream,result
KinesisProxy -> protected AmazonKinesis createKinesisClient(Properties configProps);1524053374;Create the Kinesis client, using the provided configuration properties and default {@link ClientConfiguration}._Derived classes can override this method to customize the client configuration._@param configProps_@return;protected AmazonKinesis createKinesisClient(Properties configProps) {_		return AWSUtil.createKinesisClient(configProps, new ClientConfigurationFactory().getConfig())__	};create,the,kinesis,client,using,the,provided,configuration,properties,and,default,link,client,configuration,derived,classes,can,override,this,method,to,customize,the,client,configuration,param,config,props,return;protected,amazon,kinesis,create,kinesis,client,properties,config,props,return,awsutil,create,kinesis,client,config,props,new,client,configuration,factory,get,config
KinesisProxy -> protected AmazonKinesis createKinesisClient(Properties configProps);1525262671;Create the Kinesis client, using the provided configuration properties and default {@link ClientConfiguration}._Derived classes can override this method to customize the client configuration._@param configProps_@return;protected AmazonKinesis createKinesisClient(Properties configProps) {__		ClientConfiguration awsClientConfig = new ClientConfigurationFactory().getConfig()__		AWSUtil.setAwsClientConfigProperties(awsClientConfig, configProps)__		return AWSUtil.createKinesisClient(configProps, awsClientConfig)__	};create,the,kinesis,client,using,the,provided,configuration,properties,and,default,link,client,configuration,derived,classes,can,override,this,method,to,customize,the,client,configuration,param,config,props,return;protected,amazon,kinesis,create,kinesis,client,properties,config,props,client,configuration,aws,client,config,new,client,configuration,factory,get,config,awsutil,set,aws,client,config,properties,aws,client,config,config,props,return,awsutil,create,kinesis,client,config,props,aws,client,config
KinesisProxy -> protected AmazonKinesis createKinesisClient(Properties configProps);1529652657;Create the Kinesis client, using the provided configuration properties and default {@link ClientConfiguration}._Derived classes can override this method to customize the client configuration._@param configProps_@return;protected AmazonKinesis createKinesisClient(Properties configProps) {__		ClientConfiguration awsClientConfig = new ClientConfigurationFactory().getConfig()__		AWSUtil.setAwsClientConfigProperties(awsClientConfig, configProps)__		return AWSUtil.createKinesisClient(configProps, awsClientConfig)__	};create,the,kinesis,client,using,the,provided,configuration,properties,and,default,link,client,configuration,derived,classes,can,override,this,method,to,customize,the,client,configuration,param,config,props,return;protected,amazon,kinesis,create,kinesis,client,properties,config,props,client,configuration,aws,client,config,new,client,configuration,factory,get,config,awsutil,set,aws,client,config,properties,aws,client,config,config,props,return,awsutil,create,kinesis,client,config,props,aws,client,config
KinesisProxy -> protected AmazonKinesis createKinesisClient(Properties configProps);1534479479;Create the Kinesis client, using the provided configuration properties and default {@link ClientConfiguration}._Derived classes can override this method to customize the client configuration._@param configProps_@return;protected AmazonKinesis createKinesisClient(Properties configProps) {__		ClientConfiguration awsClientConfig = new ClientConfigurationFactory().getConfig()__		AWSUtil.setAwsClientConfigProperties(awsClientConfig, configProps)__		return AWSUtil.createKinesisClient(configProps, awsClientConfig)__	};create,the,kinesis,client,using,the,provided,configuration,properties,and,default,link,client,configuration,derived,classes,can,override,this,method,to,customize,the,client,configuration,param,config,props,return;protected,amazon,kinesis,create,kinesis,client,properties,config,props,client,configuration,aws,client,config,new,client,configuration,factory,get,config,awsutil,set,aws,client,config,properties,aws,client,config,config,props,return,awsutil,create,kinesis,client,config,props,aws,client,config
KinesisProxy -> protected AmazonKinesis createKinesisClient(Properties configProps);1545495597;Create the Kinesis client, using the provided configuration properties and default {@link ClientConfiguration}._Derived classes can override this method to customize the client configuration._@param configProps_@return;protected AmazonKinesis createKinesisClient(Properties configProps) {__		ClientConfiguration awsClientConfig = new ClientConfigurationFactory().getConfig()__		AWSUtil.setAwsClientConfigProperties(awsClientConfig, configProps)__		return AWSUtil.createKinesisClient(configProps, awsClientConfig)__	};create,the,kinesis,client,using,the,provided,configuration,properties,and,default,link,client,configuration,derived,classes,can,override,this,method,to,customize,the,client,configuration,param,config,props,return;protected,amazon,kinesis,create,kinesis,client,properties,config,props,client,configuration,aws,client,config,new,client,configuration,factory,get,config,awsutil,set,aws,client,config,properties,aws,client,config,config,props,return,awsutil,create,kinesis,client,config,props,aws,client,config
KinesisProxy -> protected AmazonKinesis createKinesisClient(Properties configProps);1549739849;Create the Kinesis client, using the provided configuration properties and default {@link ClientConfiguration}._Derived classes can override this method to customize the client configuration._@param configProps_@return;protected AmazonKinesis createKinesisClient(Properties configProps) {__		ClientConfiguration awsClientConfig = new ClientConfigurationFactory().getConfig()__		AWSUtil.setAwsClientConfigProperties(awsClientConfig, configProps)__		return AWSUtil.createKinesisClient(configProps, awsClientConfig)__	};create,the,kinesis,client,using,the,provided,configuration,properties,and,default,link,client,configuration,derived,classes,can,override,this,method,to,customize,the,client,configuration,param,config,props,return;protected,amazon,kinesis,create,kinesis,client,properties,config,props,client,configuration,aws,client,config,new,client,configuration,factory,get,config,awsutil,set,aws,client,config,properties,aws,client,config,config,props,return,awsutil,create,kinesis,client,config,props,aws,client,config
KinesisProxy -> protected DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) 			throws InterruptedException;1545495597;Get metainfo for a Kinesis stream, which contains information about which shards this_Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">_"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher._This jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation__@return the result of the describe stream operation;protected DescribeStreamResult describeStream(String streamName, @Nullable String startShardId)_			throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_						describeStreamBaseBackoffMillis,_						describeStreamMaxBackoffMillis,_						describeStreamExpConstant,_						attemptCount++)__				LOG.warn(String.format("Got LimitExceededException when describing stream %s. "_						+ "Backing off for %d millis.", streamName, backoffMillis))__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString())_				|| streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn(String.format("The status of stream %s is %s _ result of the current "_								+ "describeStream operation will not contain any shard information.",_						streamName, streamStatus))__			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,return,the,result,of,the,describe,stream,operation;protected,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,string,format,got,limit,exceeded,exception,when,describing,stream,s,backing,off,for,d,millis,stream,name,backoff,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,string,format,the,status,of,stream,s,is,s,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,stream,name,stream,status,return,describe,stream,result
KinesisProxy -> protected DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) 			throws InterruptedException;1549739849;Get metainfo for a Kinesis stream, which contains information about which shards this_Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">_"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher._This jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation__@return the result of the describe stream operation;protected DescribeStreamResult describeStream(String streamName, @Nullable String startShardId)_			throws InterruptedException {_		final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest()__		describeStreamRequest.setStreamName(streamName)__		describeStreamRequest.setExclusiveStartShardId(startShardId)___		DescribeStreamResult describeStreamResult = null___		_		int attemptCount = 0__		while (describeStreamResult == null) { _			try {_				describeStreamResult = kinesisClient.describeStream(describeStreamRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_						describeStreamBaseBackoffMillis,_						describeStreamMaxBackoffMillis,_						describeStreamExpConstant,_						attemptCount++)__				LOG.warn(String.format("Got LimitExceededException when describing stream %s. "_						+ "Backing off for %d millis.", streamName, backoffMillis))__				Thread.sleep(backoffMillis)__			} catch (ResourceNotFoundException re) {_				throw new RuntimeException("Error while getting stream details", re)__			}_		}__		String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus()__		if (!(streamStatus.equals(StreamStatus.ACTIVE.toString())_				|| streamStatus.equals(StreamStatus.UPDATING.toString()))) {_			if (LOG.isWarnEnabled()) {_				LOG.warn(String.format("The status of stream %s is %s _ result of the current "_								+ "describeStream operation will not contain any shard information.",_						streamName, streamStatus))__			}_		}__		return describeStreamResult__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,return,the,result,of,the,describe,stream,operation;protected,describe,stream,result,describe,stream,string,stream,name,nullable,string,start,shard,id,throws,interrupted,exception,final,describe,stream,request,describe,stream,request,new,describe,stream,request,describe,stream,request,set,stream,name,stream,name,describe,stream,request,set,exclusive,start,shard,id,start,shard,id,describe,stream,result,describe,stream,result,null,int,attempt,count,0,while,describe,stream,result,null,try,describe,stream,result,kinesis,client,describe,stream,describe,stream,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,describe,stream,base,backoff,millis,describe,stream,max,backoff,millis,describe,stream,exp,constant,attempt,count,log,warn,string,format,got,limit,exceeded,exception,when,describing,stream,s,backing,off,for,d,millis,stream,name,backoff,millis,thread,sleep,backoff,millis,catch,resource,not,found,exception,re,throw,new,runtime,exception,error,while,getting,stream,details,re,string,stream,status,describe,stream,result,get,stream,description,get,stream,status,if,stream,status,equals,stream,status,active,to,string,stream,status,equals,stream,status,updating,to,string,if,log,is,warn,enabled,log,warn,string,format,the,status,of,stream,s,is,s,result,of,the,current,describe,stream,operation,will,not,contain,any,shard,information,stream,name,stream,status,return,describe,stream,result
KinesisProxy -> @Override 	public String getShardIterator(KinesisStreamShard shard, String shardIteratorType, @Nullable String startingSeqNum) throws InterruptedException;1480685315;{@inheritDoc};@Override_	public String getShardIterator(KinesisStreamShard shard, String shardIteratorType, @Nullable String startingSeqNum) throws InterruptedException {_		GetShardIteratorResult getShardIteratorResult = null___		int attempt = 0__		while (attempt <= getShardIteratorMaxAttempts && getShardIteratorResult == null) {_			try {_				getShardIteratorResult =_					kinesisClient.getShardIterator(shard.getStreamName(), shard.getShard().getShardId(), shardIteratorType, startingSeqNum)__			} catch (ProvisionedThroughputExceededException ex) {_				long backoffMillis = fullJitterBackoff(_					getShardIteratorBaseBackoffMillis, getShardIteratorMaxBackoffMillis, getShardIteratorExpConstant, attempt++)__				LOG.warn("Got ProvisionedThroughputExceededException. Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			}_		}__		if (getShardIteratorResult == null) {_			throw new RuntimeException("Rate Exceeded for getShardIterator operation - all " + getShardIteratorMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}_		return getShardIteratorResult.getShardIterator()__	};inherit,doc;override,public,string,get,shard,iterator,kinesis,stream,shard,shard,string,shard,iterator,type,nullable,string,starting,seq,num,throws,interrupted,exception,get,shard,iterator,result,get,shard,iterator,result,null,int,attempt,0,while,attempt,get,shard,iterator,max,attempts,get,shard,iterator,result,null,try,get,shard,iterator,result,kinesis,client,get,shard,iterator,shard,get,stream,name,shard,get,shard,get,shard,id,shard,iterator,type,starting,seq,num,catch,provisioned,throughput,exceeded,exception,ex,long,backoff,millis,full,jitter,backoff,get,shard,iterator,base,backoff,millis,get,shard,iterator,max,backoff,millis,get,shard,iterator,exp,constant,attempt,log,warn,got,provisioned,throughput,exceeded,exception,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,if,get,shard,iterator,result,null,throw,new,runtime,exception,rate,exceeded,for,get,shard,iterator,operation,all,get,shard,iterator,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,shard,iterator,result,get,shard,iterator
KinesisProxy -> @Override 	public String getShardIterator(KinesisStreamShard shard, String shardIteratorType, @Nullable String startingSeqNum) throws InterruptedException;1484926180;{@inheritDoc};@Override_	public String getShardIterator(KinesisStreamShard shard, String shardIteratorType, @Nullable String startingSeqNum) throws InterruptedException {_		GetShardIteratorResult getShardIteratorResult = null___		int attempt = 0__		while (attempt <= getShardIteratorMaxAttempts && getShardIteratorResult == null) {_			try {_				getShardIteratorResult =_					kinesisClient.getShardIterator(shard.getStreamName(), shard.getShard().getShardId(), shardIteratorType, startingSeqNum)__			} catch (AmazonServiceException ex) {_				if (isRecoverableException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getShardIteratorBaseBackoffMillis, getShardIteratorMaxBackoffMillis, getShardIteratorExpConstant, attempt++)__					LOG.warn("Got recoverable AmazonServiceException. Backing off for "_						+ backoffMillis + " millis (" + ex.getErrorMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getShardIteratorResult == null) {_			throw new RuntimeException("Rate Exceeded for getShardIterator operation - all " + getShardIteratorMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}_		return getShardIteratorResult.getShardIterator()__	};inherit,doc;override,public,string,get,shard,iterator,kinesis,stream,shard,shard,string,shard,iterator,type,nullable,string,starting,seq,num,throws,interrupted,exception,get,shard,iterator,result,get,shard,iterator,result,null,int,attempt,0,while,attempt,get,shard,iterator,max,attempts,get,shard,iterator,result,null,try,get,shard,iterator,result,kinesis,client,get,shard,iterator,shard,get,stream,name,shard,get,shard,get,shard,id,shard,iterator,type,starting,seq,num,catch,amazon,service,exception,ex,if,is,recoverable,exception,ex,long,backoff,millis,full,jitter,backoff,get,shard,iterator,base,backoff,millis,get,shard,iterator,max,backoff,millis,get,shard,iterator,exp,constant,attempt,log,warn,got,recoverable,amazon,service,exception,backing,off,for,backoff,millis,millis,ex,get,error,message,thread,sleep,backoff,millis,else,throw,ex,if,get,shard,iterator,result,null,throw,new,runtime,exception,rate,exceeded,for,get,shard,iterator,operation,all,get,shard,iterator,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,shard,iterator,result,get,shard,iterator
KinesisProxy -> private ListShardsResult listShards(String streamName, @Nullable String startShardId, 																			@Nullable String startNextToken) 			throws InterruptedException;1529652657;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private ListShardsResult listShards(String streamName, @Nullable String startShardId,_																			@Nullable String startNextToken)_			throws InterruptedException {_		final ListShardsRequest listShardsRequest = new ListShardsRequest()__		if (startNextToken == null) {_			listShardsRequest.setExclusiveStartShardId(startShardId)__			listShardsRequest.setStreamName(streamName)__		} else {_			_			listShardsRequest.setNextToken(startNextToken)__		}__		ListShardsResult listShardsResults = null___		_		int attemptCount = 0__		_		_		while (listShardsResults == null) { _			try {__				listShardsResults = kinesisClient.listShards(listShardsRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_						listShardsBaseBackoffMillis, listShardsMaxBackoffMillis, listShardsExpConstant, attemptCount++)__					LOG.warn("Got LimitExceededException when listing shards from stream " + streamName_									+ ". Backing off for " + backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceInUseException reInUse) {_				if (LOG.isWarnEnabled()) {_					_					LOG.info("The stream is currently not in active state. Reusing the older state "_							+ "for the time being")__					break__				}_			} catch (ResourceNotFoundException reNotFound) {_				throw new RuntimeException("Stream not found. Error while getting shard list.", reNotFound)__			} catch (InvalidArgumentException inArg) {_				throw new RuntimeException("Invalid Arguments to listShards.", inArg)__			} catch (ExpiredNextTokenException expiredToken) {_				LOG.warn("List Shards has an expired token. Reusing the previous state.")__				break__			}_		}_		_		_		_		if (startShardId != null && listShardsResults != null) {_			List<Shard> shards = listShardsResults.getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}_		return listShardsResults__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,list,shards,result,list,shards,string,stream,name,nullable,string,start,shard,id,nullable,string,start,next,token,throws,interrupted,exception,final,list,shards,request,list,shards,request,new,list,shards,request,if,start,next,token,null,list,shards,request,set,exclusive,start,shard,id,start,shard,id,list,shards,request,set,stream,name,stream,name,else,list,shards,request,set,next,token,start,next,token,list,shards,result,list,shards,results,null,int,attempt,count,0,while,list,shards,results,null,try,list,shards,results,kinesis,client,list,shards,list,shards,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,list,shards,base,backoff,millis,list,shards,max,backoff,millis,list,shards,exp,constant,attempt,count,log,warn,got,limit,exceeded,exception,when,listing,shards,from,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,in,use,exception,re,in,use,if,log,is,warn,enabled,log,info,the,stream,is,currently,not,in,active,state,reusing,the,older,state,for,the,time,being,break,catch,resource,not,found,exception,re,not,found,throw,new,runtime,exception,stream,not,found,error,while,getting,shard,list,re,not,found,catch,invalid,argument,exception,in,arg,throw,new,runtime,exception,invalid,arguments,to,list,shards,in,arg,catch,expired,next,token,exception,expired,token,log,warn,list,shards,has,an,expired,token,reusing,the,previous,state,break,if,start,shard,id,null,list,shards,results,null,list,shard,shards,list,shards,results,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,list,shards,results
KinesisProxy -> private ListShardsResult listShards(String streamName, @Nullable String startShardId, 																			@Nullable String startNextToken) 			throws InterruptedException;1534479479;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private ListShardsResult listShards(String streamName, @Nullable String startShardId,_																			@Nullable String startNextToken)_			throws InterruptedException {_		final ListShardsRequest listShardsRequest = new ListShardsRequest()__		if (startNextToken == null) {_			listShardsRequest.setExclusiveStartShardId(startShardId)__			listShardsRequest.setStreamName(streamName)__		} else {_			_			listShardsRequest.setNextToken(startNextToken)__		}__		ListShardsResult listShardsResults = null___		_		int retryCount = 0__		_		_		while (retryCount <= listShardsMaxRetries && listShardsResults == null) { _			try {__				listShardsResults = kinesisClient.listShards(listShardsRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_						listShardsBaseBackoffMillis, listShardsMaxBackoffMillis, listShardsExpConstant, retryCount++)__					LOG.warn("Got LimitExceededException when listing shards from stream " + streamName_									+ ". Backing off for " + backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceInUseException reInUse) {_				if (LOG.isWarnEnabled()) {_					_					LOG.info("The stream is currently not in active state. Reusing the older state "_							+ "for the time being")__					break__				}_			} catch (ResourceNotFoundException reNotFound) {_				throw new RuntimeException("Stream not found. Error while getting shard list.", reNotFound)__			} catch (InvalidArgumentException inArg) {_				throw new RuntimeException("Invalid Arguments to listShards.", inArg)__			} catch (ExpiredNextTokenException expiredToken) {_				LOG.warn("List Shards has an expired token. Reusing the previous state.")__				break__			} catch (SdkClientException ex) {_				if (retryCount < listShardsMaxRetries && isRecoverableSdkClientException(ex)) {_					long backoffMillis = fullJitterBackoff(_						listShardsBaseBackoffMillis, listShardsMaxBackoffMillis, listShardsExpConstant, retryCount++)__					LOG.warn("Got SdkClientException when listing shards from stream {}. Backing off for {} millis.",_						streamName, backoffMillis)__					Thread.sleep(backoffMillis)__				} else {_					_					_					throw ex__				}_			}_		}_		_		_		_		if (startShardId != null && listShardsResults != null) {_			List<Shard> shards = listShardsResults.getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}_		return listShardsResults__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,list,shards,result,list,shards,string,stream,name,nullable,string,start,shard,id,nullable,string,start,next,token,throws,interrupted,exception,final,list,shards,request,list,shards,request,new,list,shards,request,if,start,next,token,null,list,shards,request,set,exclusive,start,shard,id,start,shard,id,list,shards,request,set,stream,name,stream,name,else,list,shards,request,set,next,token,start,next,token,list,shards,result,list,shards,results,null,int,retry,count,0,while,retry,count,list,shards,max,retries,list,shards,results,null,try,list,shards,results,kinesis,client,list,shards,list,shards,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,list,shards,base,backoff,millis,list,shards,max,backoff,millis,list,shards,exp,constant,retry,count,log,warn,got,limit,exceeded,exception,when,listing,shards,from,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,in,use,exception,re,in,use,if,log,is,warn,enabled,log,info,the,stream,is,currently,not,in,active,state,reusing,the,older,state,for,the,time,being,break,catch,resource,not,found,exception,re,not,found,throw,new,runtime,exception,stream,not,found,error,while,getting,shard,list,re,not,found,catch,invalid,argument,exception,in,arg,throw,new,runtime,exception,invalid,arguments,to,list,shards,in,arg,catch,expired,next,token,exception,expired,token,log,warn,list,shards,has,an,expired,token,reusing,the,previous,state,break,catch,sdk,client,exception,ex,if,retry,count,list,shards,max,retries,is,recoverable,sdk,client,exception,ex,long,backoff,millis,full,jitter,backoff,list,shards,base,backoff,millis,list,shards,max,backoff,millis,list,shards,exp,constant,retry,count,log,warn,got,sdk,client,exception,when,listing,shards,from,stream,backing,off,for,millis,stream,name,backoff,millis,thread,sleep,backoff,millis,else,throw,ex,if,start,shard,id,null,list,shards,results,null,list,shard,shards,list,shards,results,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,list,shards,results
KinesisProxy -> private ListShardsResult listShards(String streamName, @Nullable String startShardId, 																			@Nullable String startNextToken) 			throws InterruptedException;1545495597;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private ListShardsResult listShards(String streamName, @Nullable String startShardId,_																			@Nullable String startNextToken)_			throws InterruptedException {_		final ListShardsRequest listShardsRequest = new ListShardsRequest()__		if (startNextToken == null) {_			listShardsRequest.setExclusiveStartShardId(startShardId)__			listShardsRequest.setStreamName(streamName)__		} else {_			_			listShardsRequest.setNextToken(startNextToken)__		}__		ListShardsResult listShardsResults = null___		_		int retryCount = 0__		_		_		while (retryCount <= listShardsMaxRetries && listShardsResults == null) { _			try {__				listShardsResults = kinesisClient.listShards(listShardsRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_						listShardsBaseBackoffMillis, listShardsMaxBackoffMillis, listShardsExpConstant, retryCount++)__					LOG.warn("Got LimitExceededException when listing shards from stream " + streamName_									+ ". Backing off for " + backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceInUseException reInUse) {_				if (LOG.isWarnEnabled()) {_					_					LOG.info("The stream is currently not in active state. Reusing the older state "_							+ "for the time being")__					break__				}_			} catch (ResourceNotFoundException reNotFound) {_				throw new RuntimeException("Stream not found. Error while getting shard list.", reNotFound)__			} catch (InvalidArgumentException inArg) {_				throw new RuntimeException("Invalid Arguments to listShards.", inArg)__			} catch (ExpiredNextTokenException expiredToken) {_				LOG.warn("List Shards has an expired token. Reusing the previous state.")__				break__			} catch (SdkClientException ex) {_				if (retryCount < listShardsMaxRetries && isRecoverableSdkClientException(ex)) {_					long backoffMillis = fullJitterBackoff(_						listShardsBaseBackoffMillis, listShardsMaxBackoffMillis, listShardsExpConstant, retryCount++)__					LOG.warn("Got SdkClientException when listing shards from stream {}. Backing off for {} millis.",_						streamName, backoffMillis)__					Thread.sleep(backoffMillis)__				} else {_					_					_					throw ex__				}_			}_		}_		_		_		_		if (startShardId != null && listShardsResults != null) {_			List<Shard> shards = listShardsResults.getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}_		return listShardsResults__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,list,shards,result,list,shards,string,stream,name,nullable,string,start,shard,id,nullable,string,start,next,token,throws,interrupted,exception,final,list,shards,request,list,shards,request,new,list,shards,request,if,start,next,token,null,list,shards,request,set,exclusive,start,shard,id,start,shard,id,list,shards,request,set,stream,name,stream,name,else,list,shards,request,set,next,token,start,next,token,list,shards,result,list,shards,results,null,int,retry,count,0,while,retry,count,list,shards,max,retries,list,shards,results,null,try,list,shards,results,kinesis,client,list,shards,list,shards,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,list,shards,base,backoff,millis,list,shards,max,backoff,millis,list,shards,exp,constant,retry,count,log,warn,got,limit,exceeded,exception,when,listing,shards,from,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,in,use,exception,re,in,use,if,log,is,warn,enabled,log,info,the,stream,is,currently,not,in,active,state,reusing,the,older,state,for,the,time,being,break,catch,resource,not,found,exception,re,not,found,throw,new,runtime,exception,stream,not,found,error,while,getting,shard,list,re,not,found,catch,invalid,argument,exception,in,arg,throw,new,runtime,exception,invalid,arguments,to,list,shards,in,arg,catch,expired,next,token,exception,expired,token,log,warn,list,shards,has,an,expired,token,reusing,the,previous,state,break,catch,sdk,client,exception,ex,if,retry,count,list,shards,max,retries,is,recoverable,sdk,client,exception,ex,long,backoff,millis,full,jitter,backoff,list,shards,base,backoff,millis,list,shards,max,backoff,millis,list,shards,exp,constant,retry,count,log,warn,got,sdk,client,exception,when,listing,shards,from,stream,backing,off,for,millis,stream,name,backoff,millis,thread,sleep,backoff,millis,else,throw,ex,if,start,shard,id,null,list,shards,results,null,list,shard,shards,list,shards,results,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,list,shards,results
KinesisProxy -> private ListShardsResult listShards(String streamName, @Nullable String startShardId, 																			@Nullable String startNextToken) 			throws InterruptedException;1549739849;Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.__<p>This method is using a "full jitter" approach described in AWS's article,_<a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>._This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This_jitter backoff approach will help distribute calls across the fetchers over time.__@param streamName the stream to describe_@param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)_@return the result of the describe stream operation;private ListShardsResult listShards(String streamName, @Nullable String startShardId,_																			@Nullable String startNextToken)_			throws InterruptedException {_		final ListShardsRequest listShardsRequest = new ListShardsRequest()__		if (startNextToken == null) {_			listShardsRequest.setExclusiveStartShardId(startShardId)__			listShardsRequest.setStreamName(streamName)__		} else {_			_			listShardsRequest.setNextToken(startNextToken)__		}__		ListShardsResult listShardsResults = null___		_		int retryCount = 0__		_		_		while (retryCount <= listShardsMaxRetries && listShardsResults == null) { _			try {__				listShardsResults = kinesisClient.listShards(listShardsRequest)__			} catch (LimitExceededException le) {_				long backoffMillis = fullJitterBackoff(_						listShardsBaseBackoffMillis, listShardsMaxBackoffMillis, listShardsExpConstant, retryCount++)__					LOG.warn("Got LimitExceededException when listing shards from stream " + streamName_									+ ". Backing off for " + backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			} catch (ResourceInUseException reInUse) {_				if (LOG.isWarnEnabled()) {_					_					LOG.info("The stream is currently not in active state. Reusing the older state "_							+ "for the time being")__					break__				}_			} catch (ResourceNotFoundException reNotFound) {_				throw new RuntimeException("Stream not found. Error while getting shard list.", reNotFound)__			} catch (InvalidArgumentException inArg) {_				throw new RuntimeException("Invalid Arguments to listShards.", inArg)__			} catch (ExpiredNextTokenException expiredToken) {_				LOG.warn("List Shards has an expired token. Reusing the previous state.")__				break__			} catch (SdkClientException ex) {_				if (retryCount < listShardsMaxRetries && isRecoverableSdkClientException(ex)) {_					long backoffMillis = fullJitterBackoff(_						listShardsBaseBackoffMillis, listShardsMaxBackoffMillis, listShardsExpConstant, retryCount++)__					LOG.warn("Got SdkClientException when listing shards from stream {}. Backing off for {} millis.",_						streamName, backoffMillis)__					Thread.sleep(backoffMillis)__				} else {_					_					_					throw ex__				}_			}_		}__		_		_		_		_		_		_		if (startShardId != null && listShardsResults != null) {_			List<Shard> shards = listShardsResults.getShards()__			Iterator<Shard> shardItr = shards.iterator()__			while (shardItr.hasNext()) {_				if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {_					shardItr.remove()__				}_			}_		}__		return listShardsResults__	};get,metainfo,for,a,kinesis,stream,which,contains,information,about,which,shards,this,kinesis,stream,possess,p,this,method,is,using,a,full,jitter,approach,described,in,aws,s,article,a,href,https,www,awsarchitectureblog,com,2015,03,backoff,html,exponential,backoff,and,jitter,a,this,is,necessary,because,concurrent,calls,will,be,made,by,all,parallel,subtask,s,fetcher,this,jitter,backoff,approach,will,help,distribute,calls,across,the,fetchers,over,time,param,stream,name,the,stream,to,describe,param,start,shard,id,which,shard,to,start,with,for,this,describe,operation,earlier,shard,s,infos,will,not,appear,in,result,return,the,result,of,the,describe,stream,operation;private,list,shards,result,list,shards,string,stream,name,nullable,string,start,shard,id,nullable,string,start,next,token,throws,interrupted,exception,final,list,shards,request,list,shards,request,new,list,shards,request,if,start,next,token,null,list,shards,request,set,exclusive,start,shard,id,start,shard,id,list,shards,request,set,stream,name,stream,name,else,list,shards,request,set,next,token,start,next,token,list,shards,result,list,shards,results,null,int,retry,count,0,while,retry,count,list,shards,max,retries,list,shards,results,null,try,list,shards,results,kinesis,client,list,shards,list,shards,request,catch,limit,exceeded,exception,le,long,backoff,millis,full,jitter,backoff,list,shards,base,backoff,millis,list,shards,max,backoff,millis,list,shards,exp,constant,retry,count,log,warn,got,limit,exceeded,exception,when,listing,shards,from,stream,stream,name,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,catch,resource,in,use,exception,re,in,use,if,log,is,warn,enabled,log,info,the,stream,is,currently,not,in,active,state,reusing,the,older,state,for,the,time,being,break,catch,resource,not,found,exception,re,not,found,throw,new,runtime,exception,stream,not,found,error,while,getting,shard,list,re,not,found,catch,invalid,argument,exception,in,arg,throw,new,runtime,exception,invalid,arguments,to,list,shards,in,arg,catch,expired,next,token,exception,expired,token,log,warn,list,shards,has,an,expired,token,reusing,the,previous,state,break,catch,sdk,client,exception,ex,if,retry,count,list,shards,max,retries,is,recoverable,sdk,client,exception,ex,long,backoff,millis,full,jitter,backoff,list,shards,base,backoff,millis,list,shards,max,backoff,millis,list,shards,exp,constant,retry,count,log,warn,got,sdk,client,exception,when,listing,shards,from,stream,backing,off,for,millis,stream,name,backoff,millis,thread,sleep,backoff,millis,else,throw,ex,if,start,shard,id,null,list,shards,results,null,list,shard,shards,list,shards,results,get,shards,iterator,shard,shard,itr,shards,iterator,while,shard,itr,has,next,if,stream,shard,handle,compare,shard,ids,shard,itr,next,get,shard,id,start,shard,id,0,shard,itr,remove,return,list,shards,results
KinesisProxy -> private KinesisProxy(Properties configProps);1480685315;Create a new KinesisProxy based on the supplied configuration properties__@param configProps configuration properties containing AWS credential and AWS region info;private KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = AWSUtil.createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;private,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,awsutil,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> private KinesisProxy(Properties configProps);1484926180;Create a new KinesisProxy based on the supplied configuration properties__@param configProps configuration properties containing AWS credential and AWS region info;private KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = AWSUtil.createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;private,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,awsutil,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> private KinesisProxy(Properties configProps);1485238807;Create a new KinesisProxy based on the supplied configuration properties__@param configProps configuration properties containing AWS credential and AWS region info;private KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = AWSUtil.createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;private,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,awsutil,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> private KinesisProxy(Properties configProps);1495787238;Create a new KinesisProxy based on the supplied configuration properties__@param configProps configuration properties containing AWS credential and AWS region info;private KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = AWSUtil.createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;private,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,awsutil,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> private KinesisProxy(Properties configProps);1495923079;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;private KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = AWSUtil.createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;private,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,awsutil,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> private KinesisProxy(Properties configProps);1515177485;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;private KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = AWSUtil.createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;private,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,awsutil,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> private KinesisProxy(Properties configProps);1515757408;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;private KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = AWSUtil.createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;private,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,awsutil,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> private KinesisProxy(Properties configProps);1515757408;Create a new KinesisProxy based on the supplied configuration properties.__@param configProps configuration properties containing AWS credential and AWS region info;private KinesisProxy(Properties configProps) {_		checkNotNull(configProps)___		this.kinesisClient = AWSUtil.createKinesisClient(configProps)___		this.describeStreamBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_BASE)))__		this.describeStreamMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_MAX)))__		this.describeStreamExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_STREAM_DESCRIBE_BACKOFF_EXPONENTIAL_CONSTANT)))___		this.getRecordsBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_BASE)))__		this.getRecordsMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_MAX)))__		this.getRecordsExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getRecordsMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETRECORDS_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_RETRIES)))___		this.getShardIteratorBaseBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_BASE,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_BASE)))__		this.getShardIteratorMaxBackoffMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_MAX,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_MAX)))__		this.getShardIteratorExpConstant = Double.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT,_				Double.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_BACKOFF_EXPONENTIAL_CONSTANT)))__		this.getShardIteratorMaxAttempts = Integer.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_GETITERATOR_RETRIES,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETITERATOR_RETRIES)))___	};create,a,new,kinesis,proxy,based,on,the,supplied,configuration,properties,param,config,props,configuration,properties,containing,aws,credential,and,aws,region,info;private,kinesis,proxy,properties,config,props,check,not,null,config,props,this,kinesis,client,awsutil,create,kinesis,client,config,props,this,describe,stream,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,describe,stream,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,records,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,records,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,base,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,max,backoff,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,get,shard,iterator,exp,constant,double,value,of,config,props,get,property,consumer,config,constants,double,to,string,consumer,config,constants,this,get,shard,iterator,max,attempts,integer,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1484926180;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1485238807;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1495787238;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1495923079;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1515177485;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1515757408;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1515757408;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1521204705;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1524053374;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1525262671;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1529652657;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1534479479;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1545495597;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> protected static boolean isRecoverableException(AmazonServiceException ex);1549739849;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected static boolean isRecoverableException(AmazonServiceException ex) {_		if (ex.getErrorType() == null) {_			return false__		}__		switch (ex.getErrorType()) {_			case Client:_				return ex instanceof ProvisionedThroughputExceededException__			case Service:_			case Unknown:_				return true__			default:_				return false__		}_	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,static,boolean,is,recoverable,exception,amazon,service,exception,ex,if,ex,get,error,type,null,return,false,switch,ex,get,error,type,case,client,return,ex,instanceof,provisioned,throughput,exceeded,exception,case,service,case,unknown,return,true,default,return,false
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1480685315;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (ProvisionedThroughputExceededException ex) {_				long backoffMillis = fullJitterBackoff(_					getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__				LOG.warn("Got ProvisionedThroughputExceededException. Backing off for "_					+ backoffMillis + " millis.")__				Thread.sleep(backoffMillis)__			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,provisioned,throughput,exceeded,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,provisioned,throughput,exceeded,exception,backing,off,for,backoff,millis,millis,thread,sleep,backoff,millis,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1484926180;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (AmazonServiceException ex) {_				if (isRecoverableException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable AmazonServiceException. Backing off for "_						+ backoffMillis + " millis (" + ex.getErrorMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,amazon,service,exception,ex,if,is,recoverable,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,amazon,service,exception,backing,off,for,backoff,millis,millis,ex,get,error,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1485238807;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (AmazonServiceException ex) {_				if (isRecoverableException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable AmazonServiceException. Backing off for "_						+ backoffMillis + " millis (" + ex.getErrorMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,amazon,service,exception,ex,if,is,recoverable,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,amazon,service,exception,backing,off,for,backoff,millis,millis,ex,get,error,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1495787238;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (AmazonServiceException ex) {_				if (isRecoverableException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable AmazonServiceException. Backing off for "_						+ backoffMillis + " millis (" + ex.getErrorMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,amazon,service,exception,ex,if,is,recoverable,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,amazon,service,exception,backing,off,for,backoff,millis,millis,ex,get,error,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1495923079;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (AmazonServiceException ex) {_				if (isRecoverableException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable AmazonServiceException. Backing off for "_						+ backoffMillis + " millis (" + ex.getErrorMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,amazon,service,exception,ex,if,is,recoverable,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,amazon,service,exception,backing,off,for,backoff,millis,millis,ex,get,error,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1515177485;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (AmazonServiceException ex) {_				if (isRecoverableException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable AmazonServiceException. Backing off for "_						+ backoffMillis + " millis (" + ex.getErrorMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,amazon,service,exception,ex,if,is,recoverable,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,amazon,service,exception,backing,off,for,backoff,millis,millis,ex,get,error,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1515757408;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (AmazonServiceException ex) {_				if (isRecoverableException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable AmazonServiceException. Backing off for "_						+ backoffMillis + " millis (" + ex.getErrorMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,amazon,service,exception,ex,if,is,recoverable,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,amazon,service,exception,backing,off,for,backoff,millis,millis,ex,get,error,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1515757408;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (AmazonServiceException ex) {_				if (isRecoverableException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable AmazonServiceException. Backing off for "_						+ backoffMillis + " millis (" + ex.getErrorMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,amazon,service,exception,ex,if,is,recoverable,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,amazon,service,exception,backing,off,for,backoff,millis,millis,ex,get,error,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1521204705;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (AmazonServiceException ex) {_				if (isRecoverableException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable AmazonServiceException. Backing off for "_						+ backoffMillis + " millis (" + ex.getErrorMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,amazon,service,exception,ex,if,is,recoverable,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,amazon,service,exception,backing,off,for,backoff,millis,millis,ex,get,error,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1524053374;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (SdkClientException ex) {_				if (isRecoverableSdkClientException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable SdkClientException. Backing off for "_						+ backoffMillis + " millis (" + ex.getMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,sdk,client,exception,ex,if,is,recoverable,sdk,client,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,sdk,client,exception,backing,off,for,backoff,millis,millis,ex,get,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1525262671;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (SdkClientException ex) {_				if (isRecoverableSdkClientException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable SdkClientException. Backing off for "_						+ backoffMillis + " millis (" + ex.getMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,sdk,client,exception,ex,if,is,recoverable,sdk,client,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,sdk,client,exception,backing,off,for,backoff,millis,millis,ex,get,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1529652657;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int attempt = 0__		while (attempt <= getRecordsMaxAttempts && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (SdkClientException ex) {_				if (isRecoverableSdkClientException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, attempt++)__					LOG.warn("Got recoverable SdkClientException. Backing off for "_						+ backoffMillis + " millis (" + ex.getMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxAttempts +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,attempt,0,while,attempt,get,records,max,attempts,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,sdk,client,exception,ex,if,is,recoverable,sdk,client,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,attempt,log,warn,got,recoverable,sdk,client,exception,backing,off,for,backoff,millis,millis,ex,get,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,attempts,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1534479479;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int retryCount = 0__		while (retryCount <= getRecordsMaxRetries && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (SdkClientException ex) {_				if (isRecoverableSdkClientException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, retryCount++)__					LOG.warn("Got recoverable SdkClientException. Backing off for "_						+ backoffMillis + " millis (" + ex.getMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxRetries +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,retry,count,0,while,retry,count,get,records,max,retries,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,sdk,client,exception,ex,if,is,recoverable,sdk,client,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,retry,count,log,warn,got,recoverable,sdk,client,exception,backing,off,for,backoff,millis,millis,ex,get,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,retries,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1545495597;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int retryCount = 0__		while (retryCount <= getRecordsMaxRetries && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (SdkClientException ex) {_				if (isRecoverableSdkClientException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, retryCount++)__					LOG.warn("Got recoverable SdkClientException. Backing off for "_						+ backoffMillis + " millis (" + ex.getMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxRetries +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,retry,count,0,while,retry,count,get,records,max,retries,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,sdk,client,exception,ex,if,is,recoverable,sdk,client,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,retry,count,log,warn,got,recoverable,sdk,client,exception,backing,off,for,backoff,millis,millis,ex,get,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,retries,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException;1549739849;{@inheritDoc};@Override_	public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {_		final GetRecordsRequest getRecordsRequest = new GetRecordsRequest()__		getRecordsRequest.setShardIterator(shardIterator)__		getRecordsRequest.setLimit(maxRecordsToGet)___		GetRecordsResult getRecordsResult = null___		int retryCount = 0__		while (retryCount <= getRecordsMaxRetries && getRecordsResult == null) {_			try {_				getRecordsResult = kinesisClient.getRecords(getRecordsRequest)__			} catch (SdkClientException ex) {_				if (isRecoverableSdkClientException(ex)) {_					long backoffMillis = fullJitterBackoff(_						getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, retryCount++)__					LOG.warn("Got recoverable SdkClientException. Backing off for "_						+ backoffMillis + " millis (" + ex.getMessage() + ")")__					Thread.sleep(backoffMillis)__				} else {_					throw ex__				}_			}_		}__		if (getRecordsResult == null) {_			throw new RuntimeException("Rate Exceeded for getRecords operation - all " + getRecordsMaxRetries +_				" retry attempts returned ProvisionedThroughputExceededException.")__		}__		return getRecordsResult__	};inherit,doc;override,public,get,records,result,get,records,string,shard,iterator,int,max,records,to,get,throws,interrupted,exception,final,get,records,request,get,records,request,new,get,records,request,get,records,request,set,shard,iterator,shard,iterator,get,records,request,set,limit,max,records,to,get,get,records,result,get,records,result,null,int,retry,count,0,while,retry,count,get,records,max,retries,get,records,result,null,try,get,records,result,kinesis,client,get,records,get,records,request,catch,sdk,client,exception,ex,if,is,recoverable,sdk,client,exception,ex,long,backoff,millis,full,jitter,backoff,get,records,base,backoff,millis,get,records,max,backoff,millis,get,records,exp,constant,retry,count,log,warn,got,recoverable,sdk,client,exception,backing,off,for,backoff,millis,millis,ex,get,message,thread,sleep,backoff,millis,else,throw,ex,if,get,records,result,null,throw,new,runtime,exception,rate,exceeded,for,get,records,operation,all,get,records,max,retries,retry,attempts,returned,provisioned,throughput,exceeded,exception,return,get,records,result
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1495787238;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1495923079;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1515177485;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1515757408;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1515757408;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1521204705;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1524053374;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1525262671;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1529652657;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1534479479;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1545495597;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> @Override 	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException;1549739849;{@inheritDoc};@Override_	public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {_		GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest()_			.withStreamName(shard.getStreamName())_			.withShardId(shard.getShard().getShardId())_			.withShardIteratorType(shardIteratorType)___		switch (ShardIteratorType.fromValue(shardIteratorType)) {_			case TRIM_HORIZON:_			case LATEST:_				break__			case AT_TIMESTAMP:_				if (startingMarker instanceof Date) {_					getShardIteratorRequest.setTimestamp((Date) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.")__				}_				break__			case AT_SEQUENCE_NUMBER:_			case AFTER_SEQUENCE_NUMBER:_				if (startingMarker instanceof String) {_					getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker)__				} else {_					throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.")__				}_		}_		return getShardIterator(getShardIteratorRequest)__	};inherit,doc;override,public,string,get,shard,iterator,stream,shard,handle,shard,string,shard,iterator,type,nullable,object,starting,marker,throws,interrupted,exception,get,shard,iterator,request,get,shard,iterator,request,new,get,shard,iterator,request,with,stream,name,shard,get,stream,name,with,shard,id,shard,get,shard,get,shard,id,with,shard,iterator,type,shard,iterator,type,switch,shard,iterator,type,from,value,shard,iterator,type,case,case,latest,break,case,if,starting,marker,instanceof,date,get,shard,iterator,request,set,timestamp,date,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,must,be,a,date,object,break,case,case,if,starting,marker,instanceof,string,get,shard,iterator,request,set,starting,sequence,number,string,starting,marker,else,throw,new,illegal,argument,exception,invalid,object,given,for,get,shard,iterator,request,when,shard,iterator,type,is,or,must,be,a,string,return,get,shard,iterator,get,shard,iterator,request
KinesisProxy -> protected boolean isRecoverableSdkClientException(SdkClientException ex);1524053374;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected boolean isRecoverableSdkClientException(SdkClientException ex) {_		if (ex instanceof AmazonServiceException) {_			return KinesisProxy.isRecoverableException((AmazonServiceException) ex)__		}_		_		return false__	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,boolean,is,recoverable,sdk,client,exception,sdk,client,exception,ex,if,ex,instanceof,amazon,service,exception,return,kinesis,proxy,is,recoverable,exception,amazon,service,exception,ex,return,false
KinesisProxy -> protected boolean isRecoverableSdkClientException(SdkClientException ex);1525262671;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected boolean isRecoverableSdkClientException(SdkClientException ex) {_		if (ex instanceof AmazonServiceException) {_			return KinesisProxy.isRecoverableException((AmazonServiceException) ex)__		}_		_		return false__	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,boolean,is,recoverable,sdk,client,exception,sdk,client,exception,ex,if,ex,instanceof,amazon,service,exception,return,kinesis,proxy,is,recoverable,exception,amazon,service,exception,ex,return,false
KinesisProxy -> protected boolean isRecoverableSdkClientException(SdkClientException ex);1529652657;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected boolean isRecoverableSdkClientException(SdkClientException ex) {_		if (ex instanceof AmazonServiceException) {_			return KinesisProxy.isRecoverableException((AmazonServiceException) ex)__		}_		_		return false__	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,boolean,is,recoverable,sdk,client,exception,sdk,client,exception,ex,if,ex,instanceof,amazon,service,exception,return,kinesis,proxy,is,recoverable,exception,amazon,service,exception,ex,return,false
KinesisProxy -> protected boolean isRecoverableSdkClientException(SdkClientException ex);1534479479;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected boolean isRecoverableSdkClientException(SdkClientException ex) {_		if (ex instanceof AmazonServiceException) {_			return KinesisProxy.isRecoverableException((AmazonServiceException) ex)__		}_		_		return false__	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,boolean,is,recoverable,sdk,client,exception,sdk,client,exception,ex,if,ex,instanceof,amazon,service,exception,return,kinesis,proxy,is,recoverable,exception,amazon,service,exception,ex,return,false
KinesisProxy -> protected boolean isRecoverableSdkClientException(SdkClientException ex);1545495597;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected boolean isRecoverableSdkClientException(SdkClientException ex) {_		if (ex instanceof AmazonServiceException) {_			return KinesisProxy.isRecoverableException((AmazonServiceException) ex)__		}_		_		return false__	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,boolean,is,recoverable,sdk,client,exception,sdk,client,exception,ex,if,ex,instanceof,amazon,service,exception,return,kinesis,proxy,is,recoverable,exception,amazon,service,exception,ex,return,false
KinesisProxy -> protected boolean isRecoverableSdkClientException(SdkClientException ex);1549739849;Determines whether the exception is recoverable using exponential-backoff.__@param ex Exception to inspect_@return <code>true</code> if the exception can be recovered from, else_<code>false</code>;protected boolean isRecoverableSdkClientException(SdkClientException ex) {_		if (ex instanceof AmazonServiceException) {_			return KinesisProxy.isRecoverableException((AmazonServiceException) ex)__		}_		_		return false__	};determines,whether,the,exception,is,recoverable,using,exponential,backoff,param,ex,exception,to,inspect,return,code,true,code,if,the,exception,can,be,recovered,from,else,code,false,code;protected,boolean,is,recoverable,sdk,client,exception,sdk,client,exception,ex,if,ex,instanceof,amazon,service,exception,return,kinesis,proxy,is,recoverable,exception,amazon,service,exception,ex,return,false
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1480685315;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String,String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1484926180;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String,String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1485238807;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String,String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1495787238;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String,String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1495923079;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1515177485;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1515757408;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1515757408;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1521204705;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1524053374;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1525262671;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1529652657;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1534479479;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1545495597;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
KinesisProxy -> @Override 	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException;1549739849;{@inheritDoc};@Override_	public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {_		GetShardListResult result = new GetShardListResult()___		for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {_			String stream = streamNameWithLastSeenShardId.getKey()__			String lastSeenShardId = streamNameWithLastSeenShardId.getValue()__			result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId))__		}_		return result__	};inherit,doc;override,public,get,shard,list,result,get,shard,list,map,string,string,stream,names,with,last,seen,shard,ids,throws,interrupted,exception,get,shard,list,result,result,new,get,shard,list,result,for,map,entry,string,string,stream,name,with,last,seen,shard,id,stream,names,with,last,seen,shard,ids,entry,set,string,stream,stream,name,with,last,seen,shard,id,get,key,string,last,seen,shard,id,stream,name,with,last,seen,shard,id,get,value,result,add,retrieved,shards,to,stream,stream,get,shards,of,stream,stream,last,seen,shard,id,return,result
