commented;modifiers;parameterAmount;loc;comment;code
true;protected;1;6;/**  * Create the Kinesis client, using the provided configuration properties and default {@link ClientConfiguration}.  * Derived classes can override this method to customize the client configuration.  * @param configProps  * @return  */ ;/**  * Create the Kinesis client, using the provided configuration properties and default {@link ClientConfiguration}.  * Derived classes can override this method to customize the client configuration.  * @param configProps  * @return  */ protected AmazonKinesis createKinesisClient(Properties configProps) {     ClientConfiguration awsClientConfig = new ClientConfigurationFactory().getConfig().     AWSUtil.setAwsClientConfigProperties(awsClientConfig, configProps).     return AWSUtil.createKinesisClient(configProps, awsClientConfig). }
true;public,static;1;3;/**  * Creates a Kinesis proxy.  *  * @param configProps configuration properties  * @return the created kinesis proxy  */ ;/**  * Creates a Kinesis proxy.  *  * @param configProps configuration properties  * @return the created kinesis proxy  */ public static KinesisProxyInterface create(Properties configProps) {     return new KinesisProxy(configProps). }
true;public;2;32;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {     final GetRecordsRequest getRecordsRequest = new GetRecordsRequest().     getRecordsRequest.setShardIterator(shardIterator).     getRecordsRequest.setLimit(maxRecordsToGet).     GetRecordsResult getRecordsResult = null.     int retryCount = 0.     while (retryCount <= getRecordsMaxRetries && getRecordsResult == null) {         try {             getRecordsResult = kinesisClient.getRecords(getRecordsRequest).         } catch (SdkClientException ex) {             if (isRecoverableSdkClientException(ex)) {                 long backoffMillis = fullJitterBackoff(getRecordsBaseBackoffMillis, getRecordsMaxBackoffMillis, getRecordsExpConstant, retryCount++).                 LOG.warn("Got recoverable SdkClientException. Backing off for " + backoffMillis + " millis (" + ex.getClass().getName() + ": " + ex.getMessage() + ")").                 Thread.sleep(backoffMillis).             } else {                 throw ex.             }         }     }     if (getRecordsResult == null) {         throw new RuntimeException("Retries exceeded for getRecords operation - all " + getRecordsMaxRetries + " retry attempts failed.").     }     return getRecordsResult. }
true;public;1;11;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {     GetShardListResult result = new GetShardListResult().     for (Map.Entry<String, String> streamNameWithLastSeenShardId : streamNamesWithLastSeenShardIds.entrySet()) {         String stream = streamNameWithLastSeenShardId.getKey().         String lastSeenShardId = streamNameWithLastSeenShardId.getValue().         result.addRetrievedShardsToStream(stream, getShardsOfStream(stream, lastSeenShardId)).     }     return result. }
true;public;3;28;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public String getShardIterator(StreamShardHandle shard, String shardIteratorType, @Nullable Object startingMarker) throws InterruptedException {     GetShardIteratorRequest getShardIteratorRequest = new GetShardIteratorRequest().withStreamName(shard.getStreamName()).withShardId(shard.getShard().getShardId()).withShardIteratorType(shardIteratorType).     switch(ShardIteratorType.fromValue(shardIteratorType)) {         case TRIM_HORIZON:         case LATEST:             break.         case AT_TIMESTAMP:             if (startingMarker instanceof Date) {                 getShardIteratorRequest.setTimestamp((Date) startingMarker).             } else {                 throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_TIMESTAMP. Must be a Date object.").             }             break.         case AT_SEQUENCE_NUMBER:         case AFTER_SEQUENCE_NUMBER:             if (startingMarker instanceof String) {                 getShardIteratorRequest.setStartingSequenceNumber((String) startingMarker).             } else {                 throw new IllegalArgumentException("Invalid object given for GetShardIteratorRequest() when ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Must be a String.").             }     }     return getShardIterator(getShardIteratorRequest). }
false;private;1;26;;private String getShardIterator(GetShardIteratorRequest getShardIteratorRequest) throws InterruptedException {     GetShardIteratorResult getShardIteratorResult = null.     int retryCount = 0.     while (retryCount <= getShardIteratorMaxRetries && getShardIteratorResult == null) {         try {             getShardIteratorResult = kinesisClient.getShardIterator(getShardIteratorRequest).         } catch (AmazonServiceException ex) {             if (isRecoverableException(ex)) {                 long backoffMillis = fullJitterBackoff(getShardIteratorBaseBackoffMillis, getShardIteratorMaxBackoffMillis, getShardIteratorExpConstant, retryCount++).                 LOG.warn("Got recoverable AmazonServiceException. Backing off for " + backoffMillis + " millis (" + ex.getClass().getName() + ": " + ex.getMessage() + ")").                 Thread.sleep(backoffMillis).             } else {                 throw ex.             }         }     }     if (getShardIteratorResult == null) {         throw new RuntimeException("Retries exceeded for getShardIterator operation - all " + getShardIteratorMaxRetries + " retry attempts failed.").     }     return getShardIteratorResult.getShardIterator(). }
true;protected;1;7;/**  * Determines whether the exception is recoverable using exponential-backoff.  *  * @param ex Exception to inspect  * @return <code>true</code> if the exception can be recovered from, else  *         <code>false</code>  */ ;/**  * Determines whether the exception is recoverable using exponential-backoff.  *  * @param ex Exception to inspect  * @return <code>true</code> if the exception can be recovered from, else  *         <code>false</code>  */ protected boolean isRecoverableSdkClientException(SdkClientException ex) {     if (ex instanceof AmazonServiceException) {         return KinesisProxy.isRecoverableException((AmazonServiceException) ex).     }     // customizations may decide to retry other errors, such as read timeouts     return false. }
true;protected,static;1;15;/**  * Determines whether the exception is recoverable using exponential-backoff.  *  * @param ex Exception to inspect  * @return <code>true</code> if the exception can be recovered from, else  *         <code>false</code>  */ ;/**  * Determines whether the exception is recoverable using exponential-backoff.  *  * @param ex Exception to inspect  * @return <code>true</code> if the exception can be recovered from, else  *         <code>false</code>  */ protected static boolean isRecoverableException(AmazonServiceException ex) {     if (ex.getErrorType() == null) {         return false.     }     switch(ex.getErrorType()) {         case Client:             return ex instanceof ProvisionedThroughputExceededException.         case Service:         case Unknown:             return true.         default:             return false.     } }
false;private;2;24;;private List<StreamShardHandle> getShardsOfStream(String streamName, @Nullable String lastSeenShardId) throws InterruptedException {     List<StreamShardHandle> shardsOfStream = new ArrayList<>().     // List Shards returns just the first 1000 shard entries. In order to read the entire stream,     // we need to use the returned nextToken to get additional shards.     ListShardsResult listShardsResult.     String startShardToken = null.     do {         listShardsResult = listShards(streamName, lastSeenShardId, startShardToken).         if (listShardsResult == null) {             // In case we have exceptions while retrieving all shards, ensure that incomplete shard list is not returned.             // Hence clearing the incomplete shard list before returning it.             shardsOfStream.clear().             return shardsOfStream.         }         List<Shard> shards = listShardsResult.getShards().         for (Shard shard : shards) {             shardsOfStream.add(new StreamShardHandle(streamName, shard)).         }         startShardToken = listShardsResult.getNextToken().     } while (startShardToken != null).     return shardsOfStream. }
true;private;3;75;/**  * Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.  *  * <p>This method is using a "full jitter" approach described in AWS's article,  * <a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>.  * This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This  * jitter backoff approach will help distribute calls across the fetchers over time.  *  * @param streamName the stream to describe  * @param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)  * @return the result of the describe stream operation  */ ;/**  * Get metainfo for a Kinesis stream, which contains information about which shards this Kinesis stream possess.  *  * <p>This method is using a "full jitter" approach described in AWS's article,  * <a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">"Exponential Backoff and Jitter"</a>.  * This is necessary because concurrent calls will be made by all parallel subtask's fetcher. This  * jitter backoff approach will help distribute calls across the fetchers over time.  *  * @param streamName the stream to describe  * @param startShardId which shard to start with for this describe operation (earlier shard's infos will not appear in result)  * @return the result of the describe stream operation  */ private ListShardsResult listShards(String streamName, @Nullable String startShardId, @Nullable String startNextToken) throws InterruptedException {     final ListShardsRequest listShardsRequest = new ListShardsRequest().     if (startNextToken == null) {         listShardsRequest.setExclusiveStartShardId(startShardId).         listShardsRequest.setStreamName(streamName).     } else {         // Note the nextToken returned by AWS expires within 300 sec.         listShardsRequest.setNextToken(startNextToken).     }     ListShardsResult listShardsResults = null.     // Call ListShards, with full-jitter backoff (if we get LimitExceededException).     int retryCount = 0.     // are taken up.     while (retryCount <= listShardsMaxRetries && listShardsResults == null) {         // retry until we get a result         try {             listShardsResults = kinesisClient.listShards(listShardsRequest).         } catch (LimitExceededException le) {             long backoffMillis = fullJitterBackoff(listShardsBaseBackoffMillis, listShardsMaxBackoffMillis, listShardsExpConstant, retryCount++).             LOG.warn("Got LimitExceededException when listing shards from stream " + streamName + ". Backing off for " + backoffMillis + " millis.").             Thread.sleep(backoffMillis).         } catch (ResourceInUseException reInUse) {             if (LOG.isWarnEnabled()) {                 // List Shards will throw an exception if stream in not in active state. Return and re-use previous state available.                 LOG.info("The stream is currently not in active state. Reusing the older state " + "for the time being").                 break.             }         } catch (ResourceNotFoundException reNotFound) {             throw new RuntimeException("Stream not found. Error while getting shard list.", reNotFound).         } catch (InvalidArgumentException inArg) {             throw new RuntimeException("Invalid Arguments to listShards.", inArg).         } catch (ExpiredNextTokenException expiredToken) {             LOG.warn("List Shards has an expired token. Reusing the previous state.").             break.         } catch (SdkClientException ex) {             if (retryCount < listShardsMaxRetries && isRecoverableSdkClientException(ex)) {                 long backoffMillis = fullJitterBackoff(listShardsBaseBackoffMillis, listShardsMaxBackoffMillis, listShardsExpConstant, retryCount++).                 LOG.warn("Got SdkClientException when listing shards from stream {}. Backing off for {} millis.", streamName, backoffMillis).                 Thread.sleep(backoffMillis).             } else {                 // (otherwise would return null result and keep trying forever)                 throw ex.             }         }     }     // https://github.com/lyft/kinesalite/pull/4     if (startShardId != null && listShardsResults != null) {         List<Shard> shards = listShardsResults.getShards().         Iterator<Shard> shardItr = shards.iterator().         while (shardItr.hasNext()) {             if (StreamShardHandle.compareShardIds(shardItr.next().getShardId(), startShardId) <= 0) {                 shardItr.remove().             }         }     }     return listShardsResults. }
true;protected;2;39;/**  * Get metainfo for a Kinesis stream, which contains information about which shards this  * Kinesis stream possess.  *  * <p>This method is using a "full jitter" approach described in AWS's article,  * <a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">  *   "Exponential Backoff and Jitter"</a>.  * This is necessary because concurrent calls will be made by all parallel subtask's fetcher.  * This jitter backoff approach will help distribute calls across the fetchers over time.  *  * @param streamName the stream to describe  * @param startShardId which shard to start with for this describe operation  *  * @return the result of the describe stream operation  */ ;/**  * Get metainfo for a Kinesis stream, which contains information about which shards this  * Kinesis stream possess.  *  * <p>This method is using a "full jitter" approach described in AWS's article,  * <a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">  *   "Exponential Backoff and Jitter"</a>.  * This is necessary because concurrent calls will be made by all parallel subtask's fetcher.  * This jitter backoff approach will help distribute calls across the fetchers over time.  *  * @param streamName the stream to describe  * @param startShardId which shard to start with for this describe operation  *  * @return the result of the describe stream operation  */ protected DescribeStreamResult describeStream(String streamName, @Nullable String startShardId) throws InterruptedException {     final DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest().     describeStreamRequest.setStreamName(streamName).     describeStreamRequest.setExclusiveStartShardId(startShardId).     DescribeStreamResult describeStreamResult = null.     // Call DescribeStream, with full-jitter backoff (if we get LimitExceededException).     int attemptCount = 0.     while (describeStreamResult == null) {         // retry until we get a result         try {             describeStreamResult = kinesisClient.describeStream(describeStreamRequest).         } catch (LimitExceededException le) {             long backoffMillis = fullJitterBackoff(describeStreamBaseBackoffMillis, describeStreamMaxBackoffMillis, describeStreamExpConstant, attemptCount++).             LOG.warn(String.format("Got LimitExceededException when describing stream %s. " + "Backing off for %d millis.", streamName, backoffMillis)).             Thread.sleep(backoffMillis).         } catch (ResourceNotFoundException re) {             throw new RuntimeException("Error while getting stream details", re).         }     }     String streamStatus = describeStreamResult.getStreamDescription().getStreamStatus().     if (!(streamStatus.equals(StreamStatus.ACTIVE.toString()) || streamStatus.equals(StreamStatus.UPDATING.toString()))) {         if (LOG.isWarnEnabled()) {             LOG.warn(String.format("The status of stream %s is %s . result of the current " + "describeStream operation will not contain any shard information.", streamName, streamStatus)).         }     }     return describeStreamResult. }
false;protected,static;4;4;;protected static long fullJitterBackoff(long base, long max, double power, int attempt) {     long exponentialBackoff = (long) Math.min(max, base * Math.pow(power, attempt)).     // random jitter between 0 and the exponential backoff     return (long) (seed.nextDouble() * exponentialBackoff). }
