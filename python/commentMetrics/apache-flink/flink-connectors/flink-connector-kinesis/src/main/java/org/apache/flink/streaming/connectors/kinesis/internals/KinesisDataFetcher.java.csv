# id;timestamp;commentText;codeText;commentWords;codeWords
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1480685315;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1490934828;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1492730110;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1494145732;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1494149584;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1495787238;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1495787239;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1495923079;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1515757408;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1515757408;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1515757408;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1519386499;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1533129233;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1534479217;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1542797087;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		_		_		if (periodicWatermarkAssigner != null) {_			ShardWatermarkState sws = shardWatermarks.get(shardStateIndex)__			Preconditions.checkNotNull(_				sws, "shard watermark state initialized in registerNewSubscribedShardState")__			recordTimestamp =_				sws.periodicWatermarkAssigner.extractTimestamp(record, sws.lastRecordTimestamp)__			sws.lastRecordTimestamp = recordTimestamp__			sws.lastUpdated = getCurrentTimeMillis()__		}__		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,if,periodic,watermark,assigner,null,shard,watermark,state,sws,shard,watermarks,get,shard,state,index,preconditions,check,not,null,sws,shard,watermark,state,initialized,in,register,new,subscribed,shard,state,record,timestamp,sws,periodic,watermark,assigner,extract,timestamp,record,sws,last,record,timestamp,sws,last,record,timestamp,record,timestamp,sws,last,updated,get,current,time,millis,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1545495597;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		_		_		if (periodicWatermarkAssigner != null) {_			ShardWatermarkState sws = shardWatermarks.get(shardStateIndex)__			Preconditions.checkNotNull(_				sws, "shard watermark state initialized in registerNewSubscribedShardState")__			recordTimestamp =_				sws.periodicWatermarkAssigner.extractTimestamp(record, sws.lastRecordTimestamp)__			sws.lastRecordTimestamp = recordTimestamp__			sws.lastUpdated = getCurrentTimeMillis()__		}__		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,if,periodic,watermark,assigner,null,shard,watermark,state,sws,shard,watermarks,get,shard,state,index,preconditions,check,not,null,sws,shard,watermark,state,initialized,in,register,new,subscribed,shard,state,record,timestamp,sws,periodic,watermark,assigner,extract,timestamp,record,sws,last,record,timestamp,sws,last,record,timestamp,record,timestamp,sws,last,updated,get,current,time,millis,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1550197938;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		_		_		if (periodicWatermarkAssigner != null) {_			ShardWatermarkState sws = shardWatermarks.get(shardStateIndex)__			Preconditions.checkNotNull(_				sws, "shard watermark state initialized in registerNewSubscribedShardState")__			recordTimestamp =_				sws.periodicWatermarkAssigner.extractTimestamp(record, sws.lastRecordTimestamp)__			sws.lastRecordTimestamp = recordTimestamp__			sws.lastUpdated = getCurrentTimeMillis()__		}__		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,if,periodic,watermark,assigner,null,shard,watermark,state,sws,shard,watermarks,get,shard,state,index,preconditions,check,not,null,sws,shard,watermark,state,initialized,in,register,new,subscribed,shard,state,record,timestamp,sws,periodic,watermark,assigner,extract,timestamp,record,sws,last,record,timestamp,sws,last,record,timestamp,record,timestamp,sws,last,updated,get,current,time,millis,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1495787239;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1495923079;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1515757408;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1515757408;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1515757408;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1517943538;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1517943538;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1517943538;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1517943538;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1518718884;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1519386499;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1533129233;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1534479217;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1542797087;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1545495597;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle);1550197938;Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.__@param streamShardHandle the {@link StreamShardHandle} to be converted_@return a {@link StreamShardMetadata} object;public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {_		StreamShardMetadata streamShardMetadata = new StreamShardMetadata()___		streamShardMetadata.setStreamName(streamShardHandle.getStreamName())__		streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId())__		streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId())__		streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId())___		if (streamShardHandle.getShard().getHashKeyRange() != null) {_			streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey())__			streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey())__		}__		if (streamShardHandle.getShard().getSequenceNumberRange() != null) {_			streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber())__			streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber())__		}__		return streamShardMetadata__	};utility,function,to,convert,link,stream,shard,handle,into,link,stream,shard,metadata,param,stream,shard,handle,the,link,stream,shard,handle,to,be,converted,return,a,link,stream,shard,metadata,object;public,static,stream,shard,metadata,convert,to,stream,shard,metadata,stream,shard,handle,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,new,stream,shard,metadata,stream,shard,metadata,set,stream,name,stream,shard,handle,get,stream,name,stream,shard,metadata,set,shard,id,stream,shard,handle,get,shard,get,shard,id,stream,shard,metadata,set,parent,shard,id,stream,shard,handle,get,shard,get,parent,shard,id,stream,shard,metadata,set,adjacent,parent,shard,id,stream,shard,handle,get,shard,get,adjacent,parent,shard,id,if,stream,shard,handle,get,shard,get,hash,key,range,null,stream,shard,metadata,set,starting,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,starting,hash,key,stream,shard,metadata,set,ending,hash,key,stream,shard,handle,get,shard,get,hash,key,range,get,ending,hash,key,if,stream,shard,handle,get,shard,get,sequence,number,range,null,stream,shard,metadata,set,starting,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,starting,sequence,number,stream,shard,metadata,set,ending,sequence,number,stream,shard,handle,get,shard,get,sequence,number,range,get,ending,sequence,number,return,stream,shard,metadata
KinesisDataFetcher -> protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1517943538;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			sourceContext.collectWithTimestamp(record, recordTimestamp)__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,source,context,collect,with,timestamp,record,record,timestamp,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1517943538;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1517943538;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1517943538;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber);1518718884;Atomic operation to collect a record and update state to the sequence number of the record._This method is called by {@link ShardConsumer}s.__@param record the record to collect_@param recordTimestamp timestamp to attach to the collected record_@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			if (record != null) {_				sourceContext.collectWithTimestamp(record, recordTimestamp)__			} else {_				LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.",_					lastSequenceNumber,_					subscribedShardsState.get(shardStateIndex).getStreamShardHandle())__			}__			updateState(shardStateIndex, lastSequenceNumber)__		}_	};atomic,operation,to,collect,a,record,and,update,state,to,the,sequence,number,of,the,record,this,method,is,called,by,link,shard,consumer,s,param,record,the,record,to,collect,param,record,timestamp,timestamp,to,attach,to,the,collected,record,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,emit,record,and,update,state,t,record,long,record,timestamp,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,if,record,null,source,context,collect,with,timestamp,record,record,timestamp,else,log,warn,skipping,non,deserializable,record,at,sequence,number,of,shard,last,sequence,number,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,update,state,shard,state,index,last,sequence,number
KinesisDataFetcher -> public HashMap<KinesisStreamShard, SequenceNumber> snapshotState();1480685315;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<KinesisStreamShard, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<KinesisStreamShard, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getKinesisStreamShard(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,kinesis,stream,shard,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,kinesis,stream,shard,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,kinesis,stream,shard,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<KinesisStreamShard, SequenceNumber> snapshotState();1490934828;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<KinesisStreamShard, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<KinesisStreamShard, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getKinesisStreamShard(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,kinesis,stream,shard,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,kinesis,stream,shard,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,kinesis,stream,shard,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<KinesisStreamShard, SequenceNumber> snapshotState();1492730110;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<KinesisStreamShard, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<KinesisStreamShard, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getKinesisStreamShard(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,kinesis,stream,shard,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,kinesis,stream,shard,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,kinesis,stream,shard,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<KinesisStreamShard, SequenceNumber> snapshotState();1494145732;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<KinesisStreamShard, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<KinesisStreamShard, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getKinesisStreamShard(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,kinesis,stream,shard,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,kinesis,stream,shard,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,kinesis,stream,shard,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<KinesisStreamShard, SequenceNumber> snapshotState();1494149584;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<KinesisStreamShard, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<KinesisStreamShard, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getKinesisStreamShard(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,kinesis,stream,shard,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,kinesis,stream,shard,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,kinesis,stream,shard,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1480685315;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1490934828;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1492730110;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1494145732;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1494149584;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1495787238;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1495787239;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1495923079;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1515757408;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1515757408;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1515757408;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1517943538;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1517943538;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1517943538;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<Throwable>(),_			new LinkedList<KinesisStreamShardState>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,throwable,new,linked,list,kinesis,stream,shard,state,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema);1517943538;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			new AtomicReference<>(),_			new ArrayList<>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,new,atomic,reference,new,array,list,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public void runFetcher() throws Exception;1480685315;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		if (LOG.isDebugEnabled()) {_			String logFormat = (!isRestoredFromFailure)_				? "Subtask {} is trying to discover initial shards ..."_				: "Subtask {} is trying to discover any new shards that were created while the consumer wasn't " +_				"running due to failure ..."___			LOG.debug(logFormat, indexOfThisConsumerSubtask)__		}_		List<KinesisStreamShard> newShardsCreatedWhileNotRunning = discoverNewShardsToSubscribe()__		for (KinesisStreamShard shard : newShardsCreatedWhileNotRunning) {_			_			_			_			_			InitialPosition initialPosition = InitialPosition.valueOf(configProps.getProperty(_				ConsumerConfigConstants.STREAM_INITIAL_POSITION, ConsumerConfigConstants.DEFAULT_STREAM_INITIAL_POSITION))___			SentinelSequenceNumber startingStateForNewShard = (isRestoredFromFailure)_				? SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM_				: initialPosition.toSentinelSequenceNumber()___			if (LOG.isInfoEnabled()) {_				String logFormat = (!isRestoredFromFailure)_					? "Subtask {} will be seeded with initial shard {}, starting state set as sequence number {}"_					: "Subtask {} will be seeded with new shard {} that was created while the consumer wasn't " +_					"running due to failure, starting state set as sequence number {}"___				LOG.info(logFormat, indexOfThisConsumerSubtask, shard.toString(), startingStateForNewShard.get())__			}_			registerNewSubscribedShardState(new KinesisStreamShardState(shard, startingStateForNewShard.get()))__		}__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getKinesisStreamShard().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getKinesisStreamShard(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum()))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		_		_		_		_		_		_		_		_		_		_		_		_		_		_		_		_		_		_		_		__		boolean emittedMaxValueWatermark = false___		if (this.numberOfActiveShards.get() == 0) {_			_			LOG.info("Subtask {} has no initial shards to read on startup_ emitting max value watermark ...",_				indexOfThisConsumerSubtask)__			sourceContext.emitWatermark(new Watermark(Long.MAX_VALUE))__			emittedMaxValueWatermark = true__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<KinesisStreamShard> newShardsDueToResharding = discoverNewShardsToSubscribe()___			_			_			_			_			_			_			_			_			_			_			_			__			if (newShardsDueToResharding.size() == 0 && this.numberOfActiveShards.get() == 0 && !emittedMaxValueWatermark) {_				_				LOG.info("Subtask {} has completed reading all shards_ emitting max value watermark ...",_					indexOfThisConsumerSubtask)__				sourceContext.emitWatermark(new Watermark(Long.MAX_VALUE))__				emittedMaxValueWatermark = true__			} else if (newShardsDueToResharding.size() > 0 && emittedMaxValueWatermark) {_				_				_				_				_				_				_				_				__				LOG.warn("Subtask {} has discovered {} new shards to subscribe, but is failing hard to avoid messing" +_						" up watermarks_ the new shards will be subscribed by this subtask after restore ...",_					indexOfThisConsumerSubtask, newShardsDueToResharding.size())__				throw new RuntimeException("Deliberate failure to avoid messing up watermarks")__			}__			for (KinesisStreamShard shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getKinesisStreamShard().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getKinesisStreamShard(),_						newShardState.getLastProcessedSequenceNum()))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,if,log,is,debug,enabled,string,log,format,is,restored,from,failure,subtask,is,trying,to,discover,initial,shards,subtask,is,trying,to,discover,any,new,shards,that,were,created,while,the,consumer,wasn,t,running,due,to,failure,log,debug,log,format,index,of,this,consumer,subtask,list,kinesis,stream,shard,new,shards,created,while,not,running,discover,new,shards,to,subscribe,for,kinesis,stream,shard,shard,new,shards,created,while,not,running,initial,position,initial,position,initial,position,value,of,config,props,get,property,consumer,config,constants,consumer,config,constants,sentinel,sequence,number,starting,state,for,new,shard,is,restored,from,failure,sentinel,sequence,number,initial,position,to,sentinel,sequence,number,if,log,is,info,enabled,string,log,format,is,restored,from,failure,subtask,will,be,seeded,with,initial,shard,starting,state,set,as,sequence,number,subtask,will,be,seeded,with,new,shard,that,was,created,while,the,consumer,wasn,t,running,due,to,failure,starting,state,set,as,sequence,number,log,info,log,format,index,of,this,consumer,subtask,shard,to,string,starting,state,for,new,shard,get,register,new,subscribed,shard,state,new,kinesis,stream,shard,state,shard,starting,state,for,new,shard,get,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,kinesis,stream,shard,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,kinesis,stream,shard,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,boolean,emitted,max,value,watermark,false,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,initial,shards,to,read,on,startup,emitting,max,value,watermark,index,of,this,consumer,subtask,source,context,emit,watermark,new,watermark,long,emitted,max,value,watermark,true,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,kinesis,stream,shard,new,shards,due,to,resharding,discover,new,shards,to,subscribe,if,new,shards,due,to,resharding,size,0,this,number,of,active,shards,get,0,emitted,max,value,watermark,log,info,subtask,has,completed,reading,all,shards,emitting,max,value,watermark,index,of,this,consumer,subtask,source,context,emit,watermark,new,watermark,long,emitted,max,value,watermark,true,else,if,new,shards,due,to,resharding,size,0,emitted,max,value,watermark,log,warn,subtask,has,discovered,new,shards,to,subscribe,but,is,failing,hard,to,avoid,messing,up,watermarks,the,new,shards,will,be,subscribed,by,this,subtask,after,restore,index,of,this,consumer,subtask,new,shards,due,to,resharding,size,throw,new,runtime,exception,deliberate,failure,to,avoid,messing,up,watermarks,for,kinesis,stream,shard,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,kinesis,stream,shard,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,kinesis,stream,shard,new,shard,state,get,last,processed,sequence,num,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1490934828;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		if (LOG.isDebugEnabled()) {_			String logFormat = (!isRestoredFromFailure)_				? "Subtask {} is trying to discover initial shards ..."_				: "Subtask {} is trying to discover any new shards that were created while the consumer wasn't " +_				"running due to failure ..."___			LOG.debug(logFormat, indexOfThisConsumerSubtask)__		}_		List<KinesisStreamShard> newShardsCreatedWhileNotRunning = discoverNewShardsToSubscribe()__		for (KinesisStreamShard shard : newShardsCreatedWhileNotRunning) {_			_			_			_			_			InitialPosition initialPosition = InitialPosition.valueOf(configProps.getProperty(_				ConsumerConfigConstants.STREAM_INITIAL_POSITION, ConsumerConfigConstants.DEFAULT_STREAM_INITIAL_POSITION))___			SentinelSequenceNumber startingStateForNewShard = (isRestoredFromFailure)_				? SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM_				: initialPosition.toSentinelSequenceNumber()___			if (LOG.isInfoEnabled()) {_				String logFormat = (!isRestoredFromFailure)_					? "Subtask {} will be seeded with initial shard {}, starting state set as sequence number {}"_					: "Subtask {} will be seeded with new shard {} that was created while the consumer wasn't " +_					"running due to failure, starting state set as sequence number {}"___				LOG.info(logFormat, indexOfThisConsumerSubtask, shard.toString(), startingStateForNewShard.get())__			}_			registerNewSubscribedShardState(new KinesisStreamShardState(shard, startingStateForNewShard.get()))__		}__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getKinesisStreamShard().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getKinesisStreamShard(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum()))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<KinesisStreamShard> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (KinesisStreamShard shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getKinesisStreamShard().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getKinesisStreamShard(),_						newShardState.getLastProcessedSequenceNum()))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,if,log,is,debug,enabled,string,log,format,is,restored,from,failure,subtask,is,trying,to,discover,initial,shards,subtask,is,trying,to,discover,any,new,shards,that,were,created,while,the,consumer,wasn,t,running,due,to,failure,log,debug,log,format,index,of,this,consumer,subtask,list,kinesis,stream,shard,new,shards,created,while,not,running,discover,new,shards,to,subscribe,for,kinesis,stream,shard,shard,new,shards,created,while,not,running,initial,position,initial,position,initial,position,value,of,config,props,get,property,consumer,config,constants,consumer,config,constants,sentinel,sequence,number,starting,state,for,new,shard,is,restored,from,failure,sentinel,sequence,number,initial,position,to,sentinel,sequence,number,if,log,is,info,enabled,string,log,format,is,restored,from,failure,subtask,will,be,seeded,with,initial,shard,starting,state,set,as,sequence,number,subtask,will,be,seeded,with,new,shard,that,was,created,while,the,consumer,wasn,t,running,due,to,failure,starting,state,set,as,sequence,number,log,info,log,format,index,of,this,consumer,subtask,shard,to,string,starting,state,for,new,shard,get,register,new,subscribed,shard,state,new,kinesis,stream,shard,state,shard,starting,state,for,new,shard,get,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,kinesis,stream,shard,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,kinesis,stream,shard,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,kinesis,stream,shard,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,kinesis,stream,shard,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,kinesis,stream,shard,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,kinesis,stream,shard,new,shard,state,get,last,processed,sequence,num,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1492730110;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		if (LOG.isDebugEnabled()) {_			String logFormat = (!isRestoredFromFailure)_				? "Subtask {} is trying to discover initial shards ..."_				: "Subtask {} is trying to discover any new shards that were created while the consumer wasn't " +_				"running due to failure ..."___			LOG.debug(logFormat, indexOfThisConsumerSubtask)__		}_		List<KinesisStreamShard> newShardsCreatedWhileNotRunning = discoverNewShardsToSubscribe()__		for (KinesisStreamShard shard : newShardsCreatedWhileNotRunning) {_			_			_			_			_			InitialPosition initialPosition = InitialPosition.valueOf(configProps.getProperty(_				ConsumerConfigConstants.STREAM_INITIAL_POSITION, ConsumerConfigConstants.DEFAULT_STREAM_INITIAL_POSITION))___			SentinelSequenceNumber startingStateForNewShard = (isRestoredFromFailure)_				? SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM_				: initialPosition.toSentinelSequenceNumber()___			if (LOG.isInfoEnabled()) {_				String logFormat = (!isRestoredFromFailure)_					? "Subtask {} will be seeded with initial shard {}, starting state set as sequence number {}"_					: "Subtask {} will be seeded with new shard {} that was created while the consumer wasn't " +_					"running due to failure, starting state set as sequence number {}"___				LOG.info(logFormat, indexOfThisConsumerSubtask, shard.toString(), startingStateForNewShard.get())__			}_			registerNewSubscribedShardState(new KinesisStreamShardState(shard, startingStateForNewShard.get()))__		}__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getKinesisStreamShard().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getKinesisStreamShard(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum()))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<KinesisStreamShard> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (KinesisStreamShard shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getKinesisStreamShard().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getKinesisStreamShard(),_						newShardState.getLastProcessedSequenceNum()))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,if,log,is,debug,enabled,string,log,format,is,restored,from,failure,subtask,is,trying,to,discover,initial,shards,subtask,is,trying,to,discover,any,new,shards,that,were,created,while,the,consumer,wasn,t,running,due,to,failure,log,debug,log,format,index,of,this,consumer,subtask,list,kinesis,stream,shard,new,shards,created,while,not,running,discover,new,shards,to,subscribe,for,kinesis,stream,shard,shard,new,shards,created,while,not,running,initial,position,initial,position,initial,position,value,of,config,props,get,property,consumer,config,constants,consumer,config,constants,sentinel,sequence,number,starting,state,for,new,shard,is,restored,from,failure,sentinel,sequence,number,initial,position,to,sentinel,sequence,number,if,log,is,info,enabled,string,log,format,is,restored,from,failure,subtask,will,be,seeded,with,initial,shard,starting,state,set,as,sequence,number,subtask,will,be,seeded,with,new,shard,that,was,created,while,the,consumer,wasn,t,running,due,to,failure,starting,state,set,as,sequence,number,log,info,log,format,index,of,this,consumer,subtask,shard,to,string,starting,state,for,new,shard,get,register,new,subscribed,shard,state,new,kinesis,stream,shard,state,shard,starting,state,for,new,shard,get,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,kinesis,stream,shard,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,kinesis,stream,shard,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,kinesis,stream,shard,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,kinesis,stream,shard,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,kinesis,stream,shard,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,kinesis,stream,shard,new,shard,state,get,last,processed,sequence,num,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1494145732;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		if (LOG.isDebugEnabled()) {_			String logFormat = (!isRestoredFromFailure)_				? "Subtask {} is trying to discover initial shards ..."_				: "Subtask {} is trying to discover any new shards that were created while the consumer wasn't " +_				"running due to failure ..."___			LOG.debug(logFormat, indexOfThisConsumerSubtask)__		}_		List<KinesisStreamShard> newShardsCreatedWhileNotRunning = discoverNewShardsToSubscribe()__		for (KinesisStreamShard shard : newShardsCreatedWhileNotRunning) {_			_			_			_			_			InitialPosition initialPosition = InitialPosition.valueOf(configProps.getProperty(_				ConsumerConfigConstants.STREAM_INITIAL_POSITION, ConsumerConfigConstants.DEFAULT_STREAM_INITIAL_POSITION))___			SentinelSequenceNumber startingStateForNewShard = (isRestoredFromFailure)_				? SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM_				: initialPosition.toSentinelSequenceNumber()___			if (LOG.isInfoEnabled()) {_				String logFormat = (!isRestoredFromFailure)_					? "Subtask {} will be seeded with initial shard {}, starting state set as sequence number {}"_					: "Subtask {} will be seeded with new shard {} that was created while the consumer wasn't " +_					"running due to failure, starting state set as sequence number {}"___				LOG.info(logFormat, indexOfThisConsumerSubtask, shard.toString(), startingStateForNewShard.get())__			}_			registerNewSubscribedShardState(new KinesisStreamShardState(shard, startingStateForNewShard.get()))__		}__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getKinesisStreamShard().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getKinesisStreamShard(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum()))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<KinesisStreamShard> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (KinesisStreamShard shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getKinesisStreamShard().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getKinesisStreamShard(),_						newShardState.getLastProcessedSequenceNum()))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,if,log,is,debug,enabled,string,log,format,is,restored,from,failure,subtask,is,trying,to,discover,initial,shards,subtask,is,trying,to,discover,any,new,shards,that,were,created,while,the,consumer,wasn,t,running,due,to,failure,log,debug,log,format,index,of,this,consumer,subtask,list,kinesis,stream,shard,new,shards,created,while,not,running,discover,new,shards,to,subscribe,for,kinesis,stream,shard,shard,new,shards,created,while,not,running,initial,position,initial,position,initial,position,value,of,config,props,get,property,consumer,config,constants,consumer,config,constants,sentinel,sequence,number,starting,state,for,new,shard,is,restored,from,failure,sentinel,sequence,number,initial,position,to,sentinel,sequence,number,if,log,is,info,enabled,string,log,format,is,restored,from,failure,subtask,will,be,seeded,with,initial,shard,starting,state,set,as,sequence,number,subtask,will,be,seeded,with,new,shard,that,was,created,while,the,consumer,wasn,t,running,due,to,failure,starting,state,set,as,sequence,number,log,info,log,format,index,of,this,consumer,subtask,shard,to,string,starting,state,for,new,shard,get,register,new,subscribed,shard,state,new,kinesis,stream,shard,state,shard,starting,state,for,new,shard,get,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,kinesis,stream,shard,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,kinesis,stream,shard,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,kinesis,stream,shard,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,kinesis,stream,shard,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,kinesis,stream,shard,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,kinesis,stream,shard,new,shard,state,get,last,processed,sequence,num,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1494149584;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getKinesisStreamShard().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getKinesisStreamShard(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum()))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<KinesisStreamShard> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (KinesisStreamShard shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getKinesisStreamShard().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getKinesisStreamShard(),_						newShardState.getLastProcessedSequenceNum()))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,kinesis,stream,shard,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,kinesis,stream,shard,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,kinesis,stream,shard,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,kinesis,stream,shard,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,kinesis,stream,shard,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,kinesis,stream,shard,new,shard,state,get,last,processed,sequence,num,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1495787238;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum()))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(createKinesisStreamShardV2(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum()))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,create,kinesis,stream,shard,v2,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1495787239;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum()))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum()))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1495923079;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum()))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum()))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1515757408;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerMetricGroupForShard(subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerMetricGroupForShard(newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,metric,group,for,shard,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,metric,group,for,shard,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1515757408;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1515757408;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1517943538;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1517943538;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1517943538;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1517943538;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1518718884;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1519386499;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					new ShardConsumer<>(_						this,_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,new,shard,consumer,this,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,new,shard,consumer,this,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1533129233;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					createShardConsumer(_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					createShardConsumer(_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,create,shard,consumer,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,create,shard,consumer,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1534479217;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					createShardConsumer(_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					createShardConsumer(_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,create,shard,consumer,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,create,shard,consumer,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1542797087;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					createShardConsumer(_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__        _		if (periodicWatermarkAssigner != null) {_			long periodicWatermarkIntervalMillis = runtimeContext.getExecutionConfig().getAutoWatermarkInterval()__			if (periodicWatermarkIntervalMillis > 0) {_				ProcessingTimeService timerService = ((StreamingRuntimeContext) runtimeContext).getProcessingTimeService()__				LOG.info("Starting periodic watermark emitter with interval {}", periodicWatermarkIntervalMillis)__				new PeriodicWatermarkEmitter(timerService, periodicWatermarkIntervalMillis).start()__			}_			this.shardIdleIntervalMillis = Long.parseLong(_				getConsumerConfiguration().getProperty(ConsumerConfigConstants.SHARD_IDLE_INTERVAL_MILLIS,_					Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_IDLE_INTERVAL_MILLIS)))__		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					createShardConsumer(_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,create,shard,consumer,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,if,periodic,watermark,assigner,null,long,periodic,watermark,interval,millis,runtime,context,get,execution,config,get,auto,watermark,interval,if,periodic,watermark,interval,millis,0,processing,time,service,timer,service,streaming,runtime,context,runtime,context,get,processing,time,service,log,info,starting,periodic,watermark,emitter,with,interval,periodic,watermark,interval,millis,new,periodic,watermark,emitter,timer,service,periodic,watermark,interval,millis,start,this,shard,idle,interval,millis,long,parse,long,get,consumer,configuration,get,property,consumer,config,constants,long,to,string,consumer,config,constants,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,create,shard,consumer,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1545495597;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					createShardConsumer(_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__        _		if (periodicWatermarkAssigner != null) {_			long periodicWatermarkIntervalMillis = runtimeContext.getExecutionConfig().getAutoWatermarkInterval()__			if (periodicWatermarkIntervalMillis > 0) {_				ProcessingTimeService timerService = ((StreamingRuntimeContext) runtimeContext).getProcessingTimeService()__				LOG.info("Starting periodic watermark emitter with interval {}", periodicWatermarkIntervalMillis)__				new PeriodicWatermarkEmitter(timerService, periodicWatermarkIntervalMillis).start()__			}_			this.shardIdleIntervalMillis = Long.parseLong(_				getConsumerConfiguration().getProperty(ConsumerConfigConstants.SHARD_IDLE_INTERVAL_MILLIS,_					Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_IDLE_INTERVAL_MILLIS)))__		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					createShardConsumer(_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		awaitTermination()___		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,create,shard,consumer,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,if,periodic,watermark,assigner,null,long,periodic,watermark,interval,millis,runtime,context,get,execution,config,get,auto,watermark,interval,if,periodic,watermark,interval,millis,0,processing,time,service,timer,service,streaming,runtime,context,runtime,context,get,processing,time,service,log,info,starting,periodic,watermark,emitter,with,interval,periodic,watermark,interval,millis,new,periodic,watermark,emitter,timer,service,periodic,watermark,interval,millis,start,this,shard,idle,interval,millis,long,parse,long,get,consumer,configuration,get,property,consumer,config,constants,long,to,string,consumer,config,constants,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,create,shard,consumer,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,await,termination,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> public void runFetcher() throws Exception;1550197938;Starts the fetcher. After starting the fetcher, it can only_be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.__@throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.;public void runFetcher() throws Exception {__		_		if (!running) {_			return__		}__		this.mainThread = Thread.currentThread()___		_		_		__		_		_		boolean hasShards = false__		StringBuilder streamsWithNoShardsFound = new StringBuilder()__		for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {_			if (streamToLastDiscoveredShardEntry.getValue() != null) {_				hasShards = true__			} else {_				streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ")__			}_		}__		if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {_			LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}",_				indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString())__		}__		if (!hasShards) {_			throw new RuntimeException("No shards can be found for all subscribed streams: " + streams)__		}__		_		_		_		for (int seededStateIndex = 0_ seededStateIndex < subscribedShardsState.size()_ seededStateIndex++) {_			KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex)___			_			if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {__				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(),_						seededShardState.getLastProcessedSequenceNum(), seededStateIndex)__					}__				shardConsumersExecutor.submit(_					createShardConsumer(_						seededStateIndex,_						subscribedShardsState.get(seededStateIndex).getStreamShardHandle(),_						subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex))))__			}_		}__        _		if (periodicWatermarkAssigner != null) {_			long periodicWatermarkIntervalMillis = runtimeContext.getExecutionConfig().getAutoWatermarkInterval()__			if (periodicWatermarkIntervalMillis > 0) {_				ProcessingTimeService timerService = ((StreamingRuntimeContext) runtimeContext).getProcessingTimeService()__				LOG.info("Starting periodic watermark emitter with interval {}", periodicWatermarkIntervalMillis)__				new PeriodicWatermarkEmitter(timerService, periodicWatermarkIntervalMillis).start()__			}_			this.shardIdleIntervalMillis = Long.parseLong(_				getConsumerConfiguration().getProperty(ConsumerConfigConstants.SHARD_IDLE_INTERVAL_MILLIS,_					Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_IDLE_INTERVAL_MILLIS)))__		}__		__		_		__		final long discoveryIntervalMillis = Long.valueOf(_			configProps.getProperty(_				ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS,_				Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS)))___		if (this.numberOfActiveShards.get() == 0) {_			LOG.info("Subtask {} has no active shards to read on startup_ marking the subtask as temporarily idle ...",_				indexOfThisConsumerSubtask)__			sourceContext.markAsTemporarilyIdle()__		}__		while (running) {_			if (LOG.isDebugEnabled()) {_				LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...",_					indexOfThisConsumerSubtask)__			}_			List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe()___			for (StreamShardHandle shard : newShardsDueToResharding) {_				_				_				KinesisStreamShardState newShardState =_					new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())__				int newStateIndex = registerNewSubscribedShardState(newShardState)___				if (LOG.isInfoEnabled()) {_					LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " +_							"the shard from sequence number {} with ShardConsumer {}",_						indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(),_						newShardState.getLastProcessedSequenceNum(), newStateIndex)__				}__				shardConsumersExecutor.submit(_					createShardConsumer(_						newStateIndex,_						newShardState.getStreamShardHandle(),_						newShardState.getLastProcessedSequenceNum(),_						registerShardMetrics(consumerMetricGroup, newShardState)))__			}__			_			_			if (running && discoveryIntervalMillis != 0) {_				try {_					Thread.sleep(discoveryIntervalMillis)__				} catch (InterruptedException iex) {_					_				}_			}_		}__		_		try {_			awaitTermination()__		} catch (InterruptedException ie) {_			_			this.error.compareAndSet(null, ie)__		}__		_		Throwable throwable = this.error.get()__		if (throwable != null) {_			if (throwable instanceof Exception) {_				throw (Exception) throwable__			} else if (throwable instanceof Error) {_				throw (Error) throwable__			} else {_				throw new Exception(throwable)__			}_		}_	};starts,the,fetcher,after,starting,the,fetcher,it,can,only,be,stopped,by,calling,link,kinesis,data,fetcher,shutdown,fetcher,throws,exception,the,first,error,or,exception,thrown,by,the,fetcher,or,any,of,the,threads,created,by,the,fetcher;public,void,run,fetcher,throws,exception,if,running,return,this,main,thread,thread,current,thread,boolean,has,shards,false,string,builder,streams,with,no,shards,found,new,string,builder,for,map,entry,string,string,stream,to,last,discovered,shard,entry,subscribed,streams,to,last,discovered,shard,ids,entry,set,if,stream,to,last,discovered,shard,entry,get,value,null,has,shards,true,else,streams,with,no,shards,found,append,stream,to,last,discovered,shard,entry,get,key,append,if,streams,with,no,shards,found,length,0,log,is,warn,enabled,log,warn,subtask,has,failed,to,find,any,shards,for,the,following,subscribed,streams,index,of,this,consumer,subtask,streams,with,no,shards,found,to,string,if,has,shards,throw,new,runtime,exception,no,shards,can,be,found,for,all,subscribed,streams,streams,for,int,seeded,state,index,0,seeded,state,index,subscribed,shards,state,size,seeded,state,index,kinesis,stream,shard,state,seeded,shard,state,subscribed,shards,state,get,seeded,state,index,if,seeded,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,if,log,is,info,enabled,log,info,subtask,will,start,consuming,seeded,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,seeded,shard,state,get,stream,shard,handle,to,string,seeded,shard,state,get,last,processed,sequence,num,seeded,state,index,shard,consumers,executor,submit,create,shard,consumer,seeded,state,index,subscribed,shards,state,get,seeded,state,index,get,stream,shard,handle,subscribed,shards,state,get,seeded,state,index,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,subscribed,shards,state,get,seeded,state,index,if,periodic,watermark,assigner,null,long,periodic,watermark,interval,millis,runtime,context,get,execution,config,get,auto,watermark,interval,if,periodic,watermark,interval,millis,0,processing,time,service,timer,service,streaming,runtime,context,runtime,context,get,processing,time,service,log,info,starting,periodic,watermark,emitter,with,interval,periodic,watermark,interval,millis,new,periodic,watermark,emitter,timer,service,periodic,watermark,interval,millis,start,this,shard,idle,interval,millis,long,parse,long,get,consumer,configuration,get,property,consumer,config,constants,long,to,string,consumer,config,constants,final,long,discovery,interval,millis,long,value,of,config,props,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,this,number,of,active,shards,get,0,log,info,subtask,has,no,active,shards,to,read,on,startup,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,while,running,if,log,is,debug,enabled,log,debug,subtask,is,trying,to,discover,new,shards,that,were,created,due,to,resharding,index,of,this,consumer,subtask,list,stream,shard,handle,new,shards,due,to,resharding,discover,new,shards,to,subscribe,for,stream,shard,handle,shard,new,shards,due,to,resharding,kinesis,stream,shard,state,new,shard,state,new,kinesis,stream,shard,state,convert,to,stream,shard,metadata,shard,shard,sentinel,sequence,number,get,int,new,state,index,register,new,subscribed,shard,state,new,shard,state,if,log,is,info,enabled,log,info,subtask,has,discovered,a,new,shard,due,to,resharding,and,will,start,consuming,the,shard,from,sequence,number,with,shard,consumer,index,of,this,consumer,subtask,new,shard,state,get,stream,shard,handle,to,string,new,shard,state,get,last,processed,sequence,num,new,state,index,shard,consumers,executor,submit,create,shard,consumer,new,state,index,new,shard,state,get,stream,shard,handle,new,shard,state,get,last,processed,sequence,num,register,shard,metrics,consumer,metric,group,new,shard,state,if,running,discovery,interval,millis,0,try,thread,sleep,discovery,interval,millis,catch,interrupted,exception,iex,try,await,termination,catch,interrupted,exception,ie,this,error,compare,and,set,null,ie,throwable,throwable,this,error,get,if,throwable,null,if,throwable,instanceof,exception,throw,exception,throwable,else,if,throwable,instanceof,error,throw,error,throwable,else,throw,new,exception,throwable
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1480685315;This constructor is exposed for testing purposes;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1490934828;This constructor is exposed for testing purposes;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1492730110;This constructor is exposed for testing purposes;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1494145732;This constructor is exposed for testing purposes;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1494149584;This constructor is exposed for testing purposes;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1495787238;This constructor is exposed for testing purposes;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1495787239;This constructor is exposed for testing purposes;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1495923079;This constructor is exposed for testing purposes.;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1515757408;This constructor is exposed for testing purposes.;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1515757408;This constructor is exposed for testing purposes.;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.consumerMetricGroup = runtimeContext.getMetricGroup()_			.addGroup(KinesisConsumerMetricConstants.KINESIS_CONSUMER_METRICS_GROUP)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,consumer,metric,group,runtime,context,get,metric,group,add,group,kinesis,consumer,metric,constants,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> protected KinesisDataFetcher(List<String> streams, 								SourceFunction.SourceContext<T> sourceContext, 								Object checkpointLock, 								RuntimeContext runtimeContext, 								Properties configProps, 								KinesisDeserializationSchema<T> deserializationSchema, 								AtomicReference<Throwable> error, 								LinkedList<KinesisStreamShardState> subscribedShardsState, 								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds, 								KinesisProxyInterface kinesis);1515757408;This constructor is exposed for testing purposes.;protected KinesisDataFetcher(List<String> streams,_								SourceFunction.SourceContext<T> sourceContext,_								Object checkpointLock,_								RuntimeContext runtimeContext,_								Properties configProps,_								KinesisDeserializationSchema<T> deserializationSchema,_								AtomicReference<Throwable> error,_								LinkedList<KinesisStreamShardState> subscribedShardsState,_								HashMap<String, String> subscribedStreamsToLastDiscoveredShardIds,_								KinesisProxyInterface kinesis) {_		this.streams = checkNotNull(streams)__		this.configProps = checkNotNull(configProps)__		this.sourceContext = checkNotNull(sourceContext)__		this.checkpointLock = checkNotNull(checkpointLock)__		this.runtimeContext = checkNotNull(runtimeContext)__		this.totalNumberOfConsumerSubtasks = runtimeContext.getNumberOfParallelSubtasks()__		this.indexOfThisConsumerSubtask = runtimeContext.getIndexOfThisSubtask()__		this.deserializationSchema = checkNotNull(deserializationSchema)__		this.kinesis = checkNotNull(kinesis)___		this.consumerMetricGroup = runtimeContext.getMetricGroup()_			.addGroup(KinesisConsumerMetricConstants.KINESIS_CONSUMER_METRICS_GROUP)___		this.error = checkNotNull(error)__		this.subscribedShardsState = checkNotNull(subscribedShardsState)__		this.subscribedStreamsToLastDiscoveredShardIds = checkNotNull(subscribedStreamsToLastDiscoveredShardIds)___		this.shardConsumersExecutor =_			createShardConsumersThreadPool(runtimeContext.getTaskNameWithSubtasks())__	};this,constructor,is,exposed,for,testing,purposes;protected,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,object,checkpoint,lock,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,atomic,reference,throwable,error,linked,list,kinesis,stream,shard,state,subscribed,shards,state,hash,map,string,string,subscribed,streams,to,last,discovered,shard,ids,kinesis,proxy,interface,kinesis,this,streams,check,not,null,streams,this,config,props,check,not,null,config,props,this,source,context,check,not,null,source,context,this,checkpoint,lock,check,not,null,checkpoint,lock,this,runtime,context,check,not,null,runtime,context,this,total,number,of,consumer,subtasks,runtime,context,get,number,of,parallel,subtasks,this,index,of,this,consumer,subtask,runtime,context,get,index,of,this,subtask,this,deserialization,schema,check,not,null,deserialization,schema,this,kinesis,check,not,null,kinesis,this,consumer,metric,group,runtime,context,get,metric,group,add,group,kinesis,consumer,metric,constants,this,error,check,not,null,error,this,subscribed,shards,state,check,not,null,subscribed,shards,state,this,subscribed,streams,to,last,discovered,shard,ids,check,not,null,subscribed,streams,to,last,discovered,shard,ids,this,shard,consumers,executor,create,shard,consumers,thread,pool,runtime,context,get,task,name,with,subtasks
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1495787238;A utility function that does the following:__1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1495787239;A utility function that does the following:__1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1495923079;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1515757408;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1515757408;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1515757408;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1517943538;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1517943538;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1517943538;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1517943538;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1518718884;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					int hashCode = shardAssigner.assign(newShard, totalNumberOfConsumerSubtasks)__					if (isThisSubtaskShouldSubscribeTo(hashCode, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,int,hash,code,shard,assigner,assign,new,shard,total,number,of,consumer,subtasks,if,is,this,subtask,should,subscribe,to,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1519386499;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					int hashCode = shardAssigner.assign(newShard, totalNumberOfConsumerSubtasks)__					if (isThisSubtaskShouldSubscribeTo(hashCode, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,int,hash,code,shard,assigner,assign,new,shard,total,number,of,consumer,subtasks,if,is,this,subtask,should,subscribe,to,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1533129233;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					int hashCode = shardAssigner.assign(newShard, totalNumberOfConsumerSubtasks)__					if (isThisSubtaskShouldSubscribeTo(hashCode, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,int,hash,code,shard,assigner,assign,new,shard,total,number,of,consumer,subtasks,if,is,this,subtask,should,subscribe,to,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1534479217;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					int hashCode = shardAssigner.assign(newShard, totalNumberOfConsumerSubtasks)__					if (isThisSubtaskShouldSubscribeTo(hashCode, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,int,hash,code,shard,assigner,assign,new,shard,total,number,of,consumer,subtasks,if,is,this,subtask,should,subscribe,to,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1542797087;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					int hashCode = shardAssigner.assign(newShard, totalNumberOfConsumerSubtasks)__					if (isThisSubtaskShouldSubscribeTo(hashCode, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,int,hash,code,shard,assigner,assign,new,shard,total,number,of,consumer,subtasks,if,is,this,subtask,should,subscribe,to,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1545495597;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					int hashCode = shardAssigner.assign(newShard, totalNumberOfConsumerSubtasks)__					if (isThisSubtaskShouldSubscribeTo(hashCode, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,int,hash,code,shard,assigner,assign,new,shard,total,number,of,consumer,subtasks,if,is,this,subtask,should,subscribe,to,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException;1550197938;A utility function that does the following:__<p>1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {__		List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (StreamShardHandle newShard : newShardsOfStream) {_					int hashCode = shardAssigner.assign(newShard, totalNumberOfConsumerSubtasks)__					if (isThisSubtaskShouldSubscribeTo(hashCode, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,p,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,stream,shard,handle,discover,new,shards,to,subscribe,throws,interrupted,exception,list,stream,shard,handle,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,stream,shard,handle,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,stream,shard,handle,new,shard,new,shards,of,stream,int,hash,code,shard,assigner,assign,new,shard,total,number,of,consumer,subtasks,if,is,this,subtask,should,subscribe,to,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema, 							KinesisShardAssigner shardAssigner, 							AssignerWithPeriodicWatermarks<T> periodicWatermarkAssigner);1542797087;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema,_							KinesisShardAssigner shardAssigner,_							AssignerWithPeriodicWatermarks<T> periodicWatermarkAssigner) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			shardAssigner,_			periodicWatermarkAssigner,_			new AtomicReference<>(),_			new ArrayList<>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy::create)__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,kinesis,shard,assigner,shard,assigner,assigner,with,periodic,watermarks,t,periodic,watermark,assigner,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,shard,assigner,periodic,watermark,assigner,new,atomic,reference,new,array,list,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema, 							KinesisShardAssigner shardAssigner, 							AssignerWithPeriodicWatermarks<T> periodicWatermarkAssigner);1545495597;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema,_							KinesisShardAssigner shardAssigner,_							AssignerWithPeriodicWatermarks<T> periodicWatermarkAssigner) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			shardAssigner,_			periodicWatermarkAssigner,_			new AtomicReference<>(),_			new ArrayList<>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy::create)__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,kinesis,shard,assigner,shard,assigner,assigner,with,periodic,watermarks,t,periodic,watermark,assigner,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,shard,assigner,periodic,watermark,assigner,new,atomic,reference,new,array,list,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema, 							KinesisShardAssigner shardAssigner, 							AssignerWithPeriodicWatermarks<T> periodicWatermarkAssigner);1550197938;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema,_							KinesisShardAssigner shardAssigner,_							AssignerWithPeriodicWatermarks<T> periodicWatermarkAssigner) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			shardAssigner,_			periodicWatermarkAssigner,_			new AtomicReference<>(),_			new ArrayList<>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy::create)__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,kinesis,shard,assigner,shard,assigner,assigner,with,periodic,watermarks,t,periodic,watermark,assigner,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,shard,assigner,periodic,watermark,assigner,new,atomic,reference,new,array,list,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create
KinesisDataFetcher -> private List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException;1480685315;A utility function that does the following:__1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;private List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException {__		List<KinesisStreamShard> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<KinesisStreamShard> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (KinesisStreamShard newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;private,list,kinesis,stream,shard,discover,new,shards,to,subscribe,throws,interrupted,exception,list,kinesis,stream,shard,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,kinesis,stream,shard,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,kinesis,stream,shard,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> private List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException;1490934828;A utility function that does the following:__1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;private List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException {__		List<KinesisStreamShard> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<KinesisStreamShard> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (KinesisStreamShard newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;private,list,kinesis,stream,shard,discover,new,shards,to,subscribe,throws,interrupted,exception,list,kinesis,stream,shard,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,kinesis,stream,shard,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,kinesis,stream,shard,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> private List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException;1492730110;A utility function that does the following:__1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;private List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException {__		List<KinesisStreamShard> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<KinesisStreamShard> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (KinesisStreamShard newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;private,list,kinesis,stream,shard,discover,new,shards,to,subscribe,throws,interrupted,exception,list,kinesis,stream,shard,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,kinesis,stream,shard,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,kinesis,stream,shard,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1495787239;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1495923079;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1515757408;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1515757408;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1515757408;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1517943538;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1517943538;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1517943538;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1517943538;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1518718884;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1519386499;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1533129233;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1534479217;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1542797087;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1545495597;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata);1550197938;Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.__@param streamShardMetadata the {@link StreamShardMetadata} to be converted_@return a {@link StreamShardHandle} object;public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {_		Shard shard = new Shard()__		shard.withShardId(streamShardMetadata.getShardId())__		shard.withParentShardId(streamShardMetadata.getParentShardId())__		shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId())___		HashKeyRange hashKeyRange = new HashKeyRange()__		hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey())__		hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey())__		shard.withHashKeyRange(hashKeyRange)___		SequenceNumberRange sequenceNumberRange = new SequenceNumberRange()__		sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber())__		sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber())__		shard.withSequenceNumberRange(sequenceNumberRange)___		return new StreamShardHandle(streamShardMetadata.getStreamName(), shard)__	};utility,function,to,convert,link,stream,shard,metadata,into,link,stream,shard,handle,param,stream,shard,metadata,the,link,stream,shard,metadata,to,be,converted,return,a,link,stream,shard,handle,object;public,static,stream,shard,handle,convert,to,stream,shard,handle,stream,shard,metadata,stream,shard,metadata,shard,shard,new,shard,shard,with,shard,id,stream,shard,metadata,get,shard,id,shard,with,parent,shard,id,stream,shard,metadata,get,parent,shard,id,shard,with,adjacent,parent,shard,id,stream,shard,metadata,get,adjacent,parent,shard,id,hash,key,range,hash,key,range,new,hash,key,range,hash,key,range,with,starting,hash,key,stream,shard,metadata,get,starting,hash,key,hash,key,range,with,ending,hash,key,stream,shard,metadata,get,ending,hash,key,shard,with,hash,key,range,hash,key,range,sequence,number,range,sequence,number,range,new,sequence,number,range,sequence,number,range,with,starting,sequence,number,stream,shard,metadata,get,starting,sequence,number,sequence,number,range,with,ending,sequence,number,stream,shard,metadata,get,ending,sequence,number,shard,with,sequence,number,range,sequence,number,range,return,new,stream,shard,handle,stream,shard,metadata,get,stream,name,shard
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1480685315;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream()__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1490934828;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream()__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1492730110;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream()__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1494145732;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream()__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1494149584;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream()__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1495787238;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream()__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1495787239;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream()__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1495923079;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1515757408;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1515757408;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1515757408;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1517943538;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1517943538;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1517943538;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1517943538;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1518718884;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1519386499;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1533129233;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1534479217;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1542797087;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1545495597;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams);1550197938;Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null__This is called in the constructor_ correct values will be set later on by calling advanceLastDiscoveredShardOfStream().__@param streams the list of subscribed streams_@return the initial map for subscribedStreamsToLastDiscoveredShardIds;protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {_		HashMap<String, String> initial = new HashMap<>()__		for (String stream : streams) {_			initial.put(stream, null)__		}_		return initial__	};utility,function,to,create,an,initial,map,of,the,last,discovered,shard,id,of,each,subscribed,stream,set,to,null,this,is,called,in,the,constructor,correct,values,will,be,set,later,on,by,calling,advance,last,discovered,shard,of,stream,param,streams,the,list,of,subscribed,streams,return,the,initial,map,for,subscribed,streams,to,last,discovered,shard,ids;protected,static,hash,map,string,string,create,initial,subscribed,streams,to,last,discovered,shards,state,list,string,streams,hash,map,string,string,initial,new,hash,map,for,string,stream,streams,initial,put,stream,null,return,initial
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema, 							KinesisShardAssigner shardAssigner);1518718884;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema,_							KinesisShardAssigner shardAssigner) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			shardAssigner,_			new AtomicReference<>(),_			new ArrayList<>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,kinesis,shard,assigner,shard,assigner,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,shard,assigner,new,atomic,reference,new,array,list,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema, 							KinesisShardAssigner shardAssigner);1519386499;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema,_							KinesisShardAssigner shardAssigner) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			shardAssigner,_			new AtomicReference<>(),_			new ArrayList<>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy.create(configProps))__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,kinesis,shard,assigner,shard,assigner,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,shard,assigner,new,atomic,reference,new,array,list,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create,config,props
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema, 							KinesisShardAssigner shardAssigner);1533129233;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema,_							KinesisShardAssigner shardAssigner) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			shardAssigner,_			new AtomicReference<>(),_			new ArrayList<>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy::create)__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,kinesis,shard,assigner,shard,assigner,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,shard,assigner,new,atomic,reference,new,array,list,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create
KinesisDataFetcher -> public KinesisDataFetcher(List<String> streams, 							SourceFunction.SourceContext<T> sourceContext, 							RuntimeContext runtimeContext, 							Properties configProps, 							KinesisDeserializationSchema<T> deserializationSchema, 							KinesisShardAssigner shardAssigner);1534479217;Creates a Kinesis Data Fetcher.__@param streams the streams to subscribe to_@param sourceContext context of the source function_@param runtimeContext this subtask's runtime context_@param configProps the consumer configuration properties_@param deserializationSchema deserialization schema;public KinesisDataFetcher(List<String> streams,_							SourceFunction.SourceContext<T> sourceContext,_							RuntimeContext runtimeContext,_							Properties configProps,_							KinesisDeserializationSchema<T> deserializationSchema,_							KinesisShardAssigner shardAssigner) {_		this(streams,_			sourceContext,_			sourceContext.getCheckpointLock(),_			runtimeContext,_			configProps,_			deserializationSchema,_			shardAssigner,_			new AtomicReference<>(),_			new ArrayList<>(),_			createInitialSubscribedStreamsToLastDiscoveredShardsState(streams),_			KinesisProxy::create)__	};creates,a,kinesis,data,fetcher,param,streams,the,streams,to,subscribe,to,param,source,context,context,of,the,source,function,param,runtime,context,this,subtask,s,runtime,context,param,config,props,the,consumer,configuration,properties,param,deserialization,schema,deserialization,schema;public,kinesis,data,fetcher,list,string,streams,source,function,source,context,t,source,context,runtime,context,runtime,context,properties,config,props,kinesis,deserialization,schema,t,deserialization,schema,kinesis,shard,assigner,shard,assigner,this,streams,source,context,source,context,get,checkpoint,lock,runtime,context,config,props,deserialization,schema,shard,assigner,new,atomic,reference,new,array,list,create,initial,subscribed,streams,to,last,discovered,shards,state,streams,kinesis,proxy,create
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1480685315;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1490934828;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1492730110;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1494145732;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1494149584;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1495787238;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1495787239;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1495923079;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1515757408;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1515757408;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1515757408;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1517943538;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1517943538;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1517943538;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1517943538;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1518718884;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1519386499;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1533129233;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1534479217;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1542797087;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1545495597;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> protected void stopWithError(Throwable throwable);1550197938;Called by created threads to pass on errors. Only the first thrown error is set._Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.;protected void stopWithError(Throwable throwable) {_		if (this.error.compareAndSet(null, throwable)) {_			shutdownFetcher()__		}_	};called,by,created,threads,to,pass,on,errors,only,the,first,thrown,error,is,set,once,set,the,shutdown,process,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;protected,void,stop,with,error,throwable,throwable,if,this,error,compare,and,set,null,throwable,shutdown,fetcher
KinesisDataFetcher -> @VisibleForTesting 	protected void emitWatermark();1542797087;Called periodically to emit a watermark. Checks all shards for the current event time_watermark, and possibly emits the next watermark.__<p>Shards that have not received an update for a certain interval are considered inactive so as_to not hold back the watermark indefinitely. When all shards are inactive, the subtask will be_marked as temporarily idle to not block downstream operators.;@VisibleForTesting_	protected void emitWatermark() {_		LOG.debug("Evaluating watermark for subtask {} time {}", indexOfThisConsumerSubtask, getCurrentTimeMillis())__		long potentialWatermark = Long.MAX_VALUE__		long idleTime =_			(shardIdleIntervalMillis > 0)_				? getCurrentTimeMillis() - shardIdleIntervalMillis_				: Long.MAX_VALUE___		for (Map.Entry<Integer, ShardWatermarkState> e : shardWatermarks.entrySet()) {_			_			Watermark w = e.getValue().periodicWatermarkAssigner.getCurrentWatermark()__			if (w != null && (e.getValue().lastUpdated >= idleTime || w.getTimestamp() > lastWatermark)) {_				potentialWatermark = Math.min(potentialWatermark, w.getTimestamp())__			}_		}__		_		if (potentialWatermark == Long.MAX_VALUE) {_			if (shardWatermarks.isEmpty() || shardIdleIntervalMillis > 0) {_				LOG.debug("No active shard for subtask {}, marking the source idle.",_					indexOfThisConsumerSubtask)__				_				sourceContext.markAsTemporarilyIdle()__			}_		} else if (potentialWatermark > lastWatermark) {_			LOG.debug("Emitting watermark {} from subtask {}",_				potentialWatermark,_				indexOfThisConsumerSubtask)__			sourceContext.emitWatermark(new Watermark(potentialWatermark))__			lastWatermark = potentialWatermark__		}_	};called,periodically,to,emit,a,watermark,checks,all,shards,for,the,current,event,time,watermark,and,possibly,emits,the,next,watermark,p,shards,that,have,not,received,an,update,for,a,certain,interval,are,considered,inactive,so,as,to,not,hold,back,the,watermark,indefinitely,when,all,shards,are,inactive,the,subtask,will,be,marked,as,temporarily,idle,to,not,block,downstream,operators;visible,for,testing,protected,void,emit,watermark,log,debug,evaluating,watermark,for,subtask,time,index,of,this,consumer,subtask,get,current,time,millis,long,potential,watermark,long,long,idle,time,shard,idle,interval,millis,0,get,current,time,millis,shard,idle,interval,millis,long,for,map,entry,integer,shard,watermark,state,e,shard,watermarks,entry,set,watermark,w,e,get,value,periodic,watermark,assigner,get,current,watermark,if,w,null,e,get,value,last,updated,idle,time,w,get,timestamp,last,watermark,potential,watermark,math,min,potential,watermark,w,get,timestamp,if,potential,watermark,long,if,shard,watermarks,is,empty,shard,idle,interval,millis,0,log,debug,no,active,shard,for,subtask,marking,the,source,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,else,if,potential,watermark,last,watermark,log,debug,emitting,watermark,from,subtask,potential,watermark,index,of,this,consumer,subtask,source,context,emit,watermark,new,watermark,potential,watermark,last,watermark,potential,watermark
KinesisDataFetcher -> @VisibleForTesting 	protected void emitWatermark();1545495597;Called periodically to emit a watermark. Checks all shards for the current event time_watermark, and possibly emits the next watermark.__<p>Shards that have not received an update for a certain interval are considered inactive so as_to not hold back the watermark indefinitely. When all shards are inactive, the subtask will be_marked as temporarily idle to not block downstream operators.;@VisibleForTesting_	protected void emitWatermark() {_		LOG.debug("Evaluating watermark for subtask {} time {}", indexOfThisConsumerSubtask, getCurrentTimeMillis())__		long potentialWatermark = Long.MAX_VALUE__		long idleTime =_			(shardIdleIntervalMillis > 0)_				? getCurrentTimeMillis() - shardIdleIntervalMillis_				: Long.MAX_VALUE___		for (Map.Entry<Integer, ShardWatermarkState> e : shardWatermarks.entrySet()) {_			_			Watermark w = e.getValue().periodicWatermarkAssigner.getCurrentWatermark()__			if (w != null && (e.getValue().lastUpdated >= idleTime || w.getTimestamp() > lastWatermark)) {_				potentialWatermark = Math.min(potentialWatermark, w.getTimestamp())__			}_		}__		_		if (potentialWatermark == Long.MAX_VALUE) {_			if (shardWatermarks.isEmpty() || shardIdleIntervalMillis > 0) {_				LOG.debug("No active shard for subtask {}, marking the source idle.",_					indexOfThisConsumerSubtask)__				_				sourceContext.markAsTemporarilyIdle()__			}_		} else if (potentialWatermark > lastWatermark) {_			LOG.debug("Emitting watermark {} from subtask {}",_				potentialWatermark,_				indexOfThisConsumerSubtask)__			sourceContext.emitWatermark(new Watermark(potentialWatermark))__			lastWatermark = potentialWatermark__		}_	};called,periodically,to,emit,a,watermark,checks,all,shards,for,the,current,event,time,watermark,and,possibly,emits,the,next,watermark,p,shards,that,have,not,received,an,update,for,a,certain,interval,are,considered,inactive,so,as,to,not,hold,back,the,watermark,indefinitely,when,all,shards,are,inactive,the,subtask,will,be,marked,as,temporarily,idle,to,not,block,downstream,operators;visible,for,testing,protected,void,emit,watermark,log,debug,evaluating,watermark,for,subtask,time,index,of,this,consumer,subtask,get,current,time,millis,long,potential,watermark,long,long,idle,time,shard,idle,interval,millis,0,get,current,time,millis,shard,idle,interval,millis,long,for,map,entry,integer,shard,watermark,state,e,shard,watermarks,entry,set,watermark,w,e,get,value,periodic,watermark,assigner,get,current,watermark,if,w,null,e,get,value,last,updated,idle,time,w,get,timestamp,last,watermark,potential,watermark,math,min,potential,watermark,w,get,timestamp,if,potential,watermark,long,if,shard,watermarks,is,empty,shard,idle,interval,millis,0,log,debug,no,active,shard,for,subtask,marking,the,source,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,else,if,potential,watermark,last,watermark,log,debug,emitting,watermark,from,subtask,potential,watermark,index,of,this,consumer,subtask,source,context,emit,watermark,new,watermark,potential,watermark,last,watermark,potential,watermark
KinesisDataFetcher -> @VisibleForTesting 	protected void emitWatermark();1550197938;Called periodically to emit a watermark. Checks all shards for the current event time_watermark, and possibly emits the next watermark.__<p>Shards that have not received an update for a certain interval are considered inactive so as_to not hold back the watermark indefinitely. When all shards are inactive, the subtask will be_marked as temporarily idle to not block downstream operators.;@VisibleForTesting_	protected void emitWatermark() {_		LOG.debug("Evaluating watermark for subtask {} time {}", indexOfThisConsumerSubtask, getCurrentTimeMillis())__		long potentialWatermark = Long.MAX_VALUE__		long idleTime =_			(shardIdleIntervalMillis > 0)_				? getCurrentTimeMillis() - shardIdleIntervalMillis_				: Long.MAX_VALUE___		for (Map.Entry<Integer, ShardWatermarkState> e : shardWatermarks.entrySet()) {_			_			Watermark w = e.getValue().periodicWatermarkAssigner.getCurrentWatermark()__			if (w != null && (e.getValue().lastUpdated >= idleTime || w.getTimestamp() > lastWatermark)) {_				potentialWatermark = Math.min(potentialWatermark, w.getTimestamp())__			}_		}__		_		if (potentialWatermark == Long.MAX_VALUE) {_			if (shardWatermarks.isEmpty() || shardIdleIntervalMillis > 0) {_				LOG.debug("No active shard for subtask {}, marking the source idle.",_					indexOfThisConsumerSubtask)__				_				sourceContext.markAsTemporarilyIdle()__			}_		} else if (potentialWatermark > lastWatermark) {_			LOG.debug("Emitting watermark {} from subtask {}",_				potentialWatermark,_				indexOfThisConsumerSubtask)__			sourceContext.emitWatermark(new Watermark(potentialWatermark))__			lastWatermark = potentialWatermark__		}_	};called,periodically,to,emit,a,watermark,checks,all,shards,for,the,current,event,time,watermark,and,possibly,emits,the,next,watermark,p,shards,that,have,not,received,an,update,for,a,certain,interval,are,considered,inactive,so,as,to,not,hold,back,the,watermark,indefinitely,when,all,shards,are,inactive,the,subtask,will,be,marked,as,temporarily,idle,to,not,block,downstream,operators;visible,for,testing,protected,void,emit,watermark,log,debug,evaluating,watermark,for,subtask,time,index,of,this,consumer,subtask,get,current,time,millis,long,potential,watermark,long,long,idle,time,shard,idle,interval,millis,0,get,current,time,millis,shard,idle,interval,millis,long,for,map,entry,integer,shard,watermark,state,e,shard,watermarks,entry,set,watermark,w,e,get,value,periodic,watermark,assigner,get,current,watermark,if,w,null,e,get,value,last,updated,idle,time,w,get,timestamp,last,watermark,potential,watermark,math,min,potential,watermark,w,get,timestamp,if,potential,watermark,long,if,shard,watermarks,is,empty,shard,idle,interval,millis,0,log,debug,no,active,shard,for,subtask,marking,the,source,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle,else,if,potential,watermark,last,watermark,log,debug,emitting,watermark,from,subtask,potential,watermark,index,of,this,consumer,subtask,source,context,emit,watermark,new,watermark,potential,watermark,last,watermark,potential,watermark
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1480685315;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.decrementAndGet()__				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getKinesisStreamShard())__			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,this,number,of,active,shards,decrement,and,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,kinesis,stream,shard
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1490934828;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getKinesisStreamShard())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,kinesis,stream,shard,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1492730110;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getKinesisStreamShard())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,kinesis,stream,shard,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1494145732;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getKinesisStreamShard())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,kinesis,stream,shard,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1494149584;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getKinesisStreamShard())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,kinesis,stream,shard,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1495787238;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1495787239;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1495923079;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1515757408;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1515757408;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1515757408;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1515757408;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)___		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1515757408;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)___		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1517943538;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)___		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1517943538;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)___		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1517943538;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)___		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1517943538;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)___		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1518718884;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)___		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1519386499;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)___		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1533129233;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)___		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1534479217;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MAX_RECORDS_PER_FETCH, shardMetrics::getMaxNumberOfRecordsPerFetch)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_AGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfAggregatedRecords)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_DEAGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfDeaggregatedRecords)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.AVG_RECORD_SIZE_BYTES, shardMetrics::getAverageRecordSizeBytes)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.BYTES_PER_READ, shardMetrics::getBytesPerRead)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.RUNTIME_LOOP_NANOS, shardMetrics::getRunLoopTimeNanos)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.LOOP_FREQUENCY_HZ, shardMetrics::getLoopFrequencyHz)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.SLEEP_TIME_MILLIS, shardMetrics::getSleepTimeMillis)__		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,max,number,of,records,per,fetch,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,number,of,aggregated,records,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,number,of,deaggregated,records,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,average,record,size,bytes,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,bytes,per,read,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,run,loop,time,nanos,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,loop,frequency,hz,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,sleep,time,millis,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1542797087;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MAX_RECORDS_PER_FETCH, shardMetrics::getMaxNumberOfRecordsPerFetch)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_AGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfAggregatedRecords)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_DEAGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfDeaggregatedRecords)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.AVG_RECORD_SIZE_BYTES, shardMetrics::getAverageRecordSizeBytes)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.BYTES_PER_READ, shardMetrics::getBytesPerRead)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.RUNTIME_LOOP_NANOS, shardMetrics::getRunLoopTimeNanos)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.LOOP_FREQUENCY_HZ, shardMetrics::getLoopFrequencyHz)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.SLEEP_TIME_MILLIS, shardMetrics::getSleepTimeMillis)__		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,max,number,of,records,per,fetch,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,number,of,aggregated,records,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,number,of,deaggregated,records,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,average,record,size,bytes,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,bytes,per,read,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,run,loop,time,nanos,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,loop,frequency,hz,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,sleep,time,millis,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1545495597;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MAX_RECORDS_PER_FETCH, shardMetrics::getMaxNumberOfRecordsPerFetch)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_AGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfAggregatedRecords)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_DEAGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfDeaggregatedRecords)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.AVG_RECORD_SIZE_BYTES, shardMetrics::getAverageRecordSizeBytes)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.BYTES_PER_READ, shardMetrics::getBytesPerRead)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.RUNTIME_LOOP_NANOS, shardMetrics::getRunLoopTimeNanos)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.LOOP_FREQUENCY_HZ, shardMetrics::getLoopFrequencyHz)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.SLEEP_TIME_MILLIS, shardMetrics::getSleepTimeMillis)__		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,max,number,of,records,per,fetch,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,number,of,aggregated,records,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,number,of,deaggregated,records,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,average,record,size,bytes,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,bytes,per,read,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,run,loop,time,nanos,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,loop,frequency,hz,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,sleep,time,millis,return,shard,metrics
KinesisDataFetcher -> private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState);1550197938;Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.__@return a {@link ShardMetricsReporter} that can be used to update metric values;private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {_		ShardMetricsReporter shardMetrics = new ShardMetricsReporter()___		MetricGroup streamShardMetricGroup = metricGroup_			.addGroup(_				KinesisConsumerMetricConstants.STREAM_METRICS_GROUP,_				shardState.getStreamShardHandle().getStreamName())_			.addGroup(_				KinesisConsumerMetricConstants.SHARD_METRICS_GROUP,_				shardState.getStreamShardHandle().getShard().getShardId())___		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MAX_RECORDS_PER_FETCH, shardMetrics::getMaxNumberOfRecordsPerFetch)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_AGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfAggregatedRecords)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_DEAGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfDeaggregatedRecords)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.AVG_RECORD_SIZE_BYTES, shardMetrics::getAverageRecordSizeBytes)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.BYTES_PER_READ, shardMetrics::getBytesPerRead)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.RUNTIME_LOOP_NANOS, shardMetrics::getRunLoopTimeNanos)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.LOOP_FREQUENCY_HZ, shardMetrics::getLoopFrequencyHz)__		streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.SLEEP_TIME_MILLIS, shardMetrics::getSleepTimeMillis)__		return shardMetrics__	};registers,a,metric,group,associated,with,the,shard,id,of,the,provided,link,kinesis,stream,shard,state,shard,state,return,a,link,shard,metrics,reporter,that,can,be,used,to,update,metric,values;private,static,shard,metrics,reporter,register,shard,metrics,metric,group,metric,group,kinesis,stream,shard,state,shard,state,shard,metrics,reporter,shard,metrics,new,shard,metrics,reporter,metric,group,stream,shard,metric,group,metric,group,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,stream,name,add,group,kinesis,consumer,metric,constants,shard,state,get,stream,shard,handle,get,shard,get,shard,id,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,millis,behind,latest,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,max,number,of,records,per,fetch,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,number,of,aggregated,records,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,number,of,deaggregated,records,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,average,record,size,bytes,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,bytes,per,read,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,run,loop,time,nanos,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,loop,frequency,hz,stream,shard,metric,group,gauge,kinesis,consumer,metric,constants,shard,metrics,get,sleep,time,millis,return,shard,metrics
KinesisDataFetcher -> public List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException;1494145732;A utility function that does the following:__1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException {__		List<KinesisStreamShard> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<KinesisStreamShard> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (KinesisStreamShard newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,kinesis,stream,shard,discover,new,shards,to,subscribe,throws,interrupted,exception,list,kinesis,stream,shard,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,kinesis,stream,shard,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,kinesis,stream,shard,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> public List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException;1494149584;A utility function that does the following:__1. Find new shards for each stream that we haven't seen before_2. For each new shard, determine whether this consumer subtask should subscribe to them__if yes, it is added to the returned list of shards_3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards_that we have already seen before the next time this function is called;public List<KinesisStreamShard> discoverNewShardsToSubscribe() throws InterruptedException {__		List<KinesisStreamShard> newShardsToSubscribe = new LinkedList<>()___		GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds)__		if (shardListResult.hasRetrievedShards()) {_			Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards()___			for (String stream : streamsWithNewShards) {_				List<KinesisStreamShard> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream)__				for (KinesisStreamShard newShard : newShardsOfStream) {_					if (isThisSubtaskShouldSubscribeTo(newShard, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {_						newShardsToSubscribe.add(newShard)__					}_				}__				advanceLastDiscoveredShardOfStream(_					stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId())__			}_		}__		return newShardsToSubscribe__	};a,utility,function,that,does,the,following,1,find,new,shards,for,each,stream,that,we,haven,t,seen,before,2,for,each,new,shard,determine,whether,this,consumer,subtask,should,subscribe,to,them,if,yes,it,is,added,to,the,returned,list,of,shards,3,update,the,subscribed,streams,to,last,discovered,shard,ids,state,so,that,we,won,t,get,shards,that,we,have,already,seen,before,the,next,time,this,function,is,called;public,list,kinesis,stream,shard,discover,new,shards,to,subscribe,throws,interrupted,exception,list,kinesis,stream,shard,new,shards,to,subscribe,new,linked,list,get,shard,list,result,shard,list,result,kinesis,get,shard,list,subscribed,streams,to,last,discovered,shard,ids,if,shard,list,result,has,retrieved,shards,set,string,streams,with,new,shards,shard,list,result,get,streams,with,retrieved,shards,for,string,stream,streams,with,new,shards,list,kinesis,stream,shard,new,shards,of,stream,shard,list,result,get,retrieved,shard,list,of,stream,stream,for,kinesis,stream,shard,new,shard,new,shards,of,stream,if,is,this,subtask,should,subscribe,to,new,shard,total,number,of,consumer,subtasks,index,of,this,consumer,subtask,new,shards,to,subscribe,add,new,shard,advance,last,discovered,shard,of,stream,stream,shard,list,result,get,last,seen,shard,of,stream,stream,get,shard,get,shard,id,return,new,shards,to,subscribe
KinesisDataFetcher -> private static boolean isThisSubtaskShouldSubscribeTo(KinesisStreamShard shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1480685315;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;private static boolean isThisSubtaskShouldSubscribeTo(KinesisStreamShard shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;private,static,boolean,is,this,subtask,should,subscribe,to,kinesis,stream,shard,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> private static boolean isThisSubtaskShouldSubscribeTo(KinesisStreamShard shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1490934828;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;private static boolean isThisSubtaskShouldSubscribeTo(KinesisStreamShard shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;private,static,boolean,is,this,subtask,should,subscribe,to,kinesis,stream,shard,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> private static boolean isThisSubtaskShouldSubscribeTo(KinesisStreamShard shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1492730110;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;private static boolean isThisSubtaskShouldSubscribeTo(KinesisStreamShard shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;private,static,boolean,is,this,subtask,should,subscribe,to,kinesis,stream,shard,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> private static boolean isThisSubtaskShouldSubscribeTo(KinesisStreamShard shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1494145732;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;private static boolean isThisSubtaskShouldSubscribeTo(KinesisStreamShard shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;private,static,boolean,is,this,subtask,should,subscribe,to,kinesis,stream,shard,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> protected boolean shouldAdvanceLastDiscoveredShardId(String shardId, String lastSeenShardIdOfStream);1545495597;Given lastSeenShardId, check if last discovered shardId should be advanced.;protected boolean shouldAdvanceLastDiscoveredShardId(String shardId, String lastSeenShardIdOfStream) {_		return (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0)__	};given,last,seen,shard,id,check,if,last,discovered,shard,id,should,be,advanced;protected,boolean,should,advance,last,discovered,shard,id,string,shard,id,string,last,seen,shard,id,of,stream,return,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0
KinesisDataFetcher -> protected boolean shouldAdvanceLastDiscoveredShardId(String shardId, String lastSeenShardIdOfStream);1550197938;Given lastSeenShardId, check if last discovered shardId should be advanced.;protected boolean shouldAdvanceLastDiscoveredShardId(String shardId, String lastSeenShardIdOfStream) {_		return (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0)__	};given,last,seen,shard,id,check,if,last,discovered,shard,id,should,be,advanced;protected,boolean,should,advance,last,discovered,shard,id,string,shard,id,string,last,seen,shard,id,of,stream,return,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(int shardHash, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1518718884;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shardHash hash code for the shard_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(int shardHash,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shardHash % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,hash,hash,code,for,the,shard,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,int,shard,hash,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(int shardHash, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1519386499;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shardHash hash code for the shard_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(int shardHash,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shardHash % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,hash,hash,code,for,the,shard,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,int,shard,hash,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(int shardHash, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1533129233;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shardHash hash code for the shard_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(int shardHash,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shardHash % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,hash,hash,code,for,the,shard,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,int,shard,hash,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(int shardHash, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1534479217;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shardHash hash code for the shard_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(int shardHash,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shardHash % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,hash,hash,code,for,the,shard,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,int,shard,hash,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(int shardHash, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1542797087;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shardHash hash code for the shard_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(int shardHash,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shardHash % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,hash,hash,code,for,the,shard,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,int,shard,hash,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(int shardHash, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1545495597;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shardHash hash code for the shard_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(int shardHash,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shardHash % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,hash,hash,code,for,the,shard,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,int,shard,hash,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(int shardHash, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1550197938;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shardHash hash code for the shard_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(int shardHash,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shardHash % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,hash,hash,code,for,the,shard,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,int,shard,hash,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1480685315;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (KinesisStreamShard.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,kinesis,stream,shard,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1490934828;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (KinesisStreamShard.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,kinesis,stream,shard,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1492730110;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (KinesisStreamShard.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,kinesis,stream,shard,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1494145732;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (KinesisStreamShard.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,kinesis,stream,shard,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1494149584;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (KinesisStreamShard.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,kinesis,stream,shard,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1495787238;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1495787239;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1495923079;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1515757408;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1515757408;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1515757408;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1517943538;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1517943538;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1517943538;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1517943538;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1518718884;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1519386499;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1533129233;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1534479217;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1542797087;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,stream,shard,handle,compare,shard,ids,shard,id,last,seen,shard,id,of,stream,0,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1545495597;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (shouldAdvanceLastDiscoveredShardId(shardId, lastSeenShardIdOfStream)) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,should,advance,last,discovered,shard,id,shard,id,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void advanceLastDiscoveredShardOfStream(String stream, String shardId);1550197938;Updates the last discovered shard of a subscribed stream_ only updates if the update is valid.;public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {_		String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream)___		_		_		if (lastSeenShardIdOfStream == null) {_			_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		} else if (shouldAdvanceLastDiscoveredShardId(shardId, lastSeenShardIdOfStream)) {_			this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId)__		}_	};updates,the,last,discovered,shard,of,a,subscribed,stream,only,updates,if,the,update,is,valid;public,void,advance,last,discovered,shard,of,stream,string,stream,string,shard,id,string,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,get,stream,if,last,seen,shard,id,of,stream,null,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id,else,if,should,advance,last,discovered,shard,id,shard,id,last,seen,shard,id,of,stream,this,subscribed,streams,to,last,discovered,shard,ids,put,stream,shard,id
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1480685315;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown;public void awaitTermination() throws InterruptedException {_		while(!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1490934828;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown;public void awaitTermination() throws InterruptedException {_		while(!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1492730110;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown;public void awaitTermination() throws InterruptedException {_		while(!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1494145732;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown;public void awaitTermination() throws InterruptedException {_		while(!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1494149584;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown;public void awaitTermination() throws InterruptedException {_		while(!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1495787238;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown;public void awaitTermination() throws InterruptedException {_		while(!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1495787239;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown;public void awaitTermination() throws InterruptedException {_		while(!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1495923079;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1515757408;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1515757408;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1515757408;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1517943538;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1517943538;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1517943538;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1517943538;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1518718884;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1519386499;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1533129233;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1534479217;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1542797087;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1545495597;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.isTerminated()) {_			Thread.sleep(50)__		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,is,terminated,thread,sleep,50
KinesisDataFetcher -> public void awaitTermination() throws InterruptedException;1550197938;After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.;public void awaitTermination() throws InterruptedException {_		while (!shardConsumersExecutor.awaitTermination(1, TimeUnit.MINUTES)) {_			_		}_	};after,calling,link,kinesis,data,fetcher,shutdown,fetcher,this,can,be,called,to,await,the,fetcher,shutdown;public,void,await,termination,throws,interrupted,exception,while,shard,consumers,executor,await,termination,1,time,unit,minutes
KinesisDataFetcher -> public void shutdownFetcher();1480685315;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false__		mainThread.interrupt()_ __		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1490934828;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false__		mainThread.interrupt()_ __		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1492730110;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1494145732;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1494149584;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1495787238;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1495787239;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1495923079;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1515757408;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1515757408;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1515757408;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1517943538;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1517943538;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1517943538;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1517943538;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1518718884;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1519386499;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1533129233;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1534479217;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1542797087;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1545495597;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public void shutdownFetcher();1550197938;Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete._Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.;public void shutdownFetcher() {_		running = false___		if (mainThread != null) {_			mainThread.interrupt()_ _		}__		if (LOG.isInfoEnabled()) {_			LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask)__		}_		shardConsumersExecutor.shutdownNow()__	};starts,shutting,down,the,fetcher,must,be,called,to,allow,link,kinesis,data,fetcher,run,fetcher,to,complete,once,called,the,shutdown,procedure,will,be,executed,and,all,shard,consuming,threads,will,be,interrupted;public,void,shutdown,fetcher,running,false,if,main,thread,null,main,thread,interrupt,if,log,is,info,enabled,log,info,shutting,down,the,shard,consumer,threads,of,subtask,index,of,this,consumer,subtask,shard,consumers,executor,shutdown,now
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1495787239;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1495923079;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1515757408;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1515757408;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1515757408;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1517943538;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1517943538;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1517943538;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1517943538;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1518718884;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1519386499;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1533129233;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1534479217;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1542797087;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1545495597;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public HashMap<StreamShardMetadata, SequenceNumber> snapshotState();1550197938;Creates a snapshot of the current last processed sequence numbers of each subscribed shard.__@return state snapshot;public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {_		_		assert Thread.holdsLock(checkpointLock)___		HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>()__		for (KinesisStreamShardState shardWithState : subscribedShardsState) {_			stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum())__		}_		return stateSnapshot__	};creates,a,snapshot,of,the,current,last,processed,sequence,numbers,of,each,subscribed,shard,return,state,snapshot;public,hash,map,stream,shard,metadata,sequence,number,snapshot,state,assert,thread,holds,lock,checkpoint,lock,hash,map,stream,shard,metadata,sequence,number,state,snapshot,new,hash,map,for,kinesis,stream,shard,state,shard,with,state,subscribed,shards,state,state,snapshot,put,shard,with,state,get,stream,shard,metadata,shard,with,state,get,last,processed,sequence,num,return,state,snapshot
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1495787238;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1495787239;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1495923079;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1515757408;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1515757408;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1515757408;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1517943538;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1517943538;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1517943538;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard, 														int totalNumberOfConsumerSubtasks, 														int indexOfThisConsumerSubtask);1517943538;Utility function to determine whether a shard should be subscribed by this consumer subtask.__@param shard the shard to determine_@param totalNumberOfConsumerSubtasks total number of consumer subtasks_@param indexOfThisConsumerSubtask index of this consumer subtask;public static boolean isThisSubtaskShouldSubscribeTo(StreamShardHandle shard,_														int totalNumberOfConsumerSubtasks,_														int indexOfThisConsumerSubtask) {_		return (Math.abs(shard.hashCode() % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask__	};utility,function,to,determine,whether,a,shard,should,be,subscribed,by,this,consumer,subtask,param,shard,the,shard,to,determine,param,total,number,of,consumer,subtasks,total,number,of,consumer,subtasks,param,index,of,this,consumer,subtask,index,of,this,consumer,subtask;public,static,boolean,is,this,subtask,should,subscribe,to,stream,shard,handle,shard,int,total,number,of,consumer,subtasks,int,index,of,this,consumer,subtask,return,math,abs,shard,hash,code,total,number,of,consumer,subtasks,index,of,this,consumer,subtask
KinesisDataFetcher -> protected ShardConsumer createShardConsumer( 		Integer subscribedShardStateIndex, 		StreamShardHandle subscribedShard, 		SequenceNumber lastSequenceNum, 		ShardMetricsReporter shardMetricsReporter);1533129233;Create a new shard consumer._Override this method to customize shard consumer behavior in subclasses._@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to_@return shard consumer;protected ShardConsumer createShardConsumer(_		Integer subscribedShardStateIndex,_		StreamShardHandle subscribedShard,_		SequenceNumber lastSequenceNum,_		ShardMetricsReporter shardMetricsReporter) {_		return new ShardConsumer<>(_			this,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			this.kinesisProxyFactory.create(configProps),_			shardMetricsReporter)__	};create,a,new,shard,consumer,override,this,method,to,customize,shard,consumer,behavior,in,subclasses,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to,return,shard,consumer;protected,shard,consumer,create,shard,consumer,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,return,new,shard,consumer,this,subscribed,shard,state,index,subscribed,shard,last,sequence,num,this,kinesis,proxy,factory,create,config,props,shard,metrics,reporter
KinesisDataFetcher -> protected ShardConsumer createShardConsumer( 		Integer subscribedShardStateIndex, 		StreamShardHandle subscribedShard, 		SequenceNumber lastSequenceNum, 		ShardMetricsReporter shardMetricsReporter);1534479217;Create a new shard consumer._Override this method to customize shard consumer behavior in subclasses._@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to_@return shard consumer;protected ShardConsumer createShardConsumer(_		Integer subscribedShardStateIndex,_		StreamShardHandle subscribedShard,_		SequenceNumber lastSequenceNum,_		ShardMetricsReporter shardMetricsReporter) {_		return new ShardConsumer<>(_			this,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			this.kinesisProxyFactory.create(configProps),_			shardMetricsReporter)__	};create,a,new,shard,consumer,override,this,method,to,customize,shard,consumer,behavior,in,subclasses,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to,return,shard,consumer;protected,shard,consumer,create,shard,consumer,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,return,new,shard,consumer,this,subscribed,shard,state,index,subscribed,shard,last,sequence,num,this,kinesis,proxy,factory,create,config,props,shard,metrics,reporter
KinesisDataFetcher -> protected ShardConsumer createShardConsumer( 		Integer subscribedShardStateIndex, 		StreamShardHandle subscribedShard, 		SequenceNumber lastSequenceNum, 		ShardMetricsReporter shardMetricsReporter);1542797087;Create a new shard consumer._Override this method to customize shard consumer behavior in subclasses._@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to_@return shard consumer;protected ShardConsumer createShardConsumer(_		Integer subscribedShardStateIndex,_		StreamShardHandle subscribedShard,_		SequenceNumber lastSequenceNum,_		ShardMetricsReporter shardMetricsReporter) {_		return new ShardConsumer<>(_			this,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			this.kinesisProxyFactory.create(configProps),_			shardMetricsReporter)__	};create,a,new,shard,consumer,override,this,method,to,customize,shard,consumer,behavior,in,subclasses,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to,return,shard,consumer;protected,shard,consumer,create,shard,consumer,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,return,new,shard,consumer,this,subscribed,shard,state,index,subscribed,shard,last,sequence,num,this,kinesis,proxy,factory,create,config,props,shard,metrics,reporter
KinesisDataFetcher -> protected ShardConsumer createShardConsumer( 		Integer subscribedShardStateIndex, 		StreamShardHandle subscribedShard, 		SequenceNumber lastSequenceNum, 		ShardMetricsReporter shardMetricsReporter);1545495597;Create a new shard consumer._Override this method to customize shard consumer behavior in subclasses._@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to_@return shard consumer;protected ShardConsumer createShardConsumer(_		Integer subscribedShardStateIndex,_		StreamShardHandle subscribedShard,_		SequenceNumber lastSequenceNum,_		ShardMetricsReporter shardMetricsReporter) {_		return new ShardConsumer<>(_			this,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			this.kinesisProxyFactory.create(configProps),_			shardMetricsReporter)__	};create,a,new,shard,consumer,override,this,method,to,customize,shard,consumer,behavior,in,subclasses,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to,return,shard,consumer;protected,shard,consumer,create,shard,consumer,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,return,new,shard,consumer,this,subscribed,shard,state,index,subscribed,shard,last,sequence,num,this,kinesis,proxy,factory,create,config,props,shard,metrics,reporter
KinesisDataFetcher -> protected ShardConsumer createShardConsumer( 		Integer subscribedShardStateIndex, 		StreamShardHandle subscribedShard, 		SequenceNumber lastSequenceNum, 		ShardMetricsReporter shardMetricsReporter);1550197938;Create a new shard consumer._Override this method to customize shard consumer behavior in subclasses._@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to_@return shard consumer;protected ShardConsumer createShardConsumer(_		Integer subscribedShardStateIndex,_		StreamShardHandle subscribedShard,_		SequenceNumber lastSequenceNum,_		ShardMetricsReporter shardMetricsReporter) {_		return new ShardConsumer<>(_			this,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			this.kinesisProxyFactory.create(configProps),_			shardMetricsReporter)__	};create,a,new,shard,consumer,override,this,method,to,customize,shard,consumer,behavior,in,subclasses,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to,return,shard,consumer;protected,shard,consumer,create,shard,consumer,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,return,new,shard,consumer,this,subscribed,shard,state,index,subscribed,shard,last,sequence,num,this,kinesis,proxy,factory,create,config,props,shard,metrics,reporter
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1517943538;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1517943538;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1517943538;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1517943538;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1518718884;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1519386499;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1533129233;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1534479217;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1542797087;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1545495597;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber);1550197938;Update the shard to last processed sequence number state._This method is called by {@link ShardConsumer}s.__@param shardStateIndex index of the shard to update in subscribedShardsState__this index should be the returned value from_{@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called_when the shard state was registered._@param lastSequenceNumber the last sequence number value to update;protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {_		synchronized (checkpointLock) {_			subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber)___			_			_			if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				LOG.info("Subtask {} has reached the end of subscribed shard: {}",_					indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle())___				_				_				_				_				if (this.numberOfActiveShards.decrementAndGet() == 0) {_					LOG.info("Subtask {} has reached the end of all currently subscribed shards_ marking the subtask as temporarily idle ...",_						indexOfThisConsumerSubtask)___					sourceContext.markAsTemporarilyIdle()__				}_			}_		}_	};update,the,shard,to,last,processed,sequence,number,state,this,method,is,called,by,link,shard,consumer,s,param,shard,state,index,index,of,the,shard,to,update,in,subscribed,shards,state,this,index,should,be,the,returned,value,from,link,kinesis,data,fetcher,register,new,subscribed,shard,state,kinesis,stream,shard,state,called,when,the,shard,state,was,registered,param,last,sequence,number,the,last,sequence,number,value,to,update;protected,final,void,update,state,int,shard,state,index,sequence,number,last,sequence,number,synchronized,checkpoint,lock,subscribed,shards,state,get,shard,state,index,set,last,processed,sequence,num,last,sequence,number,if,last,sequence,number,equals,sentinel,sequence,number,get,log,info,subtask,has,reached,the,end,of,subscribed,shard,index,of,this,consumer,subtask,subscribed,shards,state,get,shard,state,index,get,stream,shard,handle,if,this,number,of,active,shards,decrement,and,get,0,log,info,subtask,has,reached,the,end,of,all,currently,subscribed,shards,marking,the,subtask,as,temporarily,idle,index,of,this,consumer,subtask,source,context,mark,as,temporarily,idle
KinesisDataFetcher -> @VisibleForTesting 	protected long getCurrentTimeMillis();1542797087;Return the current system time. Allow tests to override this to simulate progress for watermark_logic.__@return current processing time;@VisibleForTesting_	protected long getCurrentTimeMillis() {_		return System.currentTimeMillis()__	};return,the,current,system,time,allow,tests,to,override,this,to,simulate,progress,for,watermark,logic,return,current,processing,time;visible,for,testing,protected,long,get,current,time,millis,return,system,current,time,millis
KinesisDataFetcher -> @VisibleForTesting 	protected long getCurrentTimeMillis();1545495597;Return the current system time. Allow tests to override this to simulate progress for watermark_logic.__@return current processing time;@VisibleForTesting_	protected long getCurrentTimeMillis() {_		return System.currentTimeMillis()__	};return,the,current,system,time,allow,tests,to,override,this,to,simulate,progress,for,watermark,logic,return,current,processing,time;visible,for,testing,protected,long,get,current,time,millis,return,system,current,time,millis
KinesisDataFetcher -> @VisibleForTesting 	protected long getCurrentTimeMillis();1550197938;Return the current system time. Allow tests to override this to simulate progress for watermark_logic.__@return current processing time;@VisibleForTesting_	protected long getCurrentTimeMillis() {_		return System.currentTimeMillis()__	};return,the,current,system,time,allow,tests,to,override,this,to,simulate,progress,for,watermark,logic,return,current,processing,time;visible,for,testing,protected,long,get,current,time,millis,return,system,current,time,millis
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1480685315;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size()-1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1490934828;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size()-1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1492730110;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size()-1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1494145732;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size()-1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1494149584;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size()-1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1495787238;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size()-1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1495787239;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size()-1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1495923079;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1515757408;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1515757408;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1515757408;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1517943538;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1517943538;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1517943538;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1517943538;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1518718884;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1519386499;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1533129233;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1534479217;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			return subscribedShardsState.size() - 1__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,return,subscribed,shards,state,size,1
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1542797087;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			int shardStateIndex = subscribedShardsState.size() - 1___			_			ShardWatermarkState sws = shardWatermarks.get(shardStateIndex)__			if (sws == null) {_				sws = new ShardWatermarkState()__				try {_					sws.periodicWatermarkAssigner = InstantiationUtil.clone(periodicWatermarkAssigner)__				} catch (Exception e) {_					throw new RuntimeException("Failed to instantiate new WatermarkAssigner", e)__				}_				sws.lastUpdated = getCurrentTimeMillis()__				sws.lastRecordTimestamp = Long.MIN_VALUE__				shardWatermarks.put(shardStateIndex, sws)__			}__			return shardStateIndex__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,int,shard,state,index,subscribed,shards,state,size,1,shard,watermark,state,sws,shard,watermarks,get,shard,state,index,if,sws,null,sws,new,shard,watermark,state,try,sws,periodic,watermark,assigner,instantiation,util,clone,periodic,watermark,assigner,catch,exception,e,throw,new,runtime,exception,failed,to,instantiate,new,watermark,assigner,e,sws,last,updated,get,current,time,millis,sws,last,record,timestamp,long,shard,watermarks,put,shard,state,index,sws,return,shard,state,index
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1545495597;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			int shardStateIndex = subscribedShardsState.size() - 1___			_			ShardWatermarkState sws = shardWatermarks.get(shardStateIndex)__			if (sws == null) {_				sws = new ShardWatermarkState()__				try {_					sws.periodicWatermarkAssigner = InstantiationUtil.clone(periodicWatermarkAssigner)__				} catch (Exception e) {_					throw new RuntimeException("Failed to instantiate new WatermarkAssigner", e)__				}_				sws.lastUpdated = getCurrentTimeMillis()__				sws.lastRecordTimestamp = Long.MIN_VALUE__				shardWatermarks.put(shardStateIndex, sws)__			}__			return shardStateIndex__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,int,shard,state,index,subscribed,shards,state,size,1,shard,watermark,state,sws,shard,watermarks,get,shard,state,index,if,sws,null,sws,new,shard,watermark,state,try,sws,periodic,watermark,assigner,instantiation,util,clone,periodic,watermark,assigner,catch,exception,e,throw,new,runtime,exception,failed,to,instantiate,new,watermark,assigner,e,sws,last,updated,get,current,time,millis,sws,last,record,timestamp,long,shard,watermarks,put,shard,state,index,sws,return,shard,state,index
KinesisDataFetcher -> public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState);1550197938;Register a new subscribed shard state.__@param newSubscribedShardState the new shard state that this fetcher is to be subscribed to;public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {_		synchronized (checkpointLock) {_			subscribedShardsState.add(newSubscribedShardState)___			_			_			_			if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_				this.numberOfActiveShards.incrementAndGet()__			}__			int shardStateIndex = subscribedShardsState.size() - 1___			_			ShardWatermarkState sws = shardWatermarks.get(shardStateIndex)__			if (sws == null) {_				sws = new ShardWatermarkState()__				try {_					sws.periodicWatermarkAssigner = InstantiationUtil.clone(periodicWatermarkAssigner)__				} catch (Exception e) {_					throw new RuntimeException("Failed to instantiate new WatermarkAssigner", e)__				}_				sws.lastUpdated = getCurrentTimeMillis()__				sws.lastRecordTimestamp = Long.MIN_VALUE__				shardWatermarks.put(shardStateIndex, sws)__			}__			return shardStateIndex__		}_	};register,a,new,subscribed,shard,state,param,new,subscribed,shard,state,the,new,shard,state,that,this,fetcher,is,to,be,subscribed,to;public,int,register,new,subscribed,shard,state,kinesis,stream,shard,state,new,subscribed,shard,state,synchronized,checkpoint,lock,subscribed,shards,state,add,new,subscribed,shard,state,if,new,subscribed,shard,state,get,last,processed,sequence,num,equals,sentinel,sequence,number,get,this,number,of,active,shards,increment,and,get,int,shard,state,index,subscribed,shards,state,size,1,shard,watermark,state,sws,shard,watermarks,get,shard,state,index,if,sws,null,sws,new,shard,watermark,state,try,sws,periodic,watermark,assigner,instantiation,util,clone,periodic,watermark,assigner,catch,exception,e,throw,new,runtime,exception,failed,to,instantiate,new,watermark,assigner,e,sws,last,updated,get,current,time,millis,sws,last,record,timestamp,long,shard,watermarks,put,shard,state,index,sws,return,shard,state,index
