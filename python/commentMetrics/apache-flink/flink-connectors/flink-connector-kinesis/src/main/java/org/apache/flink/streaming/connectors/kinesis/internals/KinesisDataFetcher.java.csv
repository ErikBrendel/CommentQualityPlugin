commented;modifiers;parameterAmount;loc;comment;code
false;;1;1;;KinesisProxyInterface create(Properties configProps).
true;protected;4;13;/**  * Create a new shard consumer.  * Override this method to customize shard consumer behavior in subclasses.  * @param subscribedShardStateIndex the state index of the shard this consumer is subscribed to  * @param subscribedShard the shard this consumer is subscribed to  * @param lastSequenceNum the sequence number in the shard to start consuming  * @param shardMetricsReporter the reporter to report metrics to  * @return shard consumer  */ ;/**  * Create a new shard consumer.  * Override this method to customize shard consumer behavior in subclasses.  * @param subscribedShardStateIndex the state index of the shard this consumer is subscribed to  * @param subscribedShard the shard this consumer is subscribed to  * @param lastSequenceNum the sequence number in the shard to start consuming  * @param shardMetricsReporter the reporter to report metrics to  * @return shard consumer  */ protected ShardConsumer createShardConsumer(Integer subscribedShardStateIndex, StreamShardHandle subscribedShard, SequenceNumber lastSequenceNum, ShardMetricsReporter shardMetricsReporter) {     return new ShardConsumer<>(this, subscribedShardStateIndex, subscribedShard, lastSequenceNum, this.kinesisProxyFactory.create(configProps), shardMetricsReporter). }
true;public;0;147;/**  * Starts the fetcher. After starting the fetcher, it can only  * be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.  *  * @throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.  */ ;/**  * Starts the fetcher. After starting the fetcher, it can only  * be stopped by calling {@link KinesisDataFetcher#shutdownFetcher()}.  *  * @throws Exception the first error or exception thrown by the fetcher or any of the threads created by the fetcher.  */ public void runFetcher() throws Exception {     // check that we are running before proceeding     if (!running) {         return.     }     this.mainThread = Thread.currentThread().     // ------------------------------------------------------------------------     // Procedures before starting the infinite while loop:     // ------------------------------------------------------------------------     // 1. check that there is at least one shard in the subscribed streams to consume from (can be done by     // checking if at least one value in subscribedStreamsToLastDiscoveredShardIds is not null)     boolean hasShards = false.     StringBuilder streamsWithNoShardsFound = new StringBuilder().     for (Map.Entry<String, String> streamToLastDiscoveredShardEntry : subscribedStreamsToLastDiscoveredShardIds.entrySet()) {         if (streamToLastDiscoveredShardEntry.getValue() != null) {             hasShards = true.         } else {             streamsWithNoShardsFound.append(streamToLastDiscoveredShardEntry.getKey()).append(", ").         }     }     if (streamsWithNoShardsFound.length() != 0 && LOG.isWarnEnabled()) {         LOG.warn("Subtask {} has failed to find any shards for the following subscribed streams: {}", indexOfThisConsumerSubtask, streamsWithNoShardsFound.toString()).     }     if (!hasShards) {         throw new RuntimeException("No shards can be found for all subscribed streams: " + streams).     }     // consumer using a restored state checkpoint     for (int seededStateIndex = 0. seededStateIndex < subscribedShardsState.size(). seededStateIndex++) {         KinesisStreamShardState seededShardState = subscribedShardsState.get(seededStateIndex).         // only start a consuming thread if the seeded subscribed shard has not been completely read already         if (!seededShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {             if (LOG.isInfoEnabled()) {                 LOG.info("Subtask {} will start consuming seeded shard {} from sequence number {} with ShardConsumer {}", indexOfThisConsumerSubtask, seededShardState.getStreamShardHandle().toString(), seededShardState.getLastProcessedSequenceNum(), seededStateIndex).             }             shardConsumersExecutor.submit(createShardConsumer(seededStateIndex, subscribedShardsState.get(seededStateIndex).getStreamShardHandle(), subscribedShardsState.get(seededStateIndex).getLastProcessedSequenceNum(), registerShardMetrics(consumerMetricGroup, subscribedShardsState.get(seededStateIndex)))).         }     }     // start periodic watermark emitter, if a watermark assigner was configured     if (periodicWatermarkAssigner != null) {         long periodicWatermarkIntervalMillis = runtimeContext.getExecutionConfig().getAutoWatermarkInterval().         if (periodicWatermarkIntervalMillis > 0) {             ProcessingTimeService timerService = ((StreamingRuntimeContext) runtimeContext).getProcessingTimeService().             LOG.info("Starting periodic watermark emitter with interval {}", periodicWatermarkIntervalMillis).             new PeriodicWatermarkEmitter(timerService, periodicWatermarkIntervalMillis).start().         }         this.shardIdleIntervalMillis = Long.parseLong(getConsumerConfiguration().getProperty(ConsumerConfigConstants.SHARD_IDLE_INTERVAL_MILLIS, Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_IDLE_INTERVAL_MILLIS))).     }     // ------------------------------------------------------------------------     // finally, start the infinite shard discovery and consumer launching loop.     // we will escape from this loop only when shutdownFetcher() or stopWithError() is called     final long discoveryIntervalMillis = Long.valueOf(configProps.getProperty(ConsumerConfigConstants.SHARD_DISCOVERY_INTERVAL_MILLIS, Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_DISCOVERY_INTERVAL_MILLIS))).     if (this.numberOfActiveShards.get() == 0) {         LOG.info("Subtask {} has no active shards to read on startup. marking the subtask as temporarily idle ...", indexOfThisConsumerSubtask).         sourceContext.markAsTemporarilyIdle().     }     while (running) {         if (LOG.isDebugEnabled()) {             LOG.debug("Subtask {} is trying to discover new shards that were created due to resharding ...", indexOfThisConsumerSubtask).         }         List<StreamShardHandle> newShardsDueToResharding = discoverNewShardsToSubscribe().         for (StreamShardHandle shard : newShardsDueToResharding) {             // since there may be delay in discovering a new shard, all new shards due to             // resharding should be read starting from the earliest record possible             KinesisStreamShardState newShardState = new KinesisStreamShardState(convertToStreamShardMetadata(shard), shard, SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get()).             int newStateIndex = registerNewSubscribedShardState(newShardState).             if (LOG.isInfoEnabled()) {                 LOG.info("Subtask {} has discovered a new shard {} due to resharding, and will start consuming " + "the shard from sequence number {} with ShardConsumer {}", indexOfThisConsumerSubtask, newShardState.getStreamShardHandle().toString(), newShardState.getLastProcessedSequenceNum(), newStateIndex).             }             shardConsumersExecutor.submit(createShardConsumer(newStateIndex, newShardState.getStreamShardHandle(), newShardState.getLastProcessedSequenceNum(), registerShardMetrics(consumerMetricGroup, newShardState))).         }         // interval if the running flag was set to false during the middle of the while loop         if (running && discoveryIntervalMillis != 0) {             try {                 Thread.sleep(discoveryIntervalMillis).             } catch (InterruptedException iex) {             // the sleep may be interrupted by shutdownFetcher()             }         }     }     // make sure all resources have been terminated before leaving     try {         awaitTermination().     } catch (InterruptedException ie) {         // If there is an original exception, preserve it, since that's more important/useful.         this.error.compareAndSet(null, ie).     }     // any error thrown in the shard consumer threads will be thrown to the main thread     Throwable throwable = this.error.get().     if (throwable != null) {         if (throwable instanceof Exception) {             throw (Exception) throwable.         } else if (throwable instanceof Error) {             throw (Error) throwable.         } else {             throw new Exception(throwable).         }     } }
true;public;0;10;/**  * Creates a snapshot of the current last processed sequence numbers of each subscribed shard.  *  * @return state snapshot  */ ;/**  * Creates a snapshot of the current last processed sequence numbers of each subscribed shard.  *  * @return state snapshot  */ public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {     // this method assumes that the checkpoint lock is held     assert Thread.holdsLock(checkpointLock).     HashMap<StreamShardMetadata, SequenceNumber> stateSnapshot = new HashMap<>().     for (KinesisStreamShardState shardWithState : subscribedShardsState) {         stateSnapshot.put(shardWithState.getStreamShardMetadata(), shardWithState.getLastProcessedSequenceNum()).     }     return stateSnapshot. }
true;public;0;12;/**  * Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete.  * Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.  */ ;/**  * Starts shutting down the fetcher. Must be called to allow {@link KinesisDataFetcher#runFetcher()} to complete.  * Once called, the shutdown procedure will be executed and all shard consuming threads will be interrupted.  */ public void shutdownFetcher() {     running = false.     if (mainThread != null) {         // the main thread may be sleeping for the discovery interval         mainThread.interrupt().     }     if (LOG.isInfoEnabled()) {         LOG.info("Shutting down the shard consumer threads of subtask {} ...", indexOfThisConsumerSubtask).     }     shardConsumersExecutor.shutdownNow(). }
true;public;0;5;/**  * After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.  */ ;/**  * After calling {@link KinesisDataFetcher#shutdownFetcher()}, this can be called to await the fetcher shutdown.  */ public void awaitTermination() throws InterruptedException {     while (!shardConsumersExecutor.awaitTermination(1, TimeUnit.MINUTES)) {     // Keep waiting.     } }
true;protected;1;5;/**  * Called by created threads to pass on errors. Only the first thrown error is set.  * Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.  */ ;/**  * Called by created threads to pass on errors. Only the first thrown error is set.  * Once set, the shutdown process will be executed and all shard consuming threads will be interrupted.  */ protected void stopWithError(Throwable throwable) {     if (this.error.compareAndSet(null, throwable)) {         shutdownFetcher().     } }
true;public;2;12;/**  * Updates the last discovered shard of a subscribed stream. only updates if the update is valid.  */ ;// ------------------------------------------------------------------------ // Functions that update the subscribedStreamToLastDiscoveredShardIds state // ------------------------------------------------------------------------ /**  * Updates the last discovered shard of a subscribed stream. only updates if the update is valid.  */ public void advanceLastDiscoveredShardOfStream(String stream, String shardId) {     String lastSeenShardIdOfStream = this.subscribedStreamsToLastDiscoveredShardIds.get(stream).     // than the previous last seen shard id of the stream     if (lastSeenShardIdOfStream == null) {         // if not previously set, simply put as the last seen shard id         this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId).     } else if (shouldAdvanceLastDiscoveredShardId(shardId, lastSeenShardIdOfStream)) {         this.subscribedStreamsToLastDiscoveredShardIds.put(stream, shardId).     } }
true;protected;2;3;/**  * Given lastSeenShardId, check if last discovered shardId should be advanced.  */ ;/**  * Given lastSeenShardId, check if last discovered shardId should be advanced.  */ protected boolean shouldAdvanceLastDiscoveredShardId(String shardId, String lastSeenShardIdOfStream) {     return (StreamShardHandle.compareShardIds(shardId, lastSeenShardIdOfStream) > 0). }
true;public;0;24;/**  * A utility function that does the following:  *  * <p>1. Find new shards for each stream that we haven't seen before  * 2. For each new shard, determine whether this consumer subtask should subscribe to them.  * 	  if yes, it is added to the returned list of shards  * 3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards  *    that we have already seen before the next time this function is called  */ ;/**  * A utility function that does the following:  *  * <p>1. Find new shards for each stream that we haven't seen before  * 2. For each new shard, determine whether this consumer subtask should subscribe to them.  * 	  if yes, it is added to the returned list of shards  * 3. Update the subscribedStreamsToLastDiscoveredShardIds state so that we won't get shards  *    that we have already seen before the next time this function is called  */ public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {     List<StreamShardHandle> newShardsToSubscribe = new LinkedList<>().     GetShardListResult shardListResult = kinesis.getShardList(subscribedStreamsToLastDiscoveredShardIds).     if (shardListResult.hasRetrievedShards()) {         Set<String> streamsWithNewShards = shardListResult.getStreamsWithRetrievedShards().         for (String stream : streamsWithNewShards) {             List<StreamShardHandle> newShardsOfStream = shardListResult.getRetrievedShardListOfStream(stream).             for (StreamShardHandle newShard : newShardsOfStream) {                 int hashCode = shardAssigner.assign(newShard, totalNumberOfConsumerSubtasks).                 if (isThisSubtaskShouldSubscribeTo(hashCode, totalNumberOfConsumerSubtasks, indexOfThisConsumerSubtask)) {                     newShardsToSubscribe.add(newShard).                 }             }             advanceLastDiscoveredShardOfStream(stream, shardListResult.getLastSeenShardOfStream(stream).getShard().getShardId()).         }     }     return newShardsToSubscribe. }
false;protected;0;3;;// ------------------------------------------------------------------------ // Functions to get / set information about the consumer // ------------------------------------------------------------------------ protected Properties getConsumerConfiguration() {     return configProps. }
false;protected;0;8;;protected KinesisDeserializationSchema<T> getClonedDeserializationSchema() {     try {         return InstantiationUtil.clone(deserializationSchema, runtimeContext.getUserCodeClassLoader()).     } catch (IOException | ClassNotFoundException ex) {         // this really shouldn't happen. simply wrap it around a runtime exception         throw new RuntimeException(ex).     } }
true;protected;4;25;/**  * Atomic operation to collect a record and update state to the sequence number of the record.  * This method is called by {@link ShardConsumer}s.  *  * @param record the record to collect  * @param recordTimestamp timestamp to attach to the collected record  * @param shardStateIndex index of the shard to update in subscribedShardsState.  *                        this index should be the returned value from  *                        {@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called  *                        when the shard state was registered.  * @param lastSequenceNumber the last sequence number value to update  */ ;// ------------------------------------------------------------------------ // Thread-safe operations for record emitting and shard state updating // that assure atomicity with respect to the checkpoint lock // ------------------------------------------------------------------------ /**  * Atomic operation to collect a record and update state to the sequence number of the record.  * This method is called by {@link ShardConsumer}s.  *  * @param record the record to collect  * @param recordTimestamp timestamp to attach to the collected record  * @param shardStateIndex index of the shard to update in subscribedShardsState.  *                        this index should be the returned value from  *                        {@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called  *                        when the shard state was registered.  * @param lastSequenceNumber the last sequence number value to update  */ protected void emitRecordAndUpdateState(T record, long recordTimestamp, int shardStateIndex, SequenceNumber lastSequenceNumber) {     // when a watermark assigner was configured.     if (periodicWatermarkAssigner != null) {         ShardWatermarkState sws = shardWatermarks.get(shardStateIndex).         Preconditions.checkNotNull(sws, "shard watermark state initialized in registerNewSubscribedShardState").         recordTimestamp = sws.periodicWatermarkAssigner.extractTimestamp(record, sws.lastRecordTimestamp).         sws.lastRecordTimestamp = recordTimestamp.         sws.lastUpdated = getCurrentTimeMillis().     }     synchronized (checkpointLock) {         if (record != null) {             sourceContext.collectWithTimestamp(record, recordTimestamp).         } else {             LOG.warn("Skipping non-deserializable record at sequence number {} of shard {}.", lastSequenceNumber, subscribedShardsState.get(shardStateIndex).getStreamShardHandle()).         }         updateState(shardStateIndex, lastSequenceNumber).     } }
true;protected,final;2;23;/**  * Update the shard to last processed sequence number state.  * This method is called by {@link ShardConsumer}s.  *  * @param shardStateIndex index of the shard to update in subscribedShardsState.  *                        this index should be the returned value from  *                        {@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called  *                        when the shard state was registered.  * @param lastSequenceNumber the last sequence number value to update  */ ;/**  * Update the shard to last processed sequence number state.  * This method is called by {@link ShardConsumer}s.  *  * @param shardStateIndex index of the shard to update in subscribedShardsState.  *                        this index should be the returned value from  *                        {@link KinesisDataFetcher#registerNewSubscribedShardState(KinesisStreamShardState)}, called  *                        when the shard state was registered.  * @param lastSequenceNumber the last sequence number value to update  */ protected final void updateState(int shardStateIndex, SequenceNumber lastSequenceNumber) {     synchronized (checkpointLock) {         subscribedShardsState.get(shardStateIndex).setLastProcessedSequenceNum(lastSequenceNumber).         // we've finished reading the shard and should determine it to be non-active         if (lastSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {             LOG.info("Subtask {} has reached the end of subscribed shard: {}", indexOfThisConsumerSubtask, subscribedShardsState.get(shardStateIndex).getStreamShardHandle()).             // be active immediately afterwards as soon as we collect records from the new shards             if (this.numberOfActiveShards.decrementAndGet() == 0) {                 LOG.info("Subtask {} has reached the end of all currently subscribed shards. marking the subtask as temporarily idle ...", indexOfThisConsumerSubtask).                 sourceContext.markAsTemporarilyIdle().             }         }     } }
true;public;1;30;/**  * Register a new subscribed shard state.  *  * @param newSubscribedShardState the new shard state that this fetcher is to be subscribed to  */ ;/**  * Register a new subscribed shard state.  *  * @param newSubscribedShardState the new shard state that this fetcher is to be subscribed to  */ public int registerNewSubscribedShardState(KinesisStreamShardState newSubscribedShardState) {     synchronized (checkpointLock) {         subscribedShardsState.add(newSubscribedShardState).         // this subtask has a new active shard         if (!newSubscribedShardState.getLastProcessedSequenceNum().equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {             this.numberOfActiveShards.incrementAndGet().         }         int shardStateIndex = subscribedShardsState.size() - 1.         // track all discovered shards for watermark determination         ShardWatermarkState sws = shardWatermarks.get(shardStateIndex).         if (sws == null) {             sws = new ShardWatermarkState().             try {                 sws.periodicWatermarkAssigner = InstantiationUtil.clone(periodicWatermarkAssigner).             } catch (Exception e) {                 throw new RuntimeException("Failed to instantiate new WatermarkAssigner", e).             }             sws.lastUpdated = getCurrentTimeMillis().             sws.lastRecordTimestamp = Long.MIN_VALUE.             shardWatermarks.put(shardStateIndex, sws).         }         return shardStateIndex.     } }
true;protected;0;4;/**  * Return the current system time. Allow tests to override this to simulate progress for watermark  * logic.  *  * @return current processing time  */ ;/**  * Return the current system time. Allow tests to override this to simulate progress for watermark  * logic.  *  * @return current processing time  */ @VisibleForTesting protected long getCurrentTimeMillis() {     return System.currentTimeMillis(). }
true;protected;0;33;/**  * Called periodically to emit a watermark. Checks all shards for the current event time  * watermark, and possibly emits the next watermark.  *  * <p>Shards that have not received an update for a certain interval are considered inactive so as  * to not hold back the watermark indefinitely. When all shards are inactive, the subtask will be  * marked as temporarily idle to not block downstream operators.  */ ;/**  * Called periodically to emit a watermark. Checks all shards for the current event time  * watermark, and possibly emits the next watermark.  *  * <p>Shards that have not received an update for a certain interval are considered inactive so as  * to not hold back the watermark indefinitely. When all shards are inactive, the subtask will be  * marked as temporarily idle to not block downstream operators.  */ @VisibleForTesting protected void emitWatermark() {     LOG.debug("Evaluating watermark for subtask {} time {}", indexOfThisConsumerSubtask, getCurrentTimeMillis()).     long potentialWatermark = Long.MAX_VALUE.     long idleTime = (shardIdleIntervalMillis > 0) ? getCurrentTimeMillis() - shardIdleIntervalMillis : Long.MAX_VALUE.     for (Map.Entry<Integer, ShardWatermarkState> e : shardWatermarks.entrySet()) {         // consider only active shards, or those that would advance the watermark         Watermark w = e.getValue().periodicWatermarkAssigner.getCurrentWatermark().         if (w != null && (e.getValue().lastUpdated >= idleTime || w.getTimestamp() > lastWatermark)) {             potentialWatermark = Math.min(potentialWatermark, w.getTimestamp()).         }     }     // advance watermark if possible (watermarks can only be ascending)     if (potentialWatermark == Long.MAX_VALUE) {         if (shardWatermarks.isEmpty() || shardIdleIntervalMillis > 0) {             LOG.debug("No active shard for subtask {}, marking the source idle.", indexOfThisConsumerSubtask).             // no active shard, signal downstream operators to not wait for a watermark             sourceContext.markAsTemporarilyIdle().         }     } else if (potentialWatermark > lastWatermark) {         LOG.debug("Emitting watermark {} from subtask {}", potentialWatermark, indexOfThisConsumerSubtask).         sourceContext.emitWatermark(new Watermark(potentialWatermark)).         lastWatermark = potentialWatermark.     } }
false;public;0;4;;public void start() {     LOG.debug("registering periodic watermark timer with interval {}", interval).     timerService.registerTimer(timerService.getCurrentProcessingTime() + interval, this). }
false;public;1;6;;@Override public void onProcessingTime(long timestamp) {     emitWatermark().     // schedule the next watermark     timerService.registerTimer(timerService.getCurrentProcessingTime() + interval, this). }
true;private,static;2;22;/**  * Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.  *  * @return a {@link ShardMetricsReporter} that can be used to update metric values  */ ;/**  * Registers a metric group associated with the shard id of the provided {@link KinesisStreamShardState shardState}.  *  * @return a {@link ShardMetricsReporter} that can be used to update metric values  */ private static ShardMetricsReporter registerShardMetrics(MetricGroup metricGroup, KinesisStreamShardState shardState) {     ShardMetricsReporter shardMetrics = new ShardMetricsReporter().     MetricGroup streamShardMetricGroup = metricGroup.addGroup(KinesisConsumerMetricConstants.STREAM_METRICS_GROUP, shardState.getStreamShardHandle().getStreamName()).addGroup(KinesisConsumerMetricConstants.SHARD_METRICS_GROUP, shardState.getStreamShardHandle().getShard().getShardId()).     streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MILLIS_BEHIND_LATEST_GAUGE, shardMetrics::getMillisBehindLatest).     streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.MAX_RECORDS_PER_FETCH, shardMetrics::getMaxNumberOfRecordsPerFetch).     streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_AGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfAggregatedRecords).     streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.NUM_DEAGGREGATED_RECORDS_PER_FETCH, shardMetrics::getNumberOfDeaggregatedRecords).     streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.AVG_RECORD_SIZE_BYTES, shardMetrics::getAverageRecordSizeBytes).     streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.BYTES_PER_READ, shardMetrics::getBytesPerRead).     streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.RUNTIME_LOOP_NANOS, shardMetrics::getRunLoopTimeNanos).     streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.LOOP_FREQUENCY_HZ, shardMetrics::getLoopFrequencyHz).     streamShardMetricGroup.gauge(KinesisConsumerMetricConstants.SLEEP_TIME_MILLIS, shardMetrics::getSleepTimeMillis).     return shardMetrics. }
true;public,static;3;5;/**  * Utility function to determine whether a shard should be subscribed by this consumer subtask.  *  * @param shardHash hash code for the shard  * @param totalNumberOfConsumerSubtasks total number of consumer subtasks  * @param indexOfThisConsumerSubtask index of this consumer subtask  */ ;// ------------------------------------------------------------------------ // Miscellaneous utility functions // ------------------------------------------------------------------------ /**  * Utility function to determine whether a shard should be subscribed by this consumer subtask.  *  * @param shardHash hash code for the shard  * @param totalNumberOfConsumerSubtasks total number of consumer subtasks  * @param indexOfThisConsumerSubtask index of this consumer subtask  */ public static boolean isThisSubtaskShouldSubscribeTo(int shardHash, int totalNumberOfConsumerSubtasks, int indexOfThisConsumerSubtask) {     return (Math.abs(shardHash % totalNumberOfConsumerSubtasks)) == indexOfThisConsumerSubtask. }
false;public;1;8;;@Override public Thread newThread(Runnable runnable) {     final AtomicLong threadCount = new AtomicLong(0).     Thread thread = new Thread(runnable).     thread.setName("shardConsumers-" + subtaskName + "-thread-" + threadCount.getAndIncrement()).     thread.setDaemon(true).     return thread. }
false;protected;1;13;;@VisibleForTesting protected ExecutorService createShardConsumersThreadPool(final String subtaskName) {     return Executors.newCachedThreadPool(new ThreadFactory() {          @Override         public Thread newThread(Runnable runnable) {             final AtomicLong threadCount = new AtomicLong(0).             Thread thread = new Thread(runnable).             thread.setName("shardConsumers-" + subtaskName + "-thread-" + threadCount.getAndIncrement()).             thread.setDaemon(true).             return thread.         }     }). }
false;public;0;4;;@VisibleForTesting public List<KinesisStreamShardState> getSubscribedShardsState() {     return subscribedShardsState. }
true;protected,static;1;7;/**  * Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null.  * This is called in the constructor. correct values will be set later on by calling advanceLastDiscoveredShardOfStream().  *  * @param streams the list of subscribed streams  * @return the initial map for subscribedStreamsToLastDiscoveredShardIds  */ ;/**  * Utility function to create an initial map of the last discovered shard id of each subscribed stream, set to null.  * This is called in the constructor. correct values will be set later on by calling advanceLastDiscoveredShardOfStream().  *  * @param streams the list of subscribed streams  * @return the initial map for subscribedStreamsToLastDiscoveredShardIds  */ protected static HashMap<String, String> createInitialSubscribedStreamsToLastDiscoveredShardsState(List<String> streams) {     HashMap<String, String> initial = new HashMap<>().     for (String stream : streams) {         initial.put(stream, null).     }     return initial. }
true;public,static;1;20;/**  * Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.  *  * @param streamShardHandle the {@link StreamShardHandle} to be converted  * @return a {@link StreamShardMetadata} object  */ ;/**  * Utility function to convert {@link StreamShardHandle} into {@link StreamShardMetadata}.  *  * @param streamShardHandle the {@link StreamShardHandle} to be converted  * @return a {@link StreamShardMetadata} object  */ public static StreamShardMetadata convertToStreamShardMetadata(StreamShardHandle streamShardHandle) {     StreamShardMetadata streamShardMetadata = new StreamShardMetadata().     streamShardMetadata.setStreamName(streamShardHandle.getStreamName()).     streamShardMetadata.setShardId(streamShardHandle.getShard().getShardId()).     streamShardMetadata.setParentShardId(streamShardHandle.getShard().getParentShardId()).     streamShardMetadata.setAdjacentParentShardId(streamShardHandle.getShard().getAdjacentParentShardId()).     if (streamShardHandle.getShard().getHashKeyRange() != null) {         streamShardMetadata.setStartingHashKey(streamShardHandle.getShard().getHashKeyRange().getStartingHashKey()).         streamShardMetadata.setEndingHashKey(streamShardHandle.getShard().getHashKeyRange().getEndingHashKey()).     }     if (streamShardHandle.getShard().getSequenceNumberRange() != null) {         streamShardMetadata.setStartingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getStartingSequenceNumber()).         streamShardMetadata.setEndingSequenceNumber(streamShardHandle.getShard().getSequenceNumberRange().getEndingSequenceNumber()).     }     return streamShardMetadata. }
true;public,static;1;18;/**  * Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.  *  * @param streamShardMetadata the {@link StreamShardMetadata} to be converted  * @return a {@link StreamShardHandle} object  */ ;/**  * Utility function to convert {@link StreamShardMetadata} into {@link StreamShardHandle}.  *  * @param streamShardMetadata the {@link StreamShardMetadata} to be converted  * @return a {@link StreamShardHandle} object  */ public static StreamShardHandle convertToStreamShardHandle(StreamShardMetadata streamShardMetadata) {     Shard shard = new Shard().     shard.withShardId(streamShardMetadata.getShardId()).     shard.withParentShardId(streamShardMetadata.getParentShardId()).     shard.withAdjacentParentShardId(streamShardMetadata.getAdjacentParentShardId()).     HashKeyRange hashKeyRange = new HashKeyRange().     hashKeyRange.withStartingHashKey(streamShardMetadata.getStartingHashKey()).     hashKeyRange.withEndingHashKey(streamShardMetadata.getEndingHashKey()).     shard.withHashKeyRange(hashKeyRange).     SequenceNumberRange sequenceNumberRange = new SequenceNumberRange().     sequenceNumberRange.withStartingSequenceNumber(streamShardMetadata.getStartingSequenceNumber()).     sequenceNumberRange.withEndingSequenceNumber(streamShardMetadata.getEndingSequenceNumber()).     shard.withSequenceNumberRange(sequenceNumberRange).     return new StreamShardHandle(streamShardMetadata.getStreamName(), shard). }
