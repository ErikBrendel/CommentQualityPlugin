commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@Parameterized.Parameters(name = "Migration Savepoint: {0}") public static Collection<MigrationVersion> parameters() {     return Arrays.asList(MigrationVersion.v1_3, MigrationVersion.v1_4, MigrationVersion.v1_7). }
true;public;0;8;/**  * Manually run this to write binary snapshot data.  */ ;/**  * Manually run this to write binary snapshot data.  */ @Ignore @Test public void writeSnapshot() throws Exception {     writeSnapshot("src/test/resources/kinesis-consumer-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot", TEST_STATE).     // write empty state snapshot     writeSnapshot("src/test/resources/kinesis-consumer-migration-test-flink" + flinkGenerateSavepointVersion + "-empty-snapshot", new HashMap<>()). }
false;public;0;54;;@Test public void testRestoreWithEmptyState() throws Exception {     final List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size()).     for (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {         Shard shard = new Shard().         shard.setShardId(shardMetadata.getShardId()).         SequenceNumberRange sequenceNumberRange = new SequenceNumberRange().         sequenceNumberRange.withStartingSequenceNumber("1").         shard.setSequenceNumberRange(sequenceNumberRange).         initialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), shard)).     }     final TestFetcher<String> fetcher = new TestFetcher<>(Collections.singletonList(TEST_STREAM_NAME), new TestSourceContext<>(), new TestRuntimeContext(true, 1, 0), TestUtils.getStandardProperties(), new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()), null, initialDiscoveryShards).     final DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(fetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema())).     StreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator = new StreamSource<>(consumerFunction).     final AbstractStreamOperatorTestHarness<String> testHarness = new AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("kinesis-consumer-migration-test-flink" + testMigrateVersion + "-empty-snapshot")).     testHarness.open().     consumerFunction.run(new TestSourceContext<>()).     // assert that no state was restored     assertTrue(consumerFunction.getRestoredState().isEmpty()).     // although the restore state is empty, the fetcher should still have been registered the initial discovered shard.     // furthermore, the discovered shard should be considered a newly created shard while the job wasn't running,     // and therefore should be consumed from the earliest sequence number     KinesisStreamShardState restoredShardState = fetcher.getSubscribedShardsState().get(0).     assertEquals(TEST_STREAM_NAME, restoredShardState.getStreamShardHandle().getStreamName()).     assertEquals(TEST_SHARD_ID, restoredShardState.getStreamShardHandle().getShard().getShardId()).     assertFalse(restoredShardState.getStreamShardHandle().isClosed()).     assertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredShardState.getLastProcessedSequenceNum()).     consumerOperator.close().     consumerOperator.cancel(). }
false;public;0;56;;@Test public void testRestore() throws Exception {     final List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size()).     for (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {         Shard shard = new Shard().         shard.setShardId(shardMetadata.getShardId()).         SequenceNumberRange sequenceNumberRange = new SequenceNumberRange().         sequenceNumberRange.withStartingSequenceNumber("1").         shard.setSequenceNumberRange(sequenceNumberRange).         initialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), shard)).     }     final TestFetcher<String> fetcher = new TestFetcher<>(Collections.singletonList(TEST_STREAM_NAME), new TestSourceContext<>(), new TestRuntimeContext(true, 1, 0), TestUtils.getStandardProperties(), new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()), null, initialDiscoveryShards).     final DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(fetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema())).     StreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator = new StreamSource<>(consumerFunction).     final AbstractStreamOperatorTestHarness<String> testHarness = new AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("kinesis-consumer-migration-test-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     consumerFunction.run(new TestSourceContext<>()).     // assert that state is correctly restored     assertNotEquals(null, consumerFunction.getRestoredState()).     assertEquals(1, consumerFunction.getRestoredState().size()).     assertEquals(TEST_STATE, removeEquivalenceWrappers(consumerFunction.getRestoredState())).     assertEquals(1, fetcher.getSubscribedShardsState().size()).     assertEquals(TEST_SEQUENCE_NUMBER, fetcher.getSubscribedShardsState().get(0).getLastProcessedSequenceNum()).     KinesisStreamShardState restoredShardState = fetcher.getSubscribedShardsState().get(0).     assertEquals(TEST_STREAM_NAME, restoredShardState.getStreamShardHandle().getStreamName()).     assertEquals(TEST_SHARD_ID, restoredShardState.getStreamShardHandle().getShard().getShardId()).     assertFalse(restoredShardState.getStreamShardHandle().isClosed()).     assertEquals(TEST_SEQUENCE_NUMBER, restoredShardState.getLastProcessedSequenceNum()).     consumerOperator.close().     consumerOperator.cancel(). }
false;public;0;95;;@Test public void testRestoreWithReshardedStream() throws Exception {     final List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size()).     for (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {         // setup the closed shard         Shard closedShard = new Shard().         closedShard.setShardId(shardMetadata.getShardId()).         SequenceNumberRange closedSequenceNumberRange = new SequenceNumberRange().         closedSequenceNumberRange.withStartingSequenceNumber("1").         // this represents a closed shard         closedSequenceNumberRange.withEndingSequenceNumber("1087654321").         closedShard.setSequenceNumberRange(closedSequenceNumberRange).         initialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), closedShard)).         // setup the new shards         Shard newSplitShard1 = new Shard().         newSplitShard1.setShardId(KinesisShardIdGenerator.generateFromShardOrder(1)).         SequenceNumberRange newSequenceNumberRange1 = new SequenceNumberRange().         newSequenceNumberRange1.withStartingSequenceNumber("1087654322").         newSplitShard1.setSequenceNumberRange(newSequenceNumberRange1).         newSplitShard1.setParentShardId(TEST_SHARD_ID).         Shard newSplitShard2 = new Shard().         newSplitShard2.setShardId(KinesisShardIdGenerator.generateFromShardOrder(2)).         SequenceNumberRange newSequenceNumberRange2 = new SequenceNumberRange().         newSequenceNumberRange2.withStartingSequenceNumber("2087654322").         newSplitShard2.setSequenceNumberRange(newSequenceNumberRange2).         newSplitShard2.setParentShardId(TEST_SHARD_ID).         initialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard1)).         initialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard2)).     }     final TestFetcher<String> fetcher = new TestFetcher<>(Collections.singletonList(TEST_STREAM_NAME), new TestSourceContext<>(), new TestRuntimeContext(true, 1, 0), TestUtils.getStandardProperties(), new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()), null, initialDiscoveryShards).     final DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(fetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema())).     StreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator = new StreamSource<>(consumerFunction).     final AbstractStreamOperatorTestHarness<String> testHarness = new AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("kinesis-consumer-migration-test-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     consumerFunction.run(new TestSourceContext<>()).     // assert that state is correctly restored     assertNotEquals(null, consumerFunction.getRestoredState()).     assertEquals(1, consumerFunction.getRestoredState().size()).     assertEquals(TEST_STATE, removeEquivalenceWrappers(consumerFunction.getRestoredState())).     // assert that the fetcher is registered with all shards, including new shards     assertEquals(3, fetcher.getSubscribedShardsState().size()).     KinesisStreamShardState restoredClosedShardState = fetcher.getSubscribedShardsState().get(0).     assertEquals(TEST_STREAM_NAME, restoredClosedShardState.getStreamShardHandle().getStreamName()).     assertEquals(TEST_SHARD_ID, restoredClosedShardState.getStreamShardHandle().getShard().getShardId()).     assertTrue(restoredClosedShardState.getStreamShardHandle().isClosed()).     assertEquals(TEST_SEQUENCE_NUMBER, restoredClosedShardState.getLastProcessedSequenceNum()).     KinesisStreamShardState restoredNewSplitShard1 = fetcher.getSubscribedShardsState().get(1).     assertEquals(TEST_STREAM_NAME, restoredNewSplitShard1.getStreamShardHandle().getStreamName()).     assertEquals(KinesisShardIdGenerator.generateFromShardOrder(1), restoredNewSplitShard1.getStreamShardHandle().getShard().getShardId()).     assertFalse(restoredNewSplitShard1.getStreamShardHandle().isClosed()).     // new shards should be consumed from the beginning     assertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard1.getLastProcessedSequenceNum()).     KinesisStreamShardState restoredNewSplitShard2 = fetcher.getSubscribedShardsState().get(2).     assertEquals(TEST_STREAM_NAME, restoredNewSplitShard2.getStreamShardHandle().getStreamName()).     assertEquals(KinesisShardIdGenerator.generateFromShardOrder(2), restoredNewSplitShard2.getStreamShardHandle().getShard().getShardId()).     assertFalse(restoredNewSplitShard2.getStreamShardHandle().isClosed()).     // new shards should be consumed from the beginning     assertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard2.getLastProcessedSequenceNum()).     consumerOperator.close().     consumerOperator.cancel(). }
false;public;0;9;;@Override public void run() {     try {         consumer.run(new TestSourceContext<>()).     } catch (Throwable t) {         t.printStackTrace().         error.set(t).     } }
false;private;2;52;;// ------------------------------------------------------------------------ @SuppressWarnings("unchecked") private void writeSnapshot(String path, HashMap<StreamShardMetadata, SequenceNumber> state) throws Exception {     final TestFetcher<String> fetcher = new TestFetcher<>(Collections.singletonList(TEST_STREAM_NAME), new TestSourceContext<>(), new TestRuntimeContext(true, 1, 0), new Properties(), new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()), state, null).     final DummyFlinkKinesisConsumer<String> consumer = new DummyFlinkKinesisConsumer<>(fetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema())).     StreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator = new StreamSource<>(consumer).     final AbstractStreamOperatorTestHarness<String> testHarness = new AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0).     testHarness.setTimeCharacteristic(TimeCharacteristic.ProcessingTime).     testHarness.setup().     testHarness.open().     final AtomicReference<Throwable> error = new AtomicReference<>().     // run the source asynchronously     Thread runner = new Thread() {          @Override         public void run() {             try {                 consumer.run(new TestSourceContext<>()).             } catch (Throwable t) {                 t.printStackTrace().                 error.set(t).             }         }     }.     runner.start().     fetcher.waitUntilRun().     final OperatorSubtaskState snapshot.     synchronized (testHarness.getCheckpointLock()) {         snapshot = testHarness.snapshot(0L, 0L).     }     OperatorSnapshotUtil.writeStateHandle(snapshot, path).     consumerOperator.close().     runner.join(). }
false;protected;5;9;;@Override protected KinesisDataFetcher<T> createFetcher(List<String> streams, SourceContext<T> sourceContext, RuntimeContext runtimeContext, Properties configProps, KinesisDeserializationSchema<T> deserializer) {     return mockFetcher. }
false;public;0;4;;@Override public void runFetcher() throws Exception {     runLatch.trigger(). }
false;public;0;4;;@Override public HashMap<StreamShardMetadata, SequenceNumber> snapshotState() {     return testStateSnapshot. }
false;public;0;3;;public void waitUntilRun() throws InterruptedException {     runLatch.await(). }
false;public;0;4;;@Override public List<StreamShardHandle> discoverNewShardsToSubscribe() throws InterruptedException {     return testInitialDiscoveryShards. }
false;public;0;4;;@Override public void awaitTermination() throws InterruptedException { // do nothing }
false;private,static;1;10;;private static Map<StreamShardMetadata, SequenceNumber> removeEquivalenceWrappers(Map<StreamShardMetadata.EquivalenceWrapper, SequenceNumber> equivalenceWrappedMap) {     Map<StreamShardMetadata, SequenceNumber> unwrapped = new HashMap<>().     for (Map.Entry<StreamShardMetadata.EquivalenceWrapper, SequenceNumber> wrapped : equivalenceWrappedMap.entrySet()) {         unwrapped.put(wrapped.getKey().getShardMetadata(), wrapped.getValue()).     }     return unwrapped. }
