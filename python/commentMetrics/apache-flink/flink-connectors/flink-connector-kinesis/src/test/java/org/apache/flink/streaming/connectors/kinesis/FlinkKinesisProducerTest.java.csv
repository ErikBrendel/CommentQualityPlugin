commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;// ---------------------------------------------------------------------- // Tests to verify serializability // ---------------------------------------------------------------------- @Test public void testCreateWithNonSerializableDeserializerFails() {     exception.expect(IllegalArgumentException.class).     exception.expectMessage("The provided serialization schema is not serializable").     new FlinkKinesisProducer<>(new NonSerializableSerializationSchema(), TestUtils.getStandardProperties()). }
false;public;0;4;;@Test public void testCreateWithSerializableDeserializer() {     new FlinkKinesisProducer<>(new SerializableSerializationSchema(), TestUtils.getStandardProperties()). }
false;public;0;8;;@Test public void testConfigureWithNonSerializableCustomPartitionerFails() {     exception.expect(IllegalArgumentException.class).     exception.expectMessage("The provided custom partitioner is not serializable").     new FlinkKinesisProducer<>(new SimpleStringSchema(), TestUtils.getStandardProperties()).setCustomPartitioner(new NonSerializableCustomPartitioner()). }
false;public;0;5;;@Test public void testConfigureWithSerializableCustomPartitioner() {     new FlinkKinesisProducer<>(new SimpleStringSchema(), TestUtils.getStandardProperties()).setCustomPartitioner(new SerializableCustomPartitioner()). }
false;public;0;5;;@Test public void testProducerIsSerializable() {     FlinkKinesisProducer<String> consumer = new FlinkKinesisProducer<>(new SimpleStringSchema(), TestUtils.getStandardProperties()).     assertTrue(InstantiationUtil.isSerializable(consumer)). }
true;public;0;26;/**  * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.  */ ;// ---------------------------------------------------------------------- // Tests to verify at-least-once guarantee // ---------------------------------------------------------------------- /**  * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.  */ @SuppressWarnings("ResultOfMethodCallIgnored") @Test public void testAsyncErrorRethrownOnInvoke() throws Throwable {     final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema()).     OneInputStreamOperatorTestHarness<String, Object> testHarness = new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer)).     testHarness.open().     testHarness.processElement(new StreamRecord<>("msg-1")).     producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception")).     try {         testHarness.processElement(new StreamRecord<>("msg-2")).     } catch (Exception e) {         // the next invoke should rethrow the async exception         Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent()).         // test succeeded         return.     }     Assert.fail(). }
true;public;0;26;/**  * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.  */ ;/**  * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.  */ @SuppressWarnings("ResultOfMethodCallIgnored") @Test public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {     final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema()).     OneInputStreamOperatorTestHarness<String, Object> testHarness = new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer)).     testHarness.open().     testHarness.processElement(new StreamRecord<>("msg-1")).     producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception")).     try {         testHarness.snapshot(123L, 123L).     } catch (Exception e) {         // the next checkpoint should rethrow the async exception         Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent()).         // test succeeded         return.     }     Assert.fail(). }
false;public;0;5;;@Override public void go() throws Exception {     // this should block at first, since there are still two pending records that needs to be flushed     testHarness.snapshot(123L, 123L). }
true;public;0;44;/**  * Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,  * it should be rethrown. we set a timeout because the test will not finish if the logic is broken.  *  * <p>Note that this test does not test the snapshot method is blocked correctly when there are pending records.  * The test for that is covered in testAtLeastOnceProducer.  */ ;/**  * Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,  * it should be rethrown. we set a timeout because the test will not finish if the logic is broken.  *  * <p>Note that this test does not test the snapshot method is blocked correctly when there are pending records.  * The test for that is covered in testAtLeastOnceProducer.  */ @SuppressWarnings("ResultOfMethodCallIgnored") @Test(timeout = 10000) public void testAsyncErrorRethrownAfterFlush() throws Throwable {     final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema()).     OneInputStreamOperatorTestHarness<String, Object> testHarness = new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer)).     testHarness.open().     testHarness.processElement(new StreamRecord<>("msg-1")).     testHarness.processElement(new StreamRecord<>("msg-2")).     testHarness.processElement(new StreamRecord<>("msg-3")).     // only let the first record succeed for now     UserRecordResult result = mock(UserRecordResult.class).     when(result.isSuccessful()).thenReturn(true).     producer.getPendingRecordFutures().get(0).set(result).     CheckedThread snapshotThread = new CheckedThread() {          @Override         public void go() throws Exception {             // this should block at first, since there are still two pending records that needs to be flushed             testHarness.snapshot(123L, 123L).         }     }.     snapshotThread.start().     // let the 2nd message fail with an async exception     producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message")).     producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class)).     try {         snapshotThread.sync().     } catch (Exception e) {         // after the flush, the async exception should have been rethrown         Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent()).         // test succeeded         return.     }     Assert.fail(). }
false;public;0;6;;@Override public void go() throws Exception {     // this should block until all records are flushed.     // if the snapshot implementation returns before pending records are flushed,     testHarness.snapshot(123L, 123L). }
true;public;0;47;/**  * Test ensuring that the producer is not dropping buffered records.  * we set a timeout because the test will not finish if the logic is broken.  */ ;/**  * Test ensuring that the producer is not dropping buffered records.  * we set a timeout because the test will not finish if the logic is broken.  */ @SuppressWarnings({ "unchecked", "ResultOfMethodCallIgnored" }) @Test(timeout = 10000) public void testAtLeastOnceProducer() throws Throwable {     final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema()).     OneInputStreamOperatorTestHarness<String, Object> testHarness = new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer)).     testHarness.open().     testHarness.processElement(new StreamRecord<>("msg-1")).     testHarness.processElement(new StreamRecord<>("msg-2")).     testHarness.processElement(new StreamRecord<>("msg-3")).     // start a thread to perform checkpointing     CheckedThread snapshotThread = new CheckedThread() {          @Override         public void go() throws Exception {             // this should block until all records are flushed.             // if the snapshot implementation returns before pending records are flushed,             testHarness.snapshot(123L, 123L).         }     }.     snapshotThread.start().     // before proceeding, make sure that flushing has started and that the snapshot is still blocked.     // this would block forever if the snapshot didn't perform a flush     producer.waitUntilFlushStarted().     Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive()).     // now, complete the callbacks     UserRecordResult result = mock(UserRecordResult.class).     when(result.isSuccessful()).thenReturn(true).     producer.getPendingRecordFutures().get(0).set(result).     Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive()).     producer.getPendingRecordFutures().get(1).set(result).     Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive()).     producer.getPendingRecordFutures().get(2).set(result).     // this would fail with an exception if flushing wasn't completed before the snapshot method returned     snapshotThread.sync().     testHarness.close(). }
false;public;0;4;;@Override public void go() throws Exception {     testHarness.processElement(new StreamRecord<>("msg-1")). }
false;public;0;4;;@Override public void go() throws Exception {     testHarness.processElement(new StreamRecord<>("msg-2")). }
false;public;0;7;;@Override public void go() throws Exception {     // this should block until msg-2 is consumed     testHarness.processElement(new StreamRecord<>("msg-3")).     // this should block until msg-3 is consumed     testHarness.processElement(new StreamRecord<>("msg-4")). }
true;public;0;67;/**  * Test ensuring that the producer blocks if the queue limit is exceeded,  * until the queue length drops below the limit.  * we set a timeout because the test will not finish if the logic is broken.  */ ;/**  * Test ensuring that the producer blocks if the queue limit is exceeded,  * until the queue length drops below the limit.  * we set a timeout because the test will not finish if the logic is broken.  */ @Test(timeout = 10000) public void testBackpressure() throws Throwable {     final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema()).     producer.setQueueLimit(1).     OneInputStreamOperatorTestHarness<String, Object> testHarness = new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer)).     testHarness.open().     UserRecordResult result = mock(UserRecordResult.class).     when(result.isSuccessful()).thenReturn(true).     CheckedThread msg1 = new CheckedThread() {          @Override         public void go() throws Exception {             testHarness.processElement(new StreamRecord<>("msg-1")).         }     }.     msg1.start().     msg1.trySync(100).     assertFalse("Flush triggered before reaching queue limit", msg1.isAlive()).     // consume msg-1 so that queue is empty again     producer.getPendingRecordFutures().get(0).set(result).     CheckedThread msg2 = new CheckedThread() {          @Override         public void go() throws Exception {             testHarness.processElement(new StreamRecord<>("msg-2")).         }     }.     msg2.start().     msg2.trySync(100).     assertFalse("Flush triggered before reaching queue limit", msg2.isAlive()).     CheckedThread moreElementsThread = new CheckedThread() {          @Override         public void go() throws Exception {             // this should block until msg-2 is consumed             testHarness.processElement(new StreamRecord<>("msg-3")).             // this should block until msg-3 is consumed             testHarness.processElement(new StreamRecord<>("msg-4")).         }     }.     moreElementsThread.start().     moreElementsThread.trySync(100).     assertTrue("Producer should still block, but doesn't", moreElementsThread.isAlive()).     // consume msg-2 from the queue, leaving msg-3 in the queue and msg-4 blocked     producer.getPendingRecordFutures().get(1).set(result).     moreElementsThread.trySync(100).     assertTrue("Producer should still block, but doesn't", moreElementsThread.isAlive()).     // consume msg-3, blocked msg-4 can be inserted into the queue and block is released     producer.getPendingRecordFutures().get(2).set(result).     moreElementsThread.trySync(100).     assertFalse("Prodcuer still blocks although the queue is flushed", moreElementsThread.isAlive()).     producer.getPendingRecordFutures().get(3).set(result).     testHarness.close(). }
false;public;1;4;;@Override public ByteBuffer serialize(String element) {     return ByteBuffer.wrap(element.getBytes()). }
false;public;1;4;;@Override public String getTargetStream(String element) {     return "test-stream". }
false;public;1;4;;@Override public ByteBuffer serialize(String element) {     return ByteBuffer.wrap(element.getBytes()). }
false;public;1;4;;@Override public String getTargetStream(String element) {     return "test-stream". }
false;public;1;4;;@Override public String getPartitionId(String element) {     return "test-partition". }
false;public;1;4;;@Override public String getPartitionId(String element) {     return "test-partition". }
false;public;1;6;;@Override public Object answer(InvocationOnMock invocationOnMock) throws Throwable {     SettableFuture<UserRecordResult> future = SettableFuture.create().     pendingRecordFutures.add(future).     return future. }
false;public;1;4;;@Override public Object answer(InvocationOnMock invocationOnMock) throws Throwable {     return getNumPendingRecordFutures(). }
false;public;1;5;;@Override public Object answer(InvocationOnMock invocationOnMock) throws Throwable {     flushLatch.trigger().     return null. }
false;protected;1;4;;@Override protected KinesisProducer getKinesisProducer(KinesisProducerConfiguration producerConfig) {     return mockProducer. }
false;public;1;10;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     super.snapshotState(context).     // if the snapshot implementation doesn't wait until all pending records are flushed, we should fail the test     if (mockProducer.getOutstandingRecordsCount() > 0) {         throw new RuntimeException("Flushing is enabled. snapshots should be blocked until all pending records are flushed").     } }
false;;0;3;;List<SettableFuture<UserRecordResult>> getPendingRecordFutures() {     return pendingRecordFutures. }
false;;0;3;;void waitUntilFlushStarted() throws Exception {     flushLatch.await(). }
false;private;0;11;;private int getNumPendingRecordFutures() {     int numPending = 0.     for (SettableFuture<UserRecordResult> future : pendingRecordFutures) {         if (!future.isDone()) {             numPending++.         }     }     return numPending. }
