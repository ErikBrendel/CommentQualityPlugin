commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) {     // not setting any retrieved shards for result     return new GetShardListResult(). }
false;public;3;4;;@Override public String getShardIterator(StreamShardHandle shard, String shardIteratorType, Object startingMarker) {     return null. }
false;public;2;4;;@Override public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) {     return null. }
false;public,static;0;20;;// ------------------------------------------------------------------------ // Behaviours related to shard listing and resharding, used in KinesisDataFetcherTest // ------------------------------------------------------------------------ public static KinesisProxyInterface noShardsFoundForRequestedStreamsBehaviour() {     return new KinesisProxyInterface() {          @Override         public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) {             // not setting any retrieved shards for result             return new GetShardListResult().         }          @Override         public String getShardIterator(StreamShardHandle shard, String shardIteratorType, Object startingMarker) {             return null.         }          @Override         public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) {             return null.         }     }. }
false;public,static;1;4;;public static KinesisProxyInterface nonReshardedStreamsBehaviour(Map<String, Integer> streamsToShardCount) {     return new NonReshardedStreamsKinesis(streamsToShardCount). }
false;public,static;3;6;;// ------------------------------------------------------------------------ // Behaviours related to fetching records, used mainly in ShardConsumerTest // ------------------------------------------------------------------------ public static KinesisProxyInterface totalNumOfRecordsAfterNumOfGetRecordsCalls(final int numOfRecords, final int numOfGetRecordsCalls, final long millisBehindLatest) {     return new SingleShardEmittingFixNumOfRecordsKinesis(numOfRecords, numOfGetRecordsCalls, millisBehindLatest). }
false;public,static;4;8;;public static KinesisProxyInterface totalNumOfRecordsAfterNumOfGetRecordsCallsWithUnexpectedExpiredIterator(final int numOfRecords, final int numOfGetRecordsCall, final int orderOfCallToExpire, final long millisBehindLatest) {     return new SingleShardEmittingFixNumOfRecordsWithExpiredIteratorKinesis(numOfRecords, numOfGetRecordsCall, orderOfCallToExpire, millisBehindLatest). }
false;public,static;3;7;;public static KinesisProxyInterface initialNumOfRecordsAfterNumOfGetRecordsCallsWithAdaptiveReads(final int numOfRecords, final int numOfGetRecordsCalls, final long millisBehindLatest) {     return new SingleShardEmittingAdaptiveNumOfRecordsKinesis(numOfRecords, numOfGetRecordsCalls, millisBehindLatest). }
false;public,static;1;3;;public static KinesisProxyInterface blockingQueueGetRecords(Map<String, List<BlockingQueue<String>>> streamsToShardQueues) {     return new BlockingQueueKinesis(streamsToShardQueues). }
false;public;2;20;;@Override public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) {     if ((Integer.valueOf(shardIterator) == orderOfCallToExpire - 1) && !expiredOnceAlready) {         // we fake only once the expired iterator exception at the specified get records attempt order         expiredOnceAlready = true.         throw new ExpiredIteratorException("Artificial expired shard iterator").     } else if (expiredOnceAlready && !expiredIteratorRefreshed) {         // throw a hard exception to the test that is testing this Kinesis behaviour         throw new RuntimeException("expired shard iterator was not refreshed on the next getRecords() call").     } else {         // assuming that the maxRecordsToGet is always large enough         return new GetRecordsResult().withRecords(shardItrToRecordBatch.get(shardIterator)).withMillisBehindLatest(millisBehindLatest).withNextShardIterator((Integer.valueOf(shardIterator) == totalNumOfGetRecordsCalls - 1) ? null : // last next shard iterator is null         String.valueOf(Integer.valueOf(shardIterator) + 1)).     } }
false;public;3;12;;@Override public String getShardIterator(StreamShardHandle shard, String shardIteratorType, Object startingMarker) {     if (!expiredOnceAlready) {         // for the first call, just return the iterator of the first batch of records         return "0".     } else {         // fake the iterator refresh when this is called again after getRecords throws expired iterator         // exception on the orderOfCallToExpire attempt         expiredIteratorRefreshed = true.         return String.valueOf(orderOfCallToExpire - 1).     } }
false;public;2;10;;@Override public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) {     // assuming that the maxRecordsToGet is always large enough     return new GetRecordsResult().withRecords(shardItrToRecordBatch.get(shardIterator)).withMillisBehindLatest(millisBehindLatest).withNextShardIterator((Integer.valueOf(shardIterator) == totalNumOfGetRecordsCalls - 1) ? null : // last next shard iterator is null     String.valueOf(Integer.valueOf(shardIterator) + 1)). }
false;public;3;6;;@Override public String getShardIterator(StreamShardHandle shard, String shardIteratorType, Object startingMarker) {     // so, simply return the iterator of the first batch of records     return "0". }
false;public;1;4;;@Override public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) {     return null. }
false;public,static;2;12;;public static List<Record> createRecordBatchWithRange(int min, int max) {     List<Record> batch = new LinkedList<>().     for (int i = min. i < max. i++) {         batch.add(new Record().withData(ByteBuffer.wrap(String.valueOf(i).getBytes(ConfigConstants.DEFAULT_CHARSET))).withPartitionKey(UUID.randomUUID().toString()).withApproximateArrivalTimestamp(new Date(System.currentTimeMillis())).withSequenceNumber(String.valueOf(i))).     }     return batch. }
false;public;2;11;;@Override public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) {     // assuming that the maxRecordsToGet is always large enough     return new GetRecordsResult().withRecords(shardItrToRecordBatch.get(shardIterator)).withMillisBehindLatest(millisBehindLatest).withNextShardIterator((Integer.valueOf(shardIterator) == totalNumOfGetRecordsCalls - 1) ? null : String.valueOf(// last next shard iterator is null     Integer.valueOf(shardIterator) + 1)). }
false;public;3;7;;@Override public String getShardIterator(StreamShardHandle shard, String shardIteratorType, Object startingMarker) {     // so, simply return the iterator of the first batch of records     return "0". }
false;public;1;4;;@Override public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) {     return null. }
false;public,static;2;23;;public static List<Record> createRecordBatchWithRange(int min, int max) {     List<Record> batch = new LinkedList<>().     long sumRecordBatchBytes = 0L.     // Create record of size 10Kb     String data = createDataSize(10 * 1024L).     for (int i = min. i < max. i++) {         Record record = new Record().withData(ByteBuffer.wrap(String.valueOf(data).getBytes(ConfigConstants.DEFAULT_CHARSET))).withPartitionKey(UUID.randomUUID().toString()).withApproximateArrivalTimestamp(new Date(System.currentTimeMillis())).withSequenceNumber(String.valueOf(i)).         batch.add(record).         sumRecordBatchBytes += record.getData().remaining().     }     if (batch.size() != 0) {         averageRecordSizeBytes = sumRecordBatchBytes / batch.size().     }     return batch. }
false;private,static;1;5;;private static String createDataSize(long msgSize) {     char[] data = new char[(int) msgSize].     return new String(data). }
false;public;1;18;;@Override public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) {     GetShardListResult result = new GetShardListResult().     for (Map.Entry<String, List<StreamShardHandle>> streamsWithShards : streamsWithListOfShards.entrySet()) {         String streamName = streamsWithShards.getKey().         for (StreamShardHandle shard : streamsWithShards.getValue()) {             if (streamNamesWithLastSeenShardIds.get(streamName) == null) {                 result.addRetrievedShardToStream(streamName, shard).             } else {                 if (compareShardIds(shard.getShard().getShardId(), streamNamesWithLastSeenShardIds.get(streamName)) > 0) {                     result.addRetrievedShardToStream(streamName, shard).                 }             }         }     }     return result. }
false;public;3;4;;@Override public String getShardIterator(StreamShardHandle shard, String shardIteratorType, Object startingMarker) {     return null. }
false;public;2;4;;@Override public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) {     return null. }
true;private,static;2;12;/**  * Utility function to compare two shard ids.  *  * @param firstShardId first shard id to compare  * @param secondShardId second shard id to compare  * @return a value less than 0 if the first shard id is smaller than the second shard id,  *         or a value larger than 0 the first shard is larger than the second shard id,  *         or 0 if they are equal  */ ;/**  * Utility function to compare two shard ids.  *  * @param firstShardId first shard id to compare  * @param secondShardId second shard id to compare  * @return a value less than 0 if the first shard id is smaller than the second shard id,  *         or a value larger than 0 the first shard is larger than the second shard id,  *         or 0 if they are equal  */ private static int compareShardIds(String firstShardId, String secondShardId) {     if (!isValidShardId(firstShardId)) {         throw new IllegalArgumentException("The first shard id has invalid format.").     }     if (!isValidShardId(secondShardId)) {         throw new IllegalArgumentException("The second shard id has invalid format.").     }     // digit segment of the shard id starts at index 8     return Long.compare(Long.parseLong(firstShardId.substring(8)), Long.parseLong(secondShardId.substring(8))). }
true;private,static;1;6;/**  * Checks if a shard id has valid format.  * Kinesis stream shard ids have 12-digit numbers left-padded with 0's,  * prefixed with "shardId-", ex. "shardId-000000000015".  *  * @param shardId the shard id to check  * @return whether the shard id is valid  */ ;/**  * Checks if a shard id has valid format.  * Kinesis stream shard ids have 12-digit numbers left-padded with 0's,  * prefixed with "shardId-", ex. "shardId-000000000015".  *  * @param shardId the shard id to check  * @return whether the shard id is valid  */ private static boolean isValidShardId(String shardId) {     if (shardId == null) {         return false.     }     return shardId.matches("^shardId-\\d{12}"). }
false;private,static;1;3;;private static String getShardIterator(StreamShardHandle shardHandle) {     return shardHandle.getStreamName() + "-" + shardHandle.getShard().getShardId(). }
false;public;1;18;;@Override public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) {     GetShardListResult result = new GetShardListResult().     for (Map.Entry<String, List<StreamShardHandle>> streamsWithShards : streamsWithListOfShards.entrySet()) {         String streamName = streamsWithShards.getKey().         for (StreamShardHandle shard : streamsWithShards.getValue()) {             if (streamNamesWithLastSeenShardIds.get(streamName) == null) {                 result.addRetrievedShardToStream(streamName, shard).             } else {                 if (StreamShardHandle.compareShardIds(shard.getShard().getShardId(), streamNamesWithLastSeenShardIds.get(streamName)) > 0) {                     result.addRetrievedShardToStream(streamName, shard).                 }             }         }     }     return result. }
false;public;3;4;;@Override public String getShardIterator(StreamShardHandle shard, String shardIteratorType, Object startingMarker) {     return getShardIterator(shard). }
false;public;2;22;;@Override public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) {     BlockingQueue<String> queue = Preconditions.checkNotNull(this.shardIteratorToQueueMap.get(shardIterator), "no queue for iterator %s", shardIterator).     List<Record> records = Collections.emptyList().     try {         String data = queue.take().         Record record = new Record().withData(ByteBuffer.wrap(String.valueOf(data).getBytes(ConfigConstants.DEFAULT_CHARSET))).withPartitionKey(UUID.randomUUID().toString()).withApproximateArrivalTimestamp(new Date(System.currentTimeMillis())).withSequenceNumber(String.valueOf(0)).         records = Collections.singletonList(record).     } catch (InterruptedException e) {         shardIterator = null.     }     return new GetRecordsResult().withRecords(records).withMillisBehindLatest(0L).withNextShardIterator(shardIterator). }
