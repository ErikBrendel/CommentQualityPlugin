commented;modifiers;parameterAmount;loc;comment;code
false;protected;12;28;;@Override protected ElasticsearchUpsertTableSinkBase copy(boolean isAppendOnly, TableSchema schema, List<Host> hosts, String index, String docType, String keyDelimiter, String keyNullLiteral, SerializationSchema<Row> serializationSchema, XContentType contentType, ActionRequestFailureHandler failureHandler, Map<SinkOption, String> sinkOptions, RequestFactory requestFactory) {     return new Elasticsearch6UpsertTableSink(isAppendOnly, schema, hosts, index, docType, keyDelimiter, keyNullLiteral, serializationSchema, contentType, failureHandler, sinkOptions). }
false;protected;4;54;;@Override protected SinkFunction<Tuple2<Boolean, Row>> createSinkFunction(List<Host> hosts, ActionRequestFailureHandler failureHandler, Map<SinkOption, String> sinkOptions, ElasticsearchUpsertSinkFunction upsertSinkFunction) {     final List<HttpHost> httpHosts = hosts.stream().map((host) -> new HttpHost(host.hostname, host.port, host.protocol)).collect(Collectors.toList()).     final ElasticsearchSink.Builder<Tuple2<Boolean, Row>> builder = createBuilder(upsertSinkFunction, httpHosts).     builder.setFailureHandler(failureHandler).     Optional.ofNullable(sinkOptions.get(BULK_FLUSH_MAX_ACTIONS)).ifPresent(v -> builder.setBulkFlushMaxActions(Integer.valueOf(v))).     Optional.ofNullable(sinkOptions.get(BULK_FLUSH_MAX_SIZE)).ifPresent(v -> builder.setBulkFlushMaxSizeMb(MemorySize.parse(v).getMebiBytes())).     Optional.ofNullable(sinkOptions.get(BULK_FLUSH_INTERVAL)).ifPresent(v -> builder.setBulkFlushInterval(Long.valueOf(v))).     Optional.ofNullable(sinkOptions.get(BULK_FLUSH_BACKOFF_ENABLED)).ifPresent(v -> builder.setBulkFlushBackoff(Boolean.valueOf(v))).     Optional.ofNullable(sinkOptions.get(BULK_FLUSH_BACKOFF_TYPE)).ifPresent(v -> builder.setBulkFlushBackoffType(ElasticsearchSinkBase.FlushBackoffType.valueOf(v))).     Optional.ofNullable(sinkOptions.get(BULK_FLUSH_BACKOFF_RETRIES)).ifPresent(v -> builder.setBulkFlushBackoffRetries(Integer.valueOf(v))).     Optional.ofNullable(sinkOptions.get(BULK_FLUSH_BACKOFF_DELAY)).ifPresent(v -> builder.setBulkFlushBackoffDelay(Long.valueOf(v))).     builder.setRestClientFactory(new DefaultRestClientFactory(Optional.ofNullable(sinkOptions.get(REST_MAX_RETRY_TIMEOUT)).map(Integer::valueOf).orElse(null), sinkOptions.get(REST_PATH_PREFIX))).     final ElasticsearchSink<Tuple2<Boolean, Row>> sink = builder.build().     Optional.ofNullable(sinkOptions.get(DISABLE_FLUSH_ON_CHECKPOINT)).ifPresent(v -> {         if (Boolean.valueOf(v)) {             sink.disableFlushOnCheckpoint().         }     }).     return sink. }
false;;2;6;;@VisibleForTesting ElasticsearchSink.Builder<Tuple2<Boolean, Row>> createBuilder(ElasticsearchUpsertSinkFunction upsertSinkFunction, List<HttpHost> httpHosts) {     return new ElasticsearchSink.Builder<>(httpHosts, upsertSinkFunction). }
false;public;1;9;;@Override public void configureRestClientBuilder(RestClientBuilder restClientBuilder) {     if (maxRetryTimeout != null) {         restClientBuilder.setMaxRetryTimeoutMillis(maxRetryTimeout).     }     if (pathPrefix != null) {         restClientBuilder.setPathPrefix(pathPrefix).     } }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     DefaultRestClientFactory that = (DefaultRestClientFactory) o.     return Objects.equals(maxRetryTimeout, that.maxRetryTimeout) && Objects.equals(pathPrefix, that.pathPrefix). }
false;public;0;6;;@Override public int hashCode() {     return Objects.hash(maxRetryTimeout, pathPrefix). }
false;public;5;11;;@Override public UpdateRequest createUpdateRequest(String index, String docType, String key, XContentType contentType, byte[] document) {     return new UpdateRequest(index, docType, key).doc(document, contentType).upsert(document, contentType). }
false;public;4;9;;@Override public IndexRequest createIndexRequest(String index, String docType, XContentType contentType, byte[] document) {     return new IndexRequest(index, docType).source(document, contentType). }
false;public;3;4;;@Override public DeleteRequest createDeleteRequest(String index, String docType, String key) {     return new DeleteRequest(index, docType, key). }
