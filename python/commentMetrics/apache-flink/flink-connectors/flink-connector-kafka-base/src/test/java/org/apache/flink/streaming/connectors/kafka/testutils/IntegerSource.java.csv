commented;modifiers;parameterAmount;loc;comment;code
false;public;1;35;;@Override public void run(SourceContext<Integer> ctx) throws Exception {     // each source subtask emits only the numbers where (num % parallelism == subtask_index)     final int stepSize = getRuntimeContext().getNumberOfParallelSubtasks().     int current = this.currentPosition >= 0 ? this.currentPosition : getRuntimeContext().getIndexOfThisSubtask().     while (this.running && current < this.numEventsTotal) {         // emit the next element         synchronized (ctx.getCheckpointLock()) {             ctx.collect(current).             current += stepSize.             this.currentPosition = current.         }         // give some time to trigger checkpoint while we are not holding the lock (to prevent starvation)         if (!restored && current % 10 == 0) {             Thread.sleep(1).         }     }     // after we are done, we need to wait for two more checkpoint to complete     // before finishing the program - that is to be on the safe side that     // the sink also got the "commit" notification for all relevant checkpoints     // and committed the data     final long lastCheckpoint.     synchronized (ctx.getCheckpointLock()) {         lastCheckpoint = this.lastCheckpointTriggered.     }     synchronized (this.blocker) {         while (this.lastCheckpointConfirmed <= lastCheckpoint + 1) {             this.blocker.wait().         }     } }
false;public;0;4;;@Override public void cancel() {     this.running = false. }
false;public;2;6;;@Override public List<Integer> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {     this.lastCheckpointTriggered = checkpointId.     return Collections.singletonList(this.currentPosition). }
false;public;1;9;;@Override public void restoreState(List<Integer> state) throws Exception {     this.currentPosition = state.get(0).     // at least one checkpoint must have happened so far     this.lastCheckpointTriggered = 1L.     this.lastCheckpointConfirmed = 1L.     this.restored = true. }
false;public;1;7;;@Override public void notifyCheckpointComplete(long checkpointId) throws Exception {     synchronized (blocker) {         this.lastCheckpointConfirmed = checkpointId.         blocker.notifyAll().     } }
