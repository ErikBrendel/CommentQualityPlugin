commented;modifiers;parameterAmount;loc;comment;code
true;public;0;8;/**  * Gets the number of elements currently in the queue.  * @return The number of elements currently in the queue.  */ ;// ------------------------------------------------------------------------ // Size and status // ------------------------------------------------------------------------ /**  * Gets the number of elements currently in the queue.  * @return The number of elements currently in the queue.  */ public int size() {     lock.lock().     try {         return elements.size().     } finally {         lock.unlock().     } }
true;public;0;3;/**  * Checks whether the queue is empty (has no elements).  * @return True, if the queue is empty. false, if it is non-empty.  */ ;/**  * Checks whether the queue is empty (has no elements).  * @return True, if the queue is empty. false, if it is non-empty.  */ public boolean isEmpty() {     return size() == 0. }
true;public;0;3;/**  * Checks whether the queue is currently open, meaning elements can be added and polled.  * @return True, if the queue is open. false, if it is closed.  */ ;/**  * Checks whether the queue is currently open, meaning elements can be added and polled.  * @return True, if the queue is open. false, if it is closed.  */ public boolean isOpen() {     return open. }
true;public;0;20;/**  * Tries to close the queue. Closing the queue only succeeds when no elements are  * in the queue when this method is called. Checking whether the queue is empty, and  * marking the queue as closed is one atomic operation.  *  * @return True, if the queue is closed, false if the queue remains open.  */ ;/**  * Tries to close the queue. Closing the queue only succeeds when no elements are  * in the queue when this method is called. Checking whether the queue is empty, and  * marking the queue as closed is one atomic operation.  *  * @return True, if the queue is closed, false if the queue remains open.  */ public boolean close() {     lock.lock().     try {         if (open) {             if (elements.isEmpty()) {                 open = false.                 nonEmpty.signalAll().                 return true.             } else {                 return false.             }         } else {             // already closed             return true.         }     } finally {         lock.unlock().     } }
true;public;1;16;/**  * Tries to add an element to the queue, if the queue is still open. Checking whether the queue  * is open and adding the element is one atomic operation.  *  * <p>Unlike the {@link #add(Object)} method, this method never throws an exception,  * but only indicates via the return code if the element was added or the  * queue was closed.  *  * @param element The element to add.  * @return True, if the element was added, false if the queue was closes.  */ ;// ------------------------------------------------------------------------ // Adding / Removing elements // ------------------------------------------------------------------------ /**  * Tries to add an element to the queue, if the queue is still open. Checking whether the queue  * is open and adding the element is one atomic operation.  *  * <p>Unlike the {@link #add(Object)} method, this method never throws an exception,  * but only indicates via the return code if the element was added or the  * queue was closed.  *  * @param element The element to add.  * @return True, if the element was added, false if the queue was closes.  */ public boolean addIfOpen(E element) {     requireNonNull(element).     lock.lock().     try {         if (open) {             elements.addLast(element).             if (elements.size() == 1) {                 nonEmpty.signalAll().             }         }         return open.     } finally {         lock.unlock().     } }
true;public;1;17;/**  * Adds the element to the queue, or fails with an exception, if the queue is closed.  * Checking whether the queue is open and adding the element is one atomic operation.  *  * @param element The element to add.  * @throws IllegalStateException Thrown, if the queue is closed.  */ ;/**  * Adds the element to the queue, or fails with an exception, if the queue is closed.  * Checking whether the queue is open and adding the element is one atomic operation.  *  * @param element The element to add.  * @throws IllegalStateException Thrown, if the queue is closed.  */ public void add(E element) throws IllegalStateException {     requireNonNull(element).     lock.lock().     try {         if (open) {             elements.addLast(element).             if (elements.size() == 1) {                 nonEmpty.signalAll().             }         } else {             throw new IllegalStateException("queue is closed").         }     } finally {         lock.unlock().     } }
true;public;0;16;/**  * Returns the queue's next element without removing it, if the queue is non-empty.  * Otherwise, returns null.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and getting the next element is one atomic operation.  *  * <p>This method never blocks.  *  * @return The queue's next element, or null, if the queue is empty.  * @throws IllegalStateException Thrown, if the queue is closed.  */ ;/**  * Returns the queue's next element without removing it, if the queue is non-empty.  * Otherwise, returns null.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and getting the next element is one atomic operation.  *  * <p>This method never blocks.  *  * @return The queue's next element, or null, if the queue is empty.  * @throws IllegalStateException Thrown, if the queue is closed.  */ public E peek() {     lock.lock().     try {         if (open) {             if (elements.size() > 0) {                 return elements.getFirst().             } else {                 return null.             }         } else {             throw new IllegalStateException("queue is closed").         }     } finally {         lock.unlock().     } }
true;public;0;16;/**  * Returns the queue's next element and removes it, the queue is non-empty.  * Otherwise, this method returns null.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * <p>This method never blocks.  *  * @return The queue's next element, or null, if the queue is empty.  * @throws IllegalStateException Thrown, if the queue is closed.  */ ;/**  * Returns the queue's next element and removes it, the queue is non-empty.  * Otherwise, this method returns null.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * <p>This method never blocks.  *  * @return The queue's next element, or null, if the queue is empty.  * @throws IllegalStateException Thrown, if the queue is closed.  */ public E poll() {     lock.lock().     try {         if (open) {             if (elements.size() > 0) {                 return elements.removeFirst().             } else {                 return null.             }         } else {             throw new IllegalStateException("queue is closed").         }     } finally {         lock.unlock().     } }
true;public;0;18;/**  * Returns all of the queue's current elements in a list, if the queue is non-empty.  * Otherwise, this method returns null.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the elements is one atomic operation.  *  * <p>This method never blocks.  *  * @return All of the queue's elements, or null, if the queue is empty.  * @throws IllegalStateException Thrown, if the queue is closed.  */ ;/**  * Returns all of the queue's current elements in a list, if the queue is non-empty.  * Otherwise, this method returns null.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the elements is one atomic operation.  *  * <p>This method never blocks.  *  * @return All of the queue's elements, or null, if the queue is empty.  * @throws IllegalStateException Thrown, if the queue is closed.  */ public List<E> pollBatch() {     lock.lock().     try {         if (open) {             if (elements.size() > 0) {                 ArrayList<E> result = new ArrayList<>(elements).                 elements.clear().                 return result.             } else {                 return null.             }         } else {             throw new IllegalStateException("queue is closed").         }     } finally {         lock.unlock().     } }
true;public;0;16;/**  * Returns the next element in the queue. If the queue is empty, this method  * waits until at least one element is added.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * @return The next element in the queue, never null.  *  * @throws IllegalStateException Thrown, if the queue is closed.  * @throws InterruptedException Throw, if the thread is interrupted while waiting for an  *                              element to be added.  */ ;/**  * Returns the next element in the queue. If the queue is empty, this method  * waits until at least one element is added.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * @return The next element in the queue, never null.  *  * @throws IllegalStateException Thrown, if the queue is closed.  * @throws InterruptedException Throw, if the thread is interrupted while waiting for an  *                              element to be added.  */ public E getElementBlocking() throws InterruptedException {     lock.lock().     try {         while (open && elements.isEmpty()) {             nonEmpty.await().         }         if (open) {             return elements.removeFirst().         } else {             throw new IllegalStateException("queue is closed").         }     } finally {         lock.unlock().     } }
true;public;1;29;/**  * Returns the next element in the queue. If the queue is empty, this method  * waits at most a certain time until an element becomes available. If no element  * is available after that time, the method returns null.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * @param timeoutMillis The number of milliseconds to block, at most.  * @return The next element in the queue, or null, if the timeout expires  before an element is available.  *  * @throws IllegalStateException Thrown, if the queue is closed.  * @throws InterruptedException Throw, if the thread is interrupted while waiting for an  *                              element to be added.  */ ;/**  * Returns the next element in the queue. If the queue is empty, this method  * waits at most a certain time until an element becomes available. If no element  * is available after that time, the method returns null.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * @param timeoutMillis The number of milliseconds to block, at most.  * @return The next element in the queue, or null, if the timeout expires  before an element is available.  *  * @throws IllegalStateException Thrown, if the queue is closed.  * @throws InterruptedException Throw, if the thread is interrupted while waiting for an  *                              element to be added.  */ public E getElementBlocking(long timeoutMillis) throws InterruptedException {     if (timeoutMillis == 0L) {         // wait forever case         return getElementBlocking().     } else if (timeoutMillis < 0L) {         throw new IllegalArgumentException("invalid timeout").     }     final long deadline = System.nanoTime() + timeoutMillis * 1_000_000L.     lock.lock().     try {         while (open && elements.isEmpty() && timeoutMillis > 0) {             nonEmpty.await(timeoutMillis, TimeUnit.MILLISECONDS).             timeoutMillis = (deadline - System.nanoTime()) / 1_000_000L.         }         if (!open) {             throw new IllegalStateException("queue is closed").         } else if (elements.isEmpty()) {             return null.         } else {             return elements.removeFirst().         }     } finally {         lock.unlock().     } }
true;public;0;17;/**  * Gets all the elements found in the list, or blocks until at least one element  * was added. If the queue is empty when this method is called, it blocks until  * at least one element is added.  *  * <p>This method always returns a list with at least one element.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * @return A list with all elements in the queue, always at least one element.  *  * @throws IllegalStateException Thrown, if the queue is closed.  * @throws InterruptedException Throw, if the thread is interrupted while waiting for an  *                              element to be added.  */ ;/**  * Gets all the elements found in the list, or blocks until at least one element  * was added. If the queue is empty when this method is called, it blocks until  * at least one element is added.  *  * <p>This method always returns a list with at least one element.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * @return A list with all elements in the queue, always at least one element.  *  * @throws IllegalStateException Thrown, if the queue is closed.  * @throws InterruptedException Throw, if the thread is interrupted while waiting for an  *                              element to be added.  */ public List<E> getBatchBlocking() throws InterruptedException {     lock.lock().     try {         while (open && elements.isEmpty()) {             nonEmpty.await().         }         if (open) {             ArrayList<E> result = new ArrayList<>(elements).             elements.clear().             return result.         } else {             throw new IllegalStateException("queue is closed").         }     } finally {         lock.unlock().     } }
true;public;1;32;/**  * Gets all the elements found in the list, or blocks until at least one element  * was added. This method is similar as {@link #getBatchBlocking()}, but takes  * a number of milliseconds that the method will maximally wait before returning.  *  * <p>This method never returns null, but an empty list, if the queue is empty when  * the method is called and the request times out before an element was added.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * @param timeoutMillis The number of milliseconds to wait, at most.  * @return A list with all elements in the queue, possible an empty list.  *  * @throws IllegalStateException Thrown, if the queue is closed.  * @throws InterruptedException Throw, if the thread is interrupted while waiting for an  *                              element to be added.  */ ;/**  * Gets all the elements found in the list, or blocks until at least one element  * was added. This method is similar as {@link #getBatchBlocking()}, but takes  * a number of milliseconds that the method will maximally wait before returning.  *  * <p>This method never returns null, but an empty list, if the queue is empty when  * the method is called and the request times out before an element was added.  *  * <p>The method throws an {@code IllegalStateException} if the queue is closed.  * Checking whether the queue is open and removing the next element is one atomic operation.  *  * @param timeoutMillis The number of milliseconds to wait, at most.  * @return A list with all elements in the queue, possible an empty list.  *  * @throws IllegalStateException Thrown, if the queue is closed.  * @throws InterruptedException Throw, if the thread is interrupted while waiting for an  *                              element to be added.  */ public List<E> getBatchBlocking(long timeoutMillis) throws InterruptedException {     if (timeoutMillis == 0L) {         // wait forever case         return getBatchBlocking().     } else if (timeoutMillis < 0L) {         throw new IllegalArgumentException("invalid timeout").     }     final long deadline = System.nanoTime() + timeoutMillis * 1_000_000L.     lock.lock().     try {         while (open && elements.isEmpty() && timeoutMillis > 0) {             nonEmpty.await(timeoutMillis, TimeUnit.MILLISECONDS).             timeoutMillis = (deadline - System.nanoTime()) / 1_000_000L.         }         if (!open) {             throw new IllegalStateException("queue is closed").         } else if (elements.isEmpty()) {             return Collections.emptyList().         } else {             ArrayList<E> result = new ArrayList<>(elements).             elements.clear().             return result.         }     } finally {         lock.unlock().     } }
false;public;0;8;;// ------------------------------------------------------------------------ // Standard Utilities // ------------------------------------------------------------------------ @Override public int hashCode() {     int hashCode = 17.     for (E element : elements) {         hashCode = 31 * hashCode + element.hashCode().     }     return hashCode. }
false;public;1;24;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     } else if (obj != null && obj.getClass() == ClosableBlockingQueue.class) {         @SuppressWarnings("unchecked")         ClosableBlockingQueue<E> that = (ClosableBlockingQueue<E>) obj.         if (this.elements.size() == that.elements.size()) {             Iterator<E> thisElements = this.elements.iterator().             for (E thatNext : that.elements) {                 E thisNext = thisElements.next().                 if (!(thisNext == null ? thatNext == null : thisNext.equals(thatNext))) {                     return false.                 }             }             return true.         } else {             return false.         }     } else {         return false.     } }
false;public;0;4;;@Override public String toString() {     return elements.toString(). }
