commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Opens the partition discoverer, initializing all required Kafka connections.  *  * <p>NOTE: thread-safety is not guaranteed.  */ ;/**  * Opens the partition discoverer, initializing all required Kafka connections.  *  * <p>NOTE: thread-safety is not guaranteed.  */ public void open() throws Exception {     closed = false.     initializeConnections(). }
true;public;0;4;/**  * Closes the partition discoverer, cleaning up all Kafka connections.  *  * <p>NOTE: thread-safety is not guaranteed.  */ ;/**  * Closes the partition discoverer, cleaning up all Kafka connections.  *  * <p>NOTE: thread-safety is not guaranteed.  */ public void close() throws Exception {     closed = true.     closeConnections(). }
true;public;0;4;/**  * Interrupt an in-progress discovery attempt by throwing a {@link WakeupException}.  * If no attempt is in progress, the immediate next attempt will throw a {@link WakeupException}.  *  * <p>This method can be called concurrently from a different thread.  */ ;/**  * Interrupt an in-progress discovery attempt by throwing a {@link WakeupException}.  * If no attempt is in progress, the immediate next attempt will throw a {@link WakeupException}.  *  * <p>This method can be called concurrently from a different thread.  */ public void wakeup() {     wakeup = true.     wakeupConnections(). }
true;public;0;56;/**  * Execute a partition discovery attempt for this subtask.  * This method lets the partition discoverer update what partitions it has discovered so far.  *  * @return List of discovered new partitions that this subtask should subscribe to.  */ ;/**  * Execute a partition discovery attempt for this subtask.  * This method lets the partition discoverer update what partitions it has discovered so far.  *  * @return List of discovered new partitions that this subtask should subscribe to.  */ public List<KafkaTopicPartition> discoverPartitions() throws WakeupException, ClosedException {     if (!closed && !wakeup) {         try {             List<KafkaTopicPartition> newDiscoveredPartitions.             // (1) get all possible partitions, based on whether we are subscribed to fixed topics or a topic pattern             if (topicsDescriptor.isFixedTopics()) {                 newDiscoveredPartitions = getAllPartitionsForTopics(topicsDescriptor.getFixedTopics()).             } else {                 List<String> matchedTopics = getAllTopics().                 // retain topics that match the pattern                 Iterator<String> iter = matchedTopics.iterator().                 while (iter.hasNext()) {                     if (!topicsDescriptor.isMatchingTopic(iter.next())) {                         iter.remove().                     }                 }                 if (matchedTopics.size() != 0) {                     // get partitions only for matched topics                     newDiscoveredPartitions = getAllPartitionsForTopics(matchedTopics).                 } else {                     newDiscoveredPartitions = null.                 }             }             // (2) eliminate partition that are old partitions or should not be subscribed by this subtask             if (newDiscoveredPartitions == null || newDiscoveredPartitions.isEmpty()) {                 throw new RuntimeException("Unable to retrieve any partitions with KafkaTopicsDescriptor: " + topicsDescriptor).             } else {                 Iterator<KafkaTopicPartition> iter = newDiscoveredPartitions.iterator().                 KafkaTopicPartition nextPartition.                 while (iter.hasNext()) {                     nextPartition = iter.next().                     if (!setAndCheckDiscoveredPartition(nextPartition)) {                         iter.remove().                     }                 }             }             return newDiscoveredPartitions.         } catch (WakeupException e) {             // the actual topic / partition metadata fetching methods             // may be woken up midway. reset the wakeup flag and rethrow             wakeup = false.             throw e.         }     } else if (!closed && wakeup) {         // may have been woken up before the method call         wakeup = false.         throw new WakeupException().     } else {         throw new ClosedException().     } }
true;public;1;9;/**  * Sets a partition as discovered. Partitions are considered as new  * if its partition id is larger than all partition ids previously  * seen for the topic it belongs to. Therefore, for a set of  * discovered partitions, the order that this method is invoked with  * each partition is important.  *  * <p>If the partition is indeed newly discovered, this method also returns  * whether the new partition should be subscribed by this subtask.  *  * @param partition the partition to set and check  *  * @return {@code true}, if the partition wasn't seen before and should  *         be subscribed by this subtask. {@code false} otherwise  */ ;/**  * Sets a partition as discovered. Partitions are considered as new  * if its partition id is larger than all partition ids previously  * seen for the topic it belongs to. Therefore, for a set of  * discovered partitions, the order that this method is invoked with  * each partition is important.  *  * <p>If the partition is indeed newly discovered, this method also returns  * whether the new partition should be subscribed by this subtask.  *  * @param partition the partition to set and check  *  * @return {@code true}, if the partition wasn't seen before and should  *         be subscribed by this subtask. {@code false} otherwise  */ public boolean setAndCheckDiscoveredPartition(KafkaTopicPartition partition) {     if (isUndiscoveredPartition(partition)) {         discoveredPartitions.add(partition).         return KafkaTopicPartitionAssigner.assign(partition, numParallelSubtasks) == indexOfThisSubtask.     }     return false. }
true;protected,abstract;0;1;/**  * Establish the required connections in order to fetch topics and partitions metadata.  */ ;// ------------------------------------------------------------------------ // Kafka version specifics // ------------------------------------------------------------------------ /**  * Establish the required connections in order to fetch topics and partitions metadata.  */ protected abstract void initializeConnections() throws Exception.
true;protected,abstract;0;1;/**  * Attempt to eagerly wakeup from blocking calls to Kafka in {@link AbstractPartitionDiscoverer#getAllTopics()}  * and {@link AbstractPartitionDiscoverer#getAllPartitionsForTopics(List)}.  *  * <p>If the invocation indeed results in interrupting an actual blocking Kafka call, the implementations  * of {@link AbstractPartitionDiscoverer#getAllTopics()} and  * {@link AbstractPartitionDiscoverer#getAllPartitionsForTopics(List)} are responsible of throwing a  * {@link WakeupException}.  */ ;/**  * Attempt to eagerly wakeup from blocking calls to Kafka in {@link AbstractPartitionDiscoverer#getAllTopics()}  * and {@link AbstractPartitionDiscoverer#getAllPartitionsForTopics(List)}.  *  * <p>If the invocation indeed results in interrupting an actual blocking Kafka call, the implementations  * of {@link AbstractPartitionDiscoverer#getAllTopics()} and  * {@link AbstractPartitionDiscoverer#getAllPartitionsForTopics(List)} are responsible of throwing a  * {@link WakeupException}.  */ protected abstract void wakeupConnections().
true;protected,abstract;0;1;/**  * Close all established connections.  */ ;/**  * Close all established connections.  */ protected abstract void closeConnections() throws Exception.
true;protected,abstract;0;1;/**  * Fetch the list of all topics from Kafka.  */ ;/**  * Fetch the list of all topics from Kafka.  */ protected abstract List<String> getAllTopics() throws WakeupException.
true;protected,abstract;1;1;/**  * Fetch the list of all partitions for a specific topics list from Kafka.  */ ;/**  * Fetch the list of all partitions for a specific topics list from Kafka.  */ protected abstract List<KafkaTopicPartition> getAllPartitionsForTopics(List<String> topics) throws WakeupException.
false;private;1;3;;private boolean isUndiscoveredPartition(KafkaTopicPartition partition) {     return !discoveredPartitions.contains(partition). }
