commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;4;5;/**  * Returns the version-specific Kafka producer.  *  * @param topic               Kafka topic to produce to.  * @param properties          Properties for the Kafka producer.  * @param serializationSchema Serialization schema to use to create Kafka records.  * @param partitioner         Partitioner to select Kafka partition.  * @return The version-specific Kafka producer  */ ;/**  * Returns the version-specific Kafka producer.  *  * @param topic               Kafka topic to produce to.  * @param properties          Properties for the Kafka producer.  * @param serializationSchema Serialization schema to use to create Kafka records.  * @param partitioner         Partitioner to select Kafka partition.  * @return The version-specific Kafka producer  */ protected abstract SinkFunction<Row> createKafkaProducer(String topic, Properties properties, SerializationSchema<Row> serializationSchema, Optional<FlinkKafkaPartitioner<Row>> partitioner).
false;public;1;9;;@Override public void emitDataStream(DataStream<Row> dataStream) {     final SinkFunction<Row> kafkaProducer = createKafkaProducer(topic, properties, serializationSchema, partitioner).     dataStream.addSink(kafkaProducer).name(TableConnectorUtils.generateRuntimeName(this.getClass(), getFieldNames())). }
false;public;0;4;;@Override public TypeInformation<Row> getOutputType() {     return schema.toRowType(). }
false;public;0;4;;@Override public String[] getFieldNames() {     return schema.getFieldNames(). }
false;public;0;4;;@Override public TypeInformation<?>[] getFieldTypes() {     return schema.getFieldTypes(). }
false;public;2;9;;@Override public KafkaTableSinkBase configure(String[] fieldNames, TypeInformation<?>[] fieldTypes) {     if (!Arrays.equals(getFieldNames(), fieldNames) || !Arrays.equals(getFieldTypes(), fieldTypes)) {         throw new ValidationException("Reconfiguration with different fields is not allowed. " + "Expected: " + Arrays.toString(getFieldNames()) + " / " + Arrays.toString(getFieldTypes()) + ". " + "But was: " + Arrays.toString(fieldNames) + " / " + Arrays.toString(fieldTypes)).     }     return this. }
false;public;1;15;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     final KafkaTableSinkBase that = (KafkaTableSinkBase) o.     return Objects.equals(schema, that.schema) && Objects.equals(topic, that.topic) && Objects.equals(properties, that.properties) && Objects.equals(serializationSchema, that.serializationSchema) && Objects.equals(partitioner, that.partitioner). }
false;public;0;9;;@Override public int hashCode() {     return Objects.hash(schema, topic, properties, serializationSchema, partitioner). }
