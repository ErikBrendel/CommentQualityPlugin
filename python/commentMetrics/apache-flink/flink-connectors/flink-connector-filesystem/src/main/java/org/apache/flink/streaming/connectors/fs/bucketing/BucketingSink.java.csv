# id;timestamp;commentText;codeText;commentWords;codeWords
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1480685315;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1484304405;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1484304405;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1493821557;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1494937633;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1495923089;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1503598628;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1507304600;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1511347989;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1511532265;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1516813396;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1519115515;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1519913093;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1524138809;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1525709672;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1526068396;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1531134089;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1531303510;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1531676690;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1533641721;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1536238633;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(Configuration config);1549286603;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(Configuration config) {_		this.fsConfig = new Configuration()__		fsConfig.addAll(config)__		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,configuration,config,this,fs,config,new,configuration,fs,config,add,all,config,return,this
BucketingSink -> private void closePartFilesByTime(long currentProcessingTime) throws Exception;1526068396;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. Buckets are also closed if they are_older than {@code batchRolloverInterval} ms. This enables in-progress files to be moved to the pending state_and be finalised on the next checkpoint.;private void closePartFilesByTime(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if ((entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold)_						|| (entry.getValue().creationTime < currentProcessingTime - batchRolloverInterval)) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,buckets,are,also,closed,if,they,are,older,than,code,batch,rollover,interval,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,close,part,files,by,time,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,entry,get,value,creation,time,current,processing,time,batch,rollover,interval,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void closePartFilesByTime(long currentProcessingTime) throws Exception;1531134089;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. Buckets are also closed if they are_older than {@code batchRolloverInterval} ms. This enables in-progress files to be moved to the pending state_and be finalised on the next checkpoint.;private void closePartFilesByTime(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if ((entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold)_						|| (entry.getValue().creationTime < currentProcessingTime - batchRolloverInterval)) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,buckets,are,also,closed,if,they,are,older,than,code,batch,rollover,interval,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,close,part,files,by,time,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,entry,get,value,creation,time,current,processing,time,batch,rollover,interval,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void closePartFilesByTime(long currentProcessingTime) throws Exception;1531303510;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. Buckets are also closed if they are_older than {@code batchRolloverInterval} ms. This enables in-progress files to be moved to the pending state_and be finalised on the next checkpoint.;private void closePartFilesByTime(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if ((entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold)_						|| (entry.getValue().creationTime < currentProcessingTime - batchRolloverInterval)) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,buckets,are,also,closed,if,they,are,older,than,code,batch,rollover,interval,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,close,part,files,by,time,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,entry,get,value,creation,time,current,processing,time,batch,rollover,interval,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void closePartFilesByTime(long currentProcessingTime) throws Exception;1531676690;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. Buckets are also closed if they are_older than {@code batchRolloverInterval} ms. This enables in-progress files to be moved to the pending state_and be finalised on the next checkpoint.;private void closePartFilesByTime(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if ((entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold)_						|| (entry.getValue().creationTime < currentProcessingTime - batchRolloverInterval)) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,buckets,are,also,closed,if,they,are,older,than,code,batch,rollover,interval,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,close,part,files,by,time,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,entry,get,value,creation,time,current,processing,time,batch,rollover,interval,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void closePartFilesByTime(long currentProcessingTime) throws Exception;1533641721;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. Buckets are also closed if they are_older than {@code batchRolloverInterval} ms. This enables in-progress files to be moved to the pending state_and be finalised on the next checkpoint.;private void closePartFilesByTime(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if ((entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold)_						|| (entry.getValue().creationTime < currentProcessingTime - batchRolloverInterval)) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,buckets,are,also,closed,if,they,are,older,than,code,batch,rollover,interval,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,close,part,files,by,time,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,entry,get,value,creation,time,current,processing,time,batch,rollover,interval,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void closePartFilesByTime(long currentProcessingTime) throws Exception;1536238633;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. Buckets are also closed if they are_older than {@code batchRolloverInterval} ms. This enables in-progress files to be moved to the pending state_and be finalised on the next checkpoint.;private void closePartFilesByTime(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if ((entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold)_						|| (entry.getValue().creationTime < currentProcessingTime - batchRolloverInterval)) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,buckets,are,also,closed,if,they,are,older,than,code,batch,rollover,interval,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,close,part,files,by,time,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,entry,get,value,creation,time,current,processing,time,batch,rollover,interval,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void closePartFilesByTime(long currentProcessingTime) throws Exception;1549286603;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. Buckets are also closed if they are_older than {@code batchRolloverInterval} ms. This enables in-progress files to be moved to the pending state_and be finalised on the next checkpoint.;private void closePartFilesByTime(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if ((entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold)_						|| (entry.getValue().creationTime < currentProcessingTime - batchRolloverInterval)) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,buckets,are,also,closed,if,they,are,older,than,code,batch,rollover,interval,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,close,part,files,by,time,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,entry,get,value,creation,time,current,processing,time,batch,rollover,interval,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1480685315;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1484304405;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1484304405;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1493821557;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1494937633;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1495923089;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1503598628;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1507304600;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1511347989;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1511532265;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1516813396;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1519115515;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1519913093;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1524138809;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1525709672;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1526068396;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1531134089;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1531303510;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1531676690;Sets the suffix of in-progress part files. The default is {@code "in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1533641721;Sets the suffix of in-progress part files. The default is {@code ".in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1536238633;Sets the suffix of in-progress part files. The default is {@code ".in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> public BucketingSink<T> setInProgressSuffix(String inProgressSuffix);1549286603;Sets the suffix of in-progress part files. The default is {@code ".in-progress"}.;public BucketingSink<T> setInProgressSuffix(String inProgressSuffix) {_		this.inProgressSuffix = inProgressSuffix__		return this__	};sets,the,suffix,of,in,progress,part,files,the,default,is,code,in,progress;public,bucketing,sink,t,set,in,progress,suffix,string,in,progress,suffix,this,in,progress,suffix,in,progress,suffix,return,this
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1480685315;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1484304405;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1484304405;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1493821557;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1494937633;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1495923089;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1503598628;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1507304600;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1511347989;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1511532265;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1516813396;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1519115515;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1519913093;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1524138809;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void checkForInactiveBuckets(long currentProcessingTime) throws Exception;1525709672;Checks for inactive buckets, and closes them. Buckets are considered inactive if they have not been_written to for a period greater than {@code inactiveBucketThreshold} ms. This enables in-progress_files to be moved to the pending state and be finalised on the next checkpoint.;private void checkForInactiveBuckets(long currentProcessingTime) throws Exception {__		synchronized (state.bucketStates) {_			for (Map.Entry<String, BucketState<T>> entry : state.bucketStates.entrySet()) {_				if (entry.getValue().lastWrittenToTime < currentProcessingTime - inactiveBucketThreshold) {_					LOG.debug("BucketingSink {} closing bucket due to inactivity of over {} ms.",_						getRuntimeContext().getIndexOfThisSubtask(), inactiveBucketThreshold)__					closeCurrentPartFile(entry.getValue())__				}_			}_		}_	};checks,for,inactive,buckets,and,closes,them,buckets,are,considered,inactive,if,they,have,not,been,written,to,for,a,period,greater,than,code,inactive,bucket,threshold,ms,this,enables,in,progress,files,to,be,moved,to,the,pending,state,and,be,finalised,on,the,next,checkpoint;private,void,check,for,inactive,buckets,long,current,processing,time,throws,exception,synchronized,state,bucket,states,for,map,entry,string,bucket,state,t,entry,state,bucket,states,entry,set,if,entry,get,value,last,written,to,time,current,processing,time,inactive,bucket,threshold,log,debug,bucketing,sink,closing,bucket,due,to,inactivity,of,over,ms,get,runtime,context,get,index,of,this,subtask,inactive,bucket,threshold,close,current,part,file,entry,get,value
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1480685315;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1484304405;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1484304405;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1493821557;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1494937633;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1495923089;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1503598628;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1507304600;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1511347989;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1511532265;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1516813396;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1519115515;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1519913093;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		if (partSuffix != null) {_			partPath = partPath.suffix(partSuffix)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,if,part,suffix,null,part,path,part,path,suffix,part,suffix,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1524138809;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		if (partSuffix != null) {_			partPath = partPath.suffix(partSuffix)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,if,part,suffix,null,part,path,part,path,suffix,part,suffix,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1525709672;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		if (partSuffix != null) {_			partPath = partPath.suffix(partSuffix)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__			if (bucketState.writer == null) {_				throw new UnsupportedOperationException(_					"Could not duplicate writer. " +_						"Class '" + writerTemplate.getClass().getCanonicalName() + "' must implement the 'Writer.duplicate()' method."_				)__			}_		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,if,part,suffix,null,part,path,part,path,suffix,part,suffix,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,if,bucket,state,writer,null,throw,new,unsupported,operation,exception,could,not,duplicate,writer,class,writer,template,get,class,get,canonical,name,must,implement,the,writer,duplicate,method,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1526068396;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = new Path(bucketPath, partPrefix + "-" + subtaskIndex + "-" + bucketState.partCounter)__		}__		_		bucketState.creationTime = processingTimeService.getCurrentProcessingTime()___		if (partSuffix != null) {_			partPath = partPath.suffix(partSuffix)__		}__		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__			if (bucketState.writer == null) {_				throw new UnsupportedOperationException(_					"Could not duplicate writer. " +_						"Class '" + writerTemplate.getClass().getCanonicalName() + "' must implement the 'Writer.duplicate()' method."_				)__			}_		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,new,path,bucket,path,part,prefix,subtask,index,bucket,state,part,counter,bucket,state,creation,time,processing,time,service,get,current,processing,time,if,part,suffix,null,part,path,part,path,suffix,part,suffix,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,if,bucket,state,writer,null,throw,new,unsupported,operation,exception,could,not,duplicate,writer,class,writer,template,get,class,get,canonical,name,must,implement,the,writer,duplicate,method,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1531134089;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		}__		_		bucketState.creationTime = processingTimeService.getCurrentProcessingTime()___		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__			if (bucketState.writer == null) {_				throw new UnsupportedOperationException(_					"Could not duplicate writer. " +_						"Class '" + writerTemplate.getClass().getCanonicalName() + "' must implement the 'Writer.duplicate()' method."_				)__			}_		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,bucket,state,creation,time,processing,time,service,get,current,processing,time,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,if,bucket,state,writer,null,throw,new,unsupported,operation,exception,could,not,duplicate,writer,class,writer,template,get,class,get,canonical,name,must,implement,the,writer,duplicate,method,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1531303510;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		}__		_		bucketState.creationTime = processingTimeService.getCurrentProcessingTime()___		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__			if (bucketState.writer == null) {_				throw new UnsupportedOperationException(_					"Could not duplicate writer. " +_						"Class '" + writerTemplate.getClass().getCanonicalName() + "' must implement the 'Writer.duplicate()' method."_				)__			}_		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,bucket,state,creation,time,processing,time,service,get,current,processing,time,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,if,bucket,state,writer,null,throw,new,unsupported,operation,exception,could,not,duplicate,writer,class,writer,template,get,class,get,canonical,name,must,implement,the,writer,duplicate,method,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1531676690;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		}__		_		bucketState.creationTime = processingTimeService.getCurrentProcessingTime()___		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__			if (bucketState.writer == null) {_				throw new UnsupportedOperationException(_					"Could not duplicate writer. " +_						"Class '" + writerTemplate.getClass().getCanonicalName() + "' must implement the 'Writer.duplicate()' method."_				)__			}_		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,bucket,state,creation,time,processing,time,service,get,current,processing,time,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,if,bucket,state,writer,null,throw,new,unsupported,operation,exception,could,not,duplicate,writer,class,writer,template,get,class,get,canonical,name,must,implement,the,writer,duplicate,method,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1533641721;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		}__		_		bucketState.creationTime = processingTimeService.getCurrentProcessingTime()___		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__			if (bucketState.writer == null) {_				throw new UnsupportedOperationException(_					"Could not duplicate writer. " +_						"Class '" + writerTemplate.getClass().getCanonicalName() + "' must implement the 'Writer.duplicate()' method."_				)__			}_		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,bucket,state,creation,time,processing,time,service,get,current,processing,time,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,if,bucket,state,writer,null,throw,new,unsupported,operation,exception,could,not,duplicate,writer,class,writer,template,get,class,get,canonical,name,must,implement,the,writer,duplicate,method,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1536238633;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		}__		_		bucketState.creationTime = processingTimeService.getCurrentProcessingTime()___		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__			if (bucketState.writer == null) {_				throw new UnsupportedOperationException(_					"Could not duplicate writer. " +_						"Class '" + writerTemplate.getClass().getCanonicalName() + "' must implement the 'Writer.duplicate()' method."_				)__			}_		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,bucket,state,creation,time,processing,time,service,get,current,processing,time,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,if,bucket,state,writer,null,throw,new,unsupported,operation,exception,could,not,duplicate,writer,class,writer,template,get,class,get,canonical,name,must,implement,the,writer,duplicate,method,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception;1549286603;Closes the current part file and opens a new one with a new bucket path, as returned by the_{@link Bucketer}. If the bucket is not new, then this will create a new file with the same path_as its predecessor, but with an increased rolling counter (see {@link BucketingSink}.;private void openNewPartFile(Path bucketPath, BucketState<T> bucketState) throws Exception {_		closeCurrentPartFile(bucketState)___		if (!fs.exists(bucketPath)) {_			try {_				if (fs.mkdirs(bucketPath)) {_					LOG.debug("Created new bucket directory: {}", bucketPath)__				}_			} catch (IOException e) {_				throw new RuntimeException("Could not create new bucket path.", e)__			}_		}__		_		_		_		__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		Path partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		while (fs.exists(partPath) ||_				fs.exists(getPendingPathFor(partPath)) ||_				fs.exists(getInProgressPathFor(partPath))) {_			bucketState.partCounter++__			partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter)__		}__		_		bucketState.creationTime = processingTimeService.getCurrentProcessingTime()___		_		bucketState.partCounter++___		LOG.debug("Next part path is {}", partPath.toString())__		bucketState.currentFile = partPath.toString()___		Path inProgressPath = getInProgressPathFor(partPath)__		if (bucketState.writer == null) {_			bucketState.writer = writerTemplate.duplicate()__			if (bucketState.writer == null) {_				throw new UnsupportedOperationException(_					"Could not duplicate writer. " +_						"Class '" + writerTemplate.getClass().getCanonicalName() + "' must implement the 'Writer.duplicate()' method."_				)__			}_		}__		bucketState.writer.open(fs, inProgressPath)__		bucketState.isWriterOpen = true__	};closes,the,current,part,file,and,opens,a,new,one,with,a,new,bucket,path,as,returned,by,the,link,bucketer,if,the,bucket,is,not,new,then,this,will,create,a,new,file,with,the,same,path,as,its,predecessor,but,with,an,increased,rolling,counter,see,link,bucketing,sink;private,void,open,new,part,file,path,bucket,path,bucket,state,t,bucket,state,throws,exception,close,current,part,file,bucket,state,if,fs,exists,bucket,path,try,if,fs,mkdirs,bucket,path,log,debug,created,new,bucket,directory,bucket,path,catch,ioexception,e,throw,new,runtime,exception,could,not,create,new,bucket,path,e,int,subtask,index,get,runtime,context,get,index,of,this,subtask,path,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,while,fs,exists,part,path,fs,exists,get,pending,path,for,part,path,fs,exists,get,in,progress,path,for,part,path,bucket,state,part,counter,part,path,assemble,part,path,bucket,path,subtask,index,bucket,state,part,counter,bucket,state,creation,time,processing,time,service,get,current,processing,time,bucket,state,part,counter,log,debug,next,part,path,is,part,path,to,string,bucket,state,current,file,part,path,to,string,path,in,progress,path,get,in,progress,path,for,part,path,if,bucket,state,writer,null,bucket,state,writer,writer,template,duplicate,if,bucket,state,writer,null,throw,new,unsupported,operation,exception,could,not,duplicate,writer,class,writer,template,get,class,get,canonical,name,must,implement,the,writer,duplicate,method,bucket,state,writer,open,fs,in,progress,path,bucket,state,is,writer,open,true
BucketingSink -> private void initFileSystem() throws IOException;1480685315;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs != null) {_			return__		}_		org.apache.hadoop.conf.Configuration hadoopConf = HadoopFileSystem.getHadoopConfiguration()__		if (fsConfig != null) {_			String disableCacheName = String.format("fs.%s.impl.disable.cache", new Path(basePath).toUri().getScheme())__			hadoopConf.setBoolean(disableCacheName, true)__			for (String key : fsConfig.keySet()) {_				hadoopConf.set(key, fsConfig.getString(key, null))__			}_		}__		fs = new Path(basePath).getFileSystem(hadoopConf)__	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,return,org,apache,hadoop,conf,configuration,hadoop,conf,hadoop,file,system,get,hadoop,configuration,if,fs,config,null,string,disable,cache,name,string,format,fs,s,impl,disable,cache,new,path,base,path,to,uri,get,scheme,hadoop,conf,set,boolean,disable,cache,name,true,for,string,key,fs,config,key,set,hadoop,conf,set,key,fs,config,get,string,key,null,fs,new,path,base,path,get,file,system,hadoop,conf
BucketingSink -> private void initFileSystem() throws IOException;1484304405;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs != null) {_			return__		}_		org.apache.hadoop.conf.Configuration hadoopConf = HadoopFileSystem.getHadoopConfiguration()__		if (fsConfig != null) {_			String disableCacheName = String.format("fs.%s.impl.disable.cache", new Path(basePath).toUri().getScheme())__			hadoopConf.setBoolean(disableCacheName, true)__			for (String key : fsConfig.keySet()) {_				hadoopConf.set(key, fsConfig.getString(key, null))__			}_		}__		fs = new Path(basePath).getFileSystem(hadoopConf)__	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,return,org,apache,hadoop,conf,configuration,hadoop,conf,hadoop,file,system,get,hadoop,configuration,if,fs,config,null,string,disable,cache,name,string,format,fs,s,impl,disable,cache,new,path,base,path,to,uri,get,scheme,hadoop,conf,set,boolean,disable,cache,name,true,for,string,key,fs,config,key,set,hadoop,conf,set,key,fs,config,get,string,key,null,fs,new,path,base,path,get,file,system,hadoop,conf
BucketingSink -> private void initFileSystem() throws IOException;1484304405;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs != null) {_			return__		}_		org.apache.hadoop.conf.Configuration hadoopConf = HadoopFileSystem.getHadoopConfiguration()__		if (fsConfig != null) {_			String disableCacheName = String.format("fs.%s.impl.disable.cache", new Path(basePath).toUri().getScheme())__			hadoopConf.setBoolean(disableCacheName, true)__			for (String key : fsConfig.keySet()) {_				hadoopConf.set(key, fsConfig.getString(key, null))__			}_		}__		fs = new Path(basePath).getFileSystem(hadoopConf)__	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,return,org,apache,hadoop,conf,configuration,hadoop,conf,hadoop,file,system,get,hadoop,configuration,if,fs,config,null,string,disable,cache,name,string,format,fs,s,impl,disable,cache,new,path,base,path,to,uri,get,scheme,hadoop,conf,set,boolean,disable,cache,name,true,for,string,key,fs,config,key,set,hadoop,conf,set,key,fs,config,get,string,key,null,fs,new,path,base,path,get,file,system,hadoop,conf
BucketingSink -> private void initFileSystem() throws IOException;1493821557;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs != null) {_			return__		}_		org.apache.hadoop.conf.Configuration hadoopConf = HadoopFileSystem.getHadoopConfiguration()__		if (fsConfig != null) {_			String disableCacheName = String.format("fs.%s.impl.disable.cache", new Path(basePath).toUri().getScheme())__			hadoopConf.setBoolean(disableCacheName, true)__			for (String key : fsConfig.keySet()) {_				hadoopConf.set(key, fsConfig.getString(key, null))__			}_		}__		fs = new Path(basePath).getFileSystem(hadoopConf)__	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,return,org,apache,hadoop,conf,configuration,hadoop,conf,hadoop,file,system,get,hadoop,configuration,if,fs,config,null,string,disable,cache,name,string,format,fs,s,impl,disable,cache,new,path,base,path,to,uri,get,scheme,hadoop,conf,set,boolean,disable,cache,name,true,for,string,key,fs,config,key,set,hadoop,conf,set,key,fs,config,get,string,key,null,fs,new,path,base,path,get,file,system,hadoop,conf
BucketingSink -> private void initFileSystem() throws IOException;1494937633;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs != null) {_			return__		}_		org.apache.hadoop.conf.Configuration hadoopConf = HadoopFileSystem.getHadoopConfiguration()__		if (fsConfig != null) {_			String disableCacheName = String.format("fs.%s.impl.disable.cache", new Path(basePath).toUri().getScheme())__			hadoopConf.setBoolean(disableCacheName, true)__			for (String key : fsConfig.keySet()) {_				hadoopConf.set(key, fsConfig.getString(key, null))__			}_		}__		fs = new Path(basePath).getFileSystem(hadoopConf)__	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,return,org,apache,hadoop,conf,configuration,hadoop,conf,hadoop,file,system,get,hadoop,configuration,if,fs,config,null,string,disable,cache,name,string,format,fs,s,impl,disable,cache,new,path,base,path,to,uri,get,scheme,hadoop,conf,set,boolean,disable,cache,name,true,for,string,key,fs,config,key,set,hadoop,conf,set,key,fs,config,get,string,key,null,fs,new,path,base,path,get,file,system,hadoop,conf
BucketingSink -> private void initFileSystem() throws IOException;1495923089;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs != null) {_			return__		}_		org.apache.hadoop.conf.Configuration hadoopConf = HadoopFileSystem.getHadoopConfiguration()__		if (fsConfig != null) {_			String disableCacheName = String.format("fs.%s.impl.disable.cache", new Path(basePath).toUri().getScheme())__			hadoopConf.setBoolean(disableCacheName, true)__			for (String key : fsConfig.keySet()) {_				hadoopConf.set(key, fsConfig.getString(key, null))__			}_		}__		fs = new Path(basePath).getFileSystem(hadoopConf)__	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,return,org,apache,hadoop,conf,configuration,hadoop,conf,hadoop,file,system,get,hadoop,configuration,if,fs,config,null,string,disable,cache,name,string,format,fs,s,impl,disable,cache,new,path,base,path,to,uri,get,scheme,hadoop,conf,set,boolean,disable,cache,name,true,for,string,key,fs,config,key,set,hadoop,conf,set,key,fs,config,get,string,key,null,fs,new,path,base,path,get,file,system,hadoop,conf
BucketingSink -> private void initFileSystem() throws IOException;1503598628;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs != null) {_			return__		}_		org.apache.hadoop.conf.Configuration hadoopConf = HadoopFileSystem.getHadoopConfiguration()__		if (fsConfig != null) {_			String disableCacheName = String.format("fs.%s.impl.disable.cache", new Path(basePath).toUri().getScheme())__			hadoopConf.setBoolean(disableCacheName, true)__			for (String key : fsConfig.keySet()) {_				hadoopConf.set(key, fsConfig.getString(key, null))__			}_		}__		fs = new Path(basePath).getFileSystem(hadoopConf)__	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,return,org,apache,hadoop,conf,configuration,hadoop,conf,hadoop,file,system,get,hadoop,configuration,if,fs,config,null,string,disable,cache,name,string,format,fs,s,impl,disable,cache,new,path,base,path,to,uri,get,scheme,hadoop,conf,set,boolean,disable,cache,name,true,for,string,key,fs,config,key,set,hadoop,conf,set,key,fs,config,get,string,key,null,fs,new,path,base,path,get,file,system,hadoop,conf
BucketingSink -> private void initFileSystem() throws IOException;1507304600;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1511347989;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1511532265;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1516813396;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1519115515;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1519913093;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1524138809;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1525709672;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1526068396;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1531134089;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1531303510;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1531676690;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1533641721;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1536238633;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> private void initFileSystem() throws IOException;1549286603;Create a file system with the user-defined {@code HDFS} configuration._@throws IOException;private void initFileSystem() throws IOException {_		if (fs == null) {_			Path path = new Path(basePath)__			fs = createHadoopFileSystem(path, fsConfig)__		}_	};create,a,file,system,with,the,user,defined,code,hdfs,configuration,throws,ioexception;private,void,init,file,system,throws,ioexception,if,fs,null,path,path,new,path,base,path,fs,create,hadoop,file,system,path,fs,config
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1480685315;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1484304405;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1484304405;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1493821557;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1494937633;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1495923089;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1503598628;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1507304600;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1511347989;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1511532265;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1516813396;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1519115515;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1519913093;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1524138809;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1525709672;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1526068396;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1531134089;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1531303510;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1531676690;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1533641721;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1536238633;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix);1549286603;Sets the prefix of valid-length files. The default is {@code "_"}.;public BucketingSink<T> setValidLengthPrefix(String validLengthPrefix) {_		this.validLengthPrefix = validLengthPrefix__		return this__	};sets,the,prefix,of,valid,length,files,the,default,is,code;public,bucketing,sink,t,set,valid,length,prefix,string,valid,length,prefix,this,valid,length,prefix,valid,length,prefix,return,this
BucketingSink -> public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval);1526068396;Sets the roll over interval in milliseconds.___<p>When a bucket part file is older than the roll over interval, a new bucket part file is_started and the old one is closed. The name of the bucket file depends on the {@link Bucketer}._Additionally, the old part file is also closed if the bucket is not written to for a minimum of_{@code inactiveBucketThreshold} ms.__@param batchRolloverInterval The roll over interval in milliseconds;public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval) {_		if (batchRolloverInterval > 0) {_			this.batchRolloverInterval = batchRolloverInterval__		}__		return this__	};sets,the,roll,over,interval,in,milliseconds,p,when,a,bucket,part,file,is,older,than,the,roll,over,interval,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,file,depends,on,the,link,bucketer,additionally,the,old,part,file,is,also,closed,if,the,bucket,is,not,written,to,for,a,minimum,of,code,inactive,bucket,threshold,ms,param,batch,rollover,interval,the,roll,over,interval,in,milliseconds;public,bucketing,sink,t,set,batch,rollover,interval,long,batch,rollover,interval,if,batch,rollover,interval,0,this,batch,rollover,interval,batch,rollover,interval,return,this
BucketingSink -> public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval);1531134089;Sets the roll over interval in milliseconds.___<p>When a bucket part file is older than the roll over interval, a new bucket part file is_started and the old one is closed. The name of the bucket file depends on the {@link Bucketer}._Additionally, the old part file is also closed if the bucket is not written to for a minimum of_{@code inactiveBucketThreshold} ms.__@param batchRolloverInterval The roll over interval in milliseconds;public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval) {_		if (batchRolloverInterval > 0) {_			this.batchRolloverInterval = batchRolloverInterval__		}__		return this__	};sets,the,roll,over,interval,in,milliseconds,p,when,a,bucket,part,file,is,older,than,the,roll,over,interval,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,file,depends,on,the,link,bucketer,additionally,the,old,part,file,is,also,closed,if,the,bucket,is,not,written,to,for,a,minimum,of,code,inactive,bucket,threshold,ms,param,batch,rollover,interval,the,roll,over,interval,in,milliseconds;public,bucketing,sink,t,set,batch,rollover,interval,long,batch,rollover,interval,if,batch,rollover,interval,0,this,batch,rollover,interval,batch,rollover,interval,return,this
BucketingSink -> public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval);1531303510;Sets the roll over interval in milliseconds.___<p>When a bucket part file is older than the roll over interval, a new bucket part file is_started and the old one is closed. The name of the bucket file depends on the {@link Bucketer}._Additionally, the old part file is also closed if the bucket is not written to for a minimum of_{@code inactiveBucketThreshold} ms.__@param batchRolloverInterval The roll over interval in milliseconds;public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval) {_		if (batchRolloverInterval > 0) {_			this.batchRolloverInterval = batchRolloverInterval__		}__		return this__	};sets,the,roll,over,interval,in,milliseconds,p,when,a,bucket,part,file,is,older,than,the,roll,over,interval,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,file,depends,on,the,link,bucketer,additionally,the,old,part,file,is,also,closed,if,the,bucket,is,not,written,to,for,a,minimum,of,code,inactive,bucket,threshold,ms,param,batch,rollover,interval,the,roll,over,interval,in,milliseconds;public,bucketing,sink,t,set,batch,rollover,interval,long,batch,rollover,interval,if,batch,rollover,interval,0,this,batch,rollover,interval,batch,rollover,interval,return,this
BucketingSink -> public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval);1531676690;Sets the roll over interval in milliseconds.___<p>When a bucket part file is older than the roll over interval, a new bucket part file is_started and the old one is closed. The name of the bucket file depends on the {@link Bucketer}._Additionally, the old part file is also closed if the bucket is not written to for a minimum of_{@code inactiveBucketThreshold} ms.__@param batchRolloverInterval The roll over interval in milliseconds;public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval) {_		if (batchRolloverInterval > 0) {_			this.batchRolloverInterval = batchRolloverInterval__		}__		return this__	};sets,the,roll,over,interval,in,milliseconds,p,when,a,bucket,part,file,is,older,than,the,roll,over,interval,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,file,depends,on,the,link,bucketer,additionally,the,old,part,file,is,also,closed,if,the,bucket,is,not,written,to,for,a,minimum,of,code,inactive,bucket,threshold,ms,param,batch,rollover,interval,the,roll,over,interval,in,milliseconds;public,bucketing,sink,t,set,batch,rollover,interval,long,batch,rollover,interval,if,batch,rollover,interval,0,this,batch,rollover,interval,batch,rollover,interval,return,this
BucketingSink -> public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval);1533641721;Sets the roll over interval in milliseconds.___<p>When a bucket part file is older than the roll over interval, a new bucket part file is_started and the old one is closed. The name of the bucket file depends on the {@link Bucketer}._Additionally, the old part file is also closed if the bucket is not written to for a minimum of_{@code inactiveBucketThreshold} ms.__@param batchRolloverInterval The roll over interval in milliseconds;public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval) {_		if (batchRolloverInterval > 0) {_			this.batchRolloverInterval = batchRolloverInterval__		}__		return this__	};sets,the,roll,over,interval,in,milliseconds,p,when,a,bucket,part,file,is,older,than,the,roll,over,interval,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,file,depends,on,the,link,bucketer,additionally,the,old,part,file,is,also,closed,if,the,bucket,is,not,written,to,for,a,minimum,of,code,inactive,bucket,threshold,ms,param,batch,rollover,interval,the,roll,over,interval,in,milliseconds;public,bucketing,sink,t,set,batch,rollover,interval,long,batch,rollover,interval,if,batch,rollover,interval,0,this,batch,rollover,interval,batch,rollover,interval,return,this
BucketingSink -> public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval);1536238633;Sets the roll over interval in milliseconds.___<p>When a bucket part file is older than the roll over interval, a new bucket part file is_started and the old one is closed. The name of the bucket file depends on the {@link Bucketer}._Additionally, the old part file is also closed if the bucket is not written to for a minimum of_{@code inactiveBucketThreshold} ms.__@param batchRolloverInterval The roll over interval in milliseconds;public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval) {_		if (batchRolloverInterval > 0) {_			this.batchRolloverInterval = batchRolloverInterval__		}__		return this__	};sets,the,roll,over,interval,in,milliseconds,p,when,a,bucket,part,file,is,older,than,the,roll,over,interval,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,file,depends,on,the,link,bucketer,additionally,the,old,part,file,is,also,closed,if,the,bucket,is,not,written,to,for,a,minimum,of,code,inactive,bucket,threshold,ms,param,batch,rollover,interval,the,roll,over,interval,in,milliseconds;public,bucketing,sink,t,set,batch,rollover,interval,long,batch,rollover,interval,if,batch,rollover,interval,0,this,batch,rollover,interval,batch,rollover,interval,return,this
BucketingSink -> public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval);1549286603;Sets the roll over interval in milliseconds.___<p>When a bucket part file is older than the roll over interval, a new bucket part file is_started and the old one is closed. The name of the bucket file depends on the {@link Bucketer}._Additionally, the old part file is also closed if the bucket is not written to for a minimum of_{@code inactiveBucketThreshold} ms.__@param batchRolloverInterval The roll over interval in milliseconds;public BucketingSink<T> setBatchRolloverInterval(long batchRolloverInterval) {_		if (batchRolloverInterval > 0) {_			this.batchRolloverInterval = batchRolloverInterval__		}__		return this__	};sets,the,roll,over,interval,in,milliseconds,p,when,a,bucket,part,file,is,older,than,the,roll,over,interval,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,file,depends,on,the,link,bucketer,additionally,the,old,part,file,is,also,closed,if,the,bucket,is,not,written,to,for,a,minimum,of,code,inactive,bucket,threshold,ms,param,batch,rollover,interval,the,roll,over,interval,in,milliseconds;public,bucketing,sink,t,set,batch,rollover,interval,long,batch,rollover,interval,if,batch,rollover,interval,0,this,batch,rollover,interval,batch,rollover,interval,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1480685315;Disable cleanup of leftover in-progress/pending files when the sink is opened.__<p>_This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1484304405;Disable cleanup of leftover in-progress/pending files when the sink is opened.__<p>_This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1484304405;Disable cleanup of leftover in-progress/pending files when the sink is opened.__<p>_This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1493821557;Disable cleanup of leftover in-progress/pending files when the sink is opened.__<p>_This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1494937633;Disable cleanup of leftover in-progress/pending files when the sink is opened.__<p>_This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1495923089;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1503598628;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1507304600;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1511347989;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1511532265;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1516813396;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1519115515;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1519913093;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1524138809;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1525709672;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1526068396;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1531134089;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1531303510;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1531676690;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1533641721;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1536238633;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> @Deprecated 	public BucketingSink<T> disableCleanupOnOpen();1549286603;Disable cleanup of leftover in-progress/pending files when the sink is opened.___<p>This should only be disabled if using the sink without checkpoints, to not remove_the files already in the directory.__@deprecated This option is deprecated and remains only for backwards compatibility._We do not clean up lingering files anymore.;@Deprecated_	public BucketingSink<T> disableCleanupOnOpen() {_		return this__	};disable,cleanup,of,leftover,in,progress,pending,files,when,the,sink,is,opened,p,this,should,only,be,disabled,if,using,the,sink,without,checkpoints,to,not,remove,the,files,already,in,the,directory,deprecated,this,option,is,deprecated,and,remains,only,for,backwards,compatibility,we,do,not,clean,up,lingering,files,anymore;deprecated,public,bucketing,sink,t,disable,cleanup,on,open,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1480685315;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1484304405;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1484304405;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1493821557;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1494937633;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1495923089;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1503598628;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1507304600;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1511347989;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1511532265;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1516813396;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1519115515;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1519913093;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1524138809;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1525709672;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1526068396;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive._Additionally, part files for the bucket are also closed if the bucket is older than_{@code batchRolloverInterval} ms.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,additionally,part,files,for,the,bucket,are,also,closed,if,the,bucket,is,older,than,code,batch,rollover,interval,ms,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1531134089;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive._Additionally, part files for the bucket are also closed if the bucket is older than_{@code batchRolloverInterval} ms.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,additionally,part,files,for,the,bucket,are,also,closed,if,the,bucket,is,older,than,code,batch,rollover,interval,ms,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1531303510;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive._Additionally, part files for the bucket are also closed if the bucket is older than_{@code batchRolloverInterval} ms.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,additionally,part,files,for,the,bucket,are,also,closed,if,the,bucket,is,older,than,code,batch,rollover,interval,ms,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1531676690;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive._Additionally, part files for the bucket are also closed if the bucket is older than_{@code batchRolloverInterval} ms.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,additionally,part,files,for,the,bucket,are,also,closed,if,the,bucket,is,older,than,code,batch,rollover,interval,ms,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1533641721;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive._Additionally, part files for the bucket are also closed if the bucket is older than_{@code batchRolloverInterval} ms.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,additionally,part,files,for,the,bucket,are,also,closed,if,the,bucket,is,older,than,code,batch,rollover,interval,ms,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1536238633;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive._Additionally, part files for the bucket are also closed if the bucket is older than_{@code batchRolloverInterval} ms.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,additionally,part,files,for,the,bucket,are,also,closed,if,the,bucket,is,older,than,code,batch,rollover,interval,ms,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketThreshold(long threshold);1549286603;Sets the default threshold for marking a bucket as inactive and closing its part files._Buckets which haven't been written to for at least this period of time become inactive._Additionally, part files for the bucket are also closed if the bucket is older than_{@code batchRolloverInterval} ms.__@param threshold The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketThreshold(long threshold) {_		this.inactiveBucketThreshold = threshold__		return this__	};sets,the,default,threshold,for,marking,a,bucket,as,inactive,and,closing,its,part,files,buckets,which,haven,t,been,written,to,for,at,least,this,period,of,time,become,inactive,additionally,part,files,for,the,bucket,are,also,closed,if,the,bucket,is,older,than,code,batch,rollover,interval,ms,param,threshold,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,threshold,long,threshold,this,inactive,bucket,threshold,threshold,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1480685315;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1484304405;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1484304405;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1493821557;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1494937633;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1495923089;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1503598628;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1507304600;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1511347989;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1511532265;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1516813396;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1519115515;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1519913093;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1524138809;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1525709672;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1526068396;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1531134089;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1531303510;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1531676690;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1533641721;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1536238633;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setInProgressPrefix(String inProgressPrefix);1549286603;Sets the prefix of in-progress part files. The default is {@code "_"}.;public BucketingSink<T> setInProgressPrefix(String inProgressPrefix) {_		this.inProgressPrefix = inProgressPrefix__		return this__	};sets,the,prefix,of,in,progress,part,files,the,default,is,code;public,bucketing,sink,t,set,in,progress,prefix,string,in,progress,prefix,this,in,progress,prefix,in,progress,prefix,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1480685315;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for(Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1484304405;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for(Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1484304405;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for(Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1493821557;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for(Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1494937633;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for(Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1495923089;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1503598628;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1507304600;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1511347989;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1511532265;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1516813396;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1519115515;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1519913093;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1524138809;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1525709672;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1526068396;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1531134089;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1531303510;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1531676690;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1533641721;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1536238633;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config);1549286603;Specify a custom {@code Configuration} that will be used when creating_the {@link FileSystem} for writing.;public BucketingSink<T> setFSConfig(org.apache.hadoop.conf.Configuration config) {_		this.fsConfig = new Configuration()__		for (Map.Entry<String, String> entry : config) {_			fsConfig.setString(entry.getKey(), entry.getValue())__		}_		return this__	};specify,a,custom,code,configuration,that,will,be,used,when,creating,the,link,file,system,for,writing;public,bucketing,sink,t,set,fsconfig,org,apache,hadoop,conf,configuration,config,this,fs,config,new,configuration,for,map,entry,string,string,entry,config,fs,config,set,string,entry,get,key,entry,get,value,return,this
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException;1526068396;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_<li>the current file is older than roll over interval</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			} else {_				if (currentProcessingTime - bucketState.creationTime > batchRolloverInterval) {_					shouldRoll = true__					LOG.debug(_						"BucketingSink {} starting new bucket because file is older than roll over interval {}.",_						subtaskIndex,_						batchRolloverInterval)__				}_			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,li,the,current,file,is,older,than,roll,over,interval,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,long,current,processing,time,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,else,if,current,processing,time,bucket,state,creation,time,batch,rollover,interval,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,is,older,than,roll,over,interval,subtask,index,batch,rollover,interval,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException;1531134089;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_<li>the current file is older than roll over interval</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			} else {_				if (currentProcessingTime - bucketState.creationTime > batchRolloverInterval) {_					shouldRoll = true__					LOG.debug(_						"BucketingSink {} starting new bucket because file is older than roll over interval {}.",_						subtaskIndex,_						batchRolloverInterval)__				}_			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,li,the,current,file,is,older,than,roll,over,interval,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,long,current,processing,time,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,else,if,current,processing,time,bucket,state,creation,time,batch,rollover,interval,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,is,older,than,roll,over,interval,subtask,index,batch,rollover,interval,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException;1531303510;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_<li>the current file is older than roll over interval</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			} else {_				if (currentProcessingTime - bucketState.creationTime > batchRolloverInterval) {_					shouldRoll = true__					LOG.debug(_						"BucketingSink {} starting new bucket because file is older than roll over interval {}.",_						subtaskIndex,_						batchRolloverInterval)__				}_			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,li,the,current,file,is,older,than,roll,over,interval,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,long,current,processing,time,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,else,if,current,processing,time,bucket,state,creation,time,batch,rollover,interval,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,is,older,than,roll,over,interval,subtask,index,batch,rollover,interval,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException;1531676690;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_<li>the current file is older than roll over interval</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			} else {_				if (currentProcessingTime - bucketState.creationTime > batchRolloverInterval) {_					shouldRoll = true__					LOG.debug(_						"BucketingSink {} starting new bucket because file is older than roll over interval {}.",_						subtaskIndex,_						batchRolloverInterval)__				}_			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,li,the,current,file,is,older,than,roll,over,interval,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,long,current,processing,time,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,else,if,current,processing,time,bucket,state,creation,time,batch,rollover,interval,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,is,older,than,roll,over,interval,subtask,index,batch,rollover,interval,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException;1533641721;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_<li>the current file is older than roll over interval</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			} else {_				if (currentProcessingTime - bucketState.creationTime > batchRolloverInterval) {_					shouldRoll = true__					LOG.debug(_						"BucketingSink {} starting new bucket because file is older than roll over interval {}.",_						subtaskIndex,_						batchRolloverInterval)__				}_			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,li,the,current,file,is,older,than,roll,over,interval,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,long,current,processing,time,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,else,if,current,processing,time,bucket,state,creation,time,batch,rollover,interval,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,is,older,than,roll,over,interval,subtask,index,batch,rollover,interval,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException;1536238633;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_<li>the current file is older than roll over interval</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			} else {_				if (currentProcessingTime - bucketState.creationTime > batchRolloverInterval) {_					shouldRoll = true__					LOG.debug(_						"BucketingSink {} starting new bucket because file is older than roll over interval {}.",_						subtaskIndex,_						batchRolloverInterval)__				}_			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,li,the,current,file,is,older,than,roll,over,interval,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,long,current,processing,time,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,else,if,current,processing,time,bucket,state,creation,time,batch,rollover,interval,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,is,older,than,roll,over,interval,subtask,index,batch,rollover,interval,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException;1549286603;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_<li>the current file is older than roll over interval</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState, long currentProcessingTime) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			} else {_				if (currentProcessingTime - bucketState.creationTime > batchRolloverInterval) {_					shouldRoll = true__					LOG.debug(_						"BucketingSink {} starting new bucket because file is older than roll over interval {}.",_						subtaskIndex,_						batchRolloverInterval)__				}_			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,li,the,current,file,is,older,than,roll,over,interval,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,long,current,processing,time,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,else,if,current,processing,time,bucket,state,creation,time,batch,rollover,interval,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,is,older,than,roll,over,interval,subtask,index,batch,rollover,interval,return,should,roll
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1480685315;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1484304405;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1484304405;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1493821557;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1494937633;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1495923089;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1503598628;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1507304600;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1511347989;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1511532265;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1516813396;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1519115515;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1519913093;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1524138809;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1525709672;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1526068396;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1531134089;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1531303510;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1531676690;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1533641721;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1536238633;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> public BucketingSink<T> setBucketer(Bucketer<T> bucketer);1549286603;Sets the {@link Bucketer} to use for determining the bucket files to write to.__@param bucketer The bucketer to use.;public BucketingSink<T> setBucketer(Bucketer<T> bucketer) {_		this.bucketer = bucketer__		return this__	};sets,the,link,bucketer,to,use,for,determining,the,bucket,files,to,write,to,param,bucketer,the,bucketer,to,use;public,bucketing,sink,t,set,bucketer,bucketer,t,bucketer,this,bucketer,bucketer,return,this
BucketingSink -> private Method reflectTruncate(FileSystem fs);1480685315;Gets the truncate() call using reflection._<p>_<b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if(fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1484304405;Gets the truncate() call using reflection._<p>_<b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if(fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1484304405;Gets the truncate() call using reflection._<p>_<b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if(fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1493821557;Gets the truncate() call using reflection._<p>_<b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if(fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1494937633;Gets the truncate() call using reflection._<p>_<b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if(fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1495923089;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1503598628;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1507304600;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1511347989;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1511532265;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1516813396;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works.", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file.", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1519115515;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1519913093;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1524138809;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1525709672;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1526068396;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1531134089;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			FSDataOutputStream outputStream__			Path testPath = new Path(UUID.randomUUID().toString())__			try {_				outputStream = fs.create(testPath)__				outputStream.writeUTF("hello")__				outputStream.close()__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,fsdata,output,stream,output,stream,path,test,path,new,path,uuid,random,uuid,to,string,try,output,stream,fs,create,test,path,output,stream,write,utf,hello,output,stream,close,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1531303510;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			Path testPath = new Path(UUID.randomUUID().toString())__			try (FSDataOutputStream outputStream = fs.create(testPath)) {_				outputStream.writeUTF("hello")__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,path,test,path,new,path,uuid,random,uuid,to,string,try,fsdata,output,stream,output,stream,fs,create,test,path,output,stream,write,utf,hello,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1531676690;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			Path testPath = new Path(basePath, UUID.randomUUID().toString())__			try (FSDataOutputStream outputStream = fs.create(testPath)) {_				outputStream.writeUTF("hello")__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,path,test,path,new,path,base,path,uuid,random,uuid,to,string,try,fsdata,output,stream,output,stream,fs,create,test,path,output,stream,write,utf,hello,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1533641721;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			Path testPath = new Path(basePath, UUID.randomUUID().toString())__			try (FSDataOutputStream outputStream = fs.create(testPath)) {_				outputStream.writeUTF("hello")__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,path,test,path,new,path,base,path,uuid,random,uuid,to,string,try,fsdata,output,stream,output,stream,fs,create,test,path,output,stream,write,utf,hello,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1536238633;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			Path testPath = new Path(basePath, UUID.randomUUID().toString())__			try (FSDataOutputStream outputStream = fs.create(testPath)) {_				outputStream.writeUTF("hello")__			} catch (IOException e) {_				LOG.error("Could not create file for checking if truncate works.", e)__				throw new RuntimeException("Could not create file for checking if truncate works. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}__			try {_				m.invoke(fs, testPath, 2)__			} catch (IllegalAccessException | InvocationTargetException e) {_				LOG.debug("Truncate is not supported.", e)__				m = null__			}__			try {_				fs.delete(testPath, false)__			} catch (IOException e) {_				LOG.error("Could not delete truncate test file.", e)__				throw new RuntimeException("Could not delete truncate test file. " +_					"You can disable support for truncate() completely via " +_					"BucketingSink.setUseTruncate(false).", e)__			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,path,test,path,new,path,base,path,uuid,random,uuid,to,string,try,fsdata,output,stream,output,stream,fs,create,test,path,output,stream,write,utf,hello,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> private Method reflectTruncate(FileSystem fs);1549286603;Gets the truncate() call using reflection.__<p><b>NOTE:</b> This code comes from Flume.;private Method reflectTruncate(FileSystem fs) {_		_		_		if (!useTruncate) {_			return null__		}__		Method m = null__		if (fs != null) {_			Class<?> fsClass = fs.getClass()__			try {_				m = fsClass.getMethod("truncate", Path.class, long.class)__			} catch (NoSuchMethodException ex) {_				LOG.debug("Truncate not found. Will write a file with suffix '{}' " +_					" and prefix '{}' to specify how many bytes in a bucket are valid.", validLengthSuffix, validLengthPrefix)__				return null__			}__			_			Path testPath = new Path(basePath, UUID.randomUUID().toString())__			try {_				try (FSDataOutputStream outputStream = fs.create(testPath)) {_					outputStream.writeUTF("hello")__				} catch (IOException e) {_					LOG.error("Could not create file for checking if truncate works.", e)__					throw new RuntimeException(_							"Could not create file for checking if truncate works. " +_									"You can disable support for truncate() completely via " +_									"BucketingSink.setUseTruncate(false).", e)__				}__				try {_					m.invoke(fs, testPath, 2)__				} catch (IllegalAccessException | InvocationTargetException e) {_					LOG.debug("Truncate is not supported.", e)__					m = null__				}_			} finally {_				try {_					fs.delete(testPath, false)__				} catch (IOException e) {_					LOG.error("Could not delete truncate test file.", e)__					throw new RuntimeException("Could not delete truncate test file. " +_							"You can disable support for truncate() completely via " +_							"BucketingSink.setUseTruncate(false).", e)__				}_			}_		}_		return m__	};gets,the,truncate,call,using,reflection,p,b,note,b,this,code,comes,from,flume;private,method,reflect,truncate,file,system,fs,if,use,truncate,return,null,method,m,null,if,fs,null,class,fs,class,fs,get,class,try,m,fs,class,get,method,truncate,path,class,long,class,catch,no,such,method,exception,ex,log,debug,truncate,not,found,will,write,a,file,with,suffix,and,prefix,to,specify,how,many,bytes,in,a,bucket,are,valid,valid,length,suffix,valid,length,prefix,return,null,path,test,path,new,path,base,path,uuid,random,uuid,to,string,try,try,fsdata,output,stream,output,stream,fs,create,test,path,output,stream,write,utf,hello,catch,ioexception,e,log,error,could,not,create,file,for,checking,if,truncate,works,e,throw,new,runtime,exception,could,not,create,file,for,checking,if,truncate,works,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,try,m,invoke,fs,test,path,2,catch,illegal,access,exception,invocation,target,exception,e,log,debug,truncate,is,not,supported,e,m,null,finally,try,fs,delete,test,path,false,catch,ioexception,e,log,error,could,not,delete,truncate,test,file,e,throw,new,runtime,exception,could,not,delete,truncate,test,file,you,can,disable,support,for,truncate,completely,via,bucketing,sink,set,use,truncate,false,e,return,m
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1480685315;Sets the maximum bucket size in bytes.__<p>_When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1484304405;Sets the maximum bucket size in bytes.__<p>_When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1484304405;Sets the maximum bucket size in bytes.__<p>_When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1493821557;Sets the maximum bucket size in bytes.__<p>_When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1494937633;Sets the maximum bucket size in bytes.__<p>_When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1495923089;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1503598628;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1507304600;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1511347989;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1511532265;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1516813396;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1519115515;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1519913093;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1524138809;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1525709672;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1526068396;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1531134089;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1531303510;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1531676690;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1533641721;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1536238633;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setBatchSize(long batchSize);1549286603;Sets the maximum bucket size in bytes.___<p>When a bucket part file becomes larger than this size a new bucket part file is started and_the old one is closed. The name of the bucket files depends on the {@link Bucketer}.__@param batchSize The bucket part file size in bytes.;public BucketingSink<T> setBatchSize(long batchSize) {_		this.batchSize = batchSize__		return this__	};sets,the,maximum,bucket,size,in,bytes,p,when,a,bucket,part,file,becomes,larger,than,this,size,a,new,bucket,part,file,is,started,and,the,old,one,is,closed,the,name,of,the,bucket,files,depends,on,the,link,bucketer,param,batch,size,the,bucket,part,file,size,in,bytes;public,bucketing,sink,t,set,batch,size,long,batch,size,this,batch,size,batch,size,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1480685315;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1484304405;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1484304405;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1493821557;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1494937633;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1495923089;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1503598628;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1507304600;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1511347989;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1511532265;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1516813396;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1519115515;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1519913093;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1524138809;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1525709672;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1526068396;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1531134089;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1531303510;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1531676690;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1533641721;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1536238633;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix);1549286603;Sets the suffix of valid-length files. The default is {@code ".valid-length"}.;public BucketingSink<T> setValidLengthSuffix(String validLengthSuffix) {_		this.validLengthSuffix = validLengthSuffix__		return this__	};sets,the,suffix,of,valid,length,files,the,default,is,code,valid,length;public,bucketing,sink,t,set,valid,length,suffix,string,valid,length,suffix,this,valid,length,suffix,valid,length,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1480685315;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1484304405;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1484304405;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1493821557;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1494937633;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1495923089;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1503598628;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1507304600;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1511347989;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1511532265;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1516813396;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1519115515;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1519913093;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1524138809;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1525709672;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1526068396;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1531134089;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1531303510;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1531676690;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1533641721;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1536238633;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setPartPrefix(String partPrefix);1549286603;Sets the prefix of part files.  The default is {@code "part"}.;public BucketingSink<T> setPartPrefix(String partPrefix) {_		this.partPrefix = partPrefix__		return this__	};sets,the,prefix,of,part,files,the,default,is,code,part;public,bucketing,sink,t,set,part,prefix,string,part,prefix,this,part,prefix,part,prefix,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1480685315;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1484304405;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1484304405;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1493821557;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1494937633;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1495923089;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1503598628;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1507304600;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1511347989;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1511532265;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1516813396;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1519115515;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1519913093;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1524138809;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1525709672;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1526068396;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1531134089;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1531303510;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1531676690;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1533641721;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1536238633;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setInactiveBucketCheckInterval(long interval);1549286603;Sets the default time between checks for inactive buckets.__@param interval The timeout, in milliseconds.;public BucketingSink<T> setInactiveBucketCheckInterval(long interval) {_		this.inactiveBucketCheckInterval = interval__		return this__	};sets,the,default,time,between,checks,for,inactive,buckets,param,interval,the,timeout,in,milliseconds;public,bucketing,sink,t,set,inactive,bucket,check,interval,long,interval,this,inactive,bucket,check,interval,interval,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1480685315;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1484304405;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1484304405;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1493821557;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1494937633;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1495923089;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1503598628;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1507304600;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1511347989;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1511532265;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1516813396;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1519115515;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1519913093;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1524138809;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1525709672;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1526068396;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1531134089;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1531303510;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1531676690;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1533641721;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1536238633;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setPendingPrefix(String pendingPrefix);1549286603;Sets the prefix of pending part files. The default is {@code "_"}.;public BucketingSink<T> setPendingPrefix(String pendingPrefix) {_		this.pendingPrefix = pendingPrefix__		return this__	};sets,the,prefix,of,pending,part,files,the,default,is,code;public,bucketing,sink,t,set,pending,prefix,string,pending,prefix,this,pending,prefix,pending,prefix,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1480685315;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1484304405;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1484304405;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1493821557;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1494937633;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1495923089;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1503598628;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1507304600;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1511347989;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1511532265;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1516813396;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1519115515;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1519913093;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1524138809;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1525709672;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1526068396;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1531134089;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1531303510;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1531676690;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1533641721;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1536238633;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setAsyncTimeout(long timeout);1549286603;Sets the default timeout for asynchronous operations such as recoverLease and truncate.__@param timeout The timeout, in milliseconds.;public BucketingSink<T> setAsyncTimeout(long timeout) {_		this.asyncTimeout = timeout__		return this__	};sets,the,default,timeout,for,asynchronous,operations,such,as,recover,lease,and,truncate,param,timeout,the,timeout,in,milliseconds;public,bucketing,sink,t,set,async,timeout,long,timeout,this,async,timeout,timeout,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1480685315;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1484304405;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1484304405;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1493821557;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1494937633;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1495923089;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1503598628;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1507304600;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1511347989;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1511532265;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1516813396;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1519115515;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1519913093;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1524138809;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1525709672;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1526068396;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1531134089;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1531303510;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1531676690;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1533641721;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1536238633;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink<T> setPendingSuffix(String pendingSuffix);1549286603;Sets the suffix of pending part files. The default is {@code ".pending"}.;public BucketingSink<T> setPendingSuffix(String pendingSuffix) {_		this.pendingSuffix = pendingSuffix__		return this__	};sets,the,suffix,of,pending,part,files,the,default,is,code,pending;public,bucketing,sink,t,set,pending,suffix,string,pending,suffix,this,pending,suffix,pending,suffix,return,this
BucketingSink -> public BucketingSink(String basePath);1480685315;Creates a new {@code BucketingSink} that writes files to the given base directory.__<p>_This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1484304405;Creates a new {@code BucketingSink} that writes files to the given base directory.__<p>_This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1484304405;Creates a new {@code BucketingSink} that writes files to the given base directory.__<p>_This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1493821557;Creates a new {@code BucketingSink} that writes files to the given base directory.__<p>_This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1494937633;Creates a new {@code BucketingSink} that writes files to the given base directory.__<p>_This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1495923089;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1503598628;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1507304600;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1511347989;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1511532265;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1516813396;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1519115515;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1519913093;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1524138809;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1525709672;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1526068396;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1531134089;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1531303510;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1531676690;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1533641721;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1536238633;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> public BucketingSink(String basePath);1549286603;Creates a new {@code BucketingSink} that writes files to the given base directory.___<p>This uses a{@link DateTimeBucketer} as {@link Bucketer} and a {@link StringWriter} has writer._The maximum bucket size is set to 384 MB.__@param basePath The directory to which to write the bucket files.;public BucketingSink(String basePath) {_		this.basePath = basePath__		this.bucketer = new DateTimeBucketer<>()__		this.writerTemplate = new StringWriter<>()__	};creates,a,new,code,bucketing,sink,that,writes,files,to,the,given,base,directory,p,this,uses,a,link,date,time,bucketer,as,link,bucketer,and,a,link,string,writer,has,writer,the,maximum,bucket,size,is,set,to,384,mb,param,base,path,the,directory,to,which,to,write,the,bucket,files;public,bucketing,sink,string,base,path,this,base,path,base,path,this,bucketer,new,date,time,bucketer,this,writer,template,new,string,writer
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1480685315;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1484304405;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1484304405;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1493821557;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1494937633;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1495923089;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1503598628;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1507304600;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1511347989;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1511532265;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1516813396;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1519115515;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1519913093;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1524138809;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> private boolean shouldRoll(BucketState<T> bucketState) throws IOException;1525709672;Returns {@code true} if the current {@code part-file} should be closed and a new should be created._This happens if:_<ol>_<li>no file is created yet for the task to write to, or</li>_<li>the current file has reached the maximum bucket size.</li>_</ol>;private boolean shouldRoll(BucketState<T> bucketState) throws IOException {_		boolean shouldRoll = false__		int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask()__		if (!bucketState.isWriterOpen) {_			shouldRoll = true__			LOG.debug("BucketingSink {} starting new bucket.", subtaskIndex)__		} else {_			long writePosition = bucketState.writer.getPos()__			if (writePosition > batchSize) {_				shouldRoll = true__				LOG.debug(_					"BucketingSink {} starting new bucket because file position {} is above batch size {}.",_					subtaskIndex,_					writePosition,_					batchSize)__			}_		}_		return shouldRoll__	};returns,code,true,if,the,current,code,part,file,should,be,closed,and,a,new,should,be,created,this,happens,if,ol,li,no,file,is,created,yet,for,the,task,to,write,to,or,li,li,the,current,file,has,reached,the,maximum,bucket,size,li,ol;private,boolean,should,roll,bucket,state,t,bucket,state,throws,ioexception,boolean,should,roll,false,int,subtask,index,get,runtime,context,get,index,of,this,subtask,if,bucket,state,is,writer,open,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,subtask,index,else,long,write,position,bucket,state,writer,get,pos,if,write,position,batch,size,should,roll,true,log,debug,bucketing,sink,starting,new,bucket,because,file,position,is,above,batch,size,subtask,index,write,position,batch,size,return,should,roll
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1480685315;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1484304405;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1484304405;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1493821557;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1494937633;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1495923089;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1503598628;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1507304600;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1511347989;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1511532265;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1516813396;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1519115515;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1519913093;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1524138809;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1525709672;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1526068396;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1531134089;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1531303510;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1531676690;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1533641721;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1536238633;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setWriter(Writer<T> writer);1549286603;Sets the {@link Writer} to be used for writing the incoming elements to bucket files.__@param writer The {@code Writer} to use.;public BucketingSink<T> setWriter(Writer<T> writer) {_		this.writerTemplate = writer__		return this__	};sets,the,link,writer,to,be,used,for,writing,the,incoming,elements,to,bucket,files,param,writer,the,code,writer,to,use;public,bucketing,sink,t,set,writer,writer,t,writer,this,writer,template,writer,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1519115515;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1519913093;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1524138809;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1525709672;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1526068396;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1531134089;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1531303510;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1531676690;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1533641721;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1536238633;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setUseTruncate(boolean useTruncate);1549286603;Sets whether to use {@code FileSystem.truncate()} to truncate written bucket files back to_a consistent state in case of a restore from checkpoint. If {@code truncate()} is not used_this sink will write valid-length files for corresponding bucket files that have to be used_when reading from bucket files to make sure to not read too far.;public BucketingSink<T> setUseTruncate(boolean useTruncate) {_		this.useTruncate = useTruncate__		return this__	};sets,whether,to,use,code,file,system,truncate,to,truncate,written,bucket,files,back,to,a,consistent,state,in,case,of,a,restore,from,checkpoint,if,code,truncate,is,not,used,this,sink,will,write,valid,length,files,for,corresponding,bucket,files,that,have,to,be,used,when,reading,from,bucket,files,to,make,sure,to,not,read,too,far;public,bucketing,sink,t,set,use,truncate,boolean,use,truncate,this,use,truncate,use,truncate,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1519913093;Sets the prefix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,prefix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1524138809;Sets the prefix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,prefix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1525709672;Sets the prefix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,prefix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1526068396;Sets the prefix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,prefix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1531134089;Sets the prefix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,prefix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1531303510;Sets the prefix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,prefix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1531676690;Sets the prefix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,prefix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1533641721;Sets the prefix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,prefix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1536238633;Sets the suffix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,suffix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> public BucketingSink<T> setPartSuffix(String partSuffix);1549286603;Sets the suffix of part files.  The default is no suffix.;public BucketingSink<T> setPartSuffix(String partSuffix) {_		this.partSuffix = partSuffix__		return this__	};sets,the,suffix,of,part,files,the,default,is,no,suffix;public,bucketing,sink,t,set,part,suffix,string,part,suffix,this,part,suffix,part,suffix,return,this
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1480685315;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1484304405;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1484304405;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1493821557;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1494937633;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1495923089;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1503598628;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1507304600;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1511347989;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1511532265;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1516813396;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1519115515;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1519913093;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1524138809;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1525709672;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1526068396;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1531134089;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1531303510;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1531676690;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1533641721;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1536238633;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
BucketingSink -> private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception;1549286603;Closes the current part file and moves it from the in-progress state to the pending state.;private void closeCurrentPartFile(BucketState<T> bucketState) throws Exception {_		if (bucketState.isWriterOpen) {_			bucketState.writer.close()__			bucketState.isWriterOpen = false__		}__		if (bucketState.currentFile != null) {_			Path currentPartPath = new Path(bucketState.currentFile)__			Path inProgressPath = getInProgressPathFor(currentPartPath)__			Path pendingPath = getPendingPathFor(currentPartPath)___			fs.rename(inProgressPath, pendingPath)__			LOG.debug("Moving in-progress bucket {} to pending file {}",_				inProgressPath,_				pendingPath)__			bucketState.pendingFiles.add(currentPartPath.toString())__			bucketState.currentFile = null__		}_	};closes,the,current,part,file,and,moves,it,from,the,in,progress,state,to,the,pending,state;private,void,close,current,part,file,bucket,state,t,bucket,state,throws,exception,if,bucket,state,is,writer,open,bucket,state,writer,close,bucket,state,is,writer,open,false,if,bucket,state,current,file,null,path,current,part,path,new,path,bucket,state,current,file,path,in,progress,path,get,in,progress,path,for,current,part,path,path,pending,path,get,pending,path,for,current,part,path,fs,rename,in,progress,path,pending,path,log,debug,moving,in,progress,bucket,to,pending,file,in,progress,path,pending,path,bucket,state,pending,files,add,current,part,path,to,string,bucket,state,current,file,null
