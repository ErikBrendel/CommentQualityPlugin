commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Controls whether to sync {@link FSDataOutputStream} on flush.  */ ;/**  * Controls whether to sync {@link FSDataOutputStream} on flush.  */ public void setSyncOnFlush(boolean syncOnFlush) {     this.syncOnFlush = syncOnFlush. }
true;protected;0;6;/**  * Returns the current output stream, if the stream is open.  */ ;/**  * Returns the current output stream, if the stream is open.  */ protected FSDataOutputStream getStream() {     if (outStream == null) {         throw new IllegalStateException("Output stream has not been opened").     }     return outStream. }
false;public;2;7;;@Override public void open(FileSystem fs, Path path) throws IOException {     if (outStream != null) {         throw new IllegalStateException("Writer has already been opened").     }     outStream = fs.create(path, false). }
false;public;0;13;;@Override public long flush() throws IOException {     if (outStream == null) {         throw new IllegalStateException("Writer is not open").     }     if (syncOnFlush) {         outStream.hsync().     } else {         outStream.hflush().     }     return outStream.getPos(). }
false;public;0;7;;@Override public long getPos() throws IOException {     if (outStream == null) {         throw new IllegalStateException("Writer is not open").     }     return outStream.getPos(). }
false;public;0;8;;@Override public void close() throws IOException {     if (outStream != null) {         flush().         outStream.close().         outStream = null.     } }
false;public;0;3;;public boolean isSyncOnFlush() {     return syncOnFlush. }
