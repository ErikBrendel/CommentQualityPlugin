commented;modifiers;parameterAmount;loc;comment;code
true;public;0;22;/**  * Polls the next element from the Handover, possibly blocking until the next element is  * available. This method behaves similar to polling from a blocking queue.  *  * <p>If an exception was handed in by the producer ({@link #reportError(Throwable)}), then  * that exception is thrown rather than an element being returned.  *  * @return The next element (buffer of records, never null).  *  * @throws ClosedException Thrown if the Handover was {@link #close() closed}.  * @throws Exception Rethrows exceptions from the {@link #reportError(Throwable)} method.  */ ;/**  * Polls the next element from the Handover, possibly blocking until the next element is  * available. This method behaves similar to polling from a blocking queue.  *  * <p>If an exception was handed in by the producer ({@link #reportError(Throwable)}), then  * that exception is thrown rather than an element being returned.  *  * @return The next element (buffer of records, never null).  *  * @throws ClosedException Thrown if the Handover was {@link #close() closed}.  * @throws Exception Rethrows exceptions from the {@link #reportError(Throwable)} method.  */ @Nonnull public ConsumerRecords<byte[], byte[]> pollNext() throws Exception {     synchronized (lock) {         while (next == null && error == null) {             lock.wait().         }         ConsumerRecords<byte[], byte[]> n = next.         if (n != null) {             next = null.             lock.notifyAll().             return n.         } else {             ExceptionUtils.rethrowException(error, error.getMessage()).             // this is only here to silence the compiler and any warnings             return ConsumerRecords.empty().         }     } }
true;public;1;27;/**  * Hands over an element from the producer. If the Handover already has an element that was  * not yet picked up by the consumer thread, this call blocks until the consumer picks up that  * previous element.  *  * <p>This behavior is similar to a "size one" blocking queue.  *  * @param element The next element to hand over.  *  * @throws InterruptedException  *                 Thrown, if the thread is interrupted while blocking for the Handover to be empty.  * @throws WakeupException  *                 Thrown, if the {@link #wakeupProducer()} method is called while blocking for  *                 the Handover to be empty.  * @throws ClosedException  *                 Thrown if the Handover was closed or concurrently being closed.  */ ;/**  * Hands over an element from the producer. If the Handover already has an element that was  * not yet picked up by the consumer thread, this call blocks until the consumer picks up that  * previous element.  *  * <p>This behavior is similar to a "size one" blocking queue.  *  * @param element The next element to hand over.  *  * @throws InterruptedException  *                 Thrown, if the thread is interrupted while blocking for the Handover to be empty.  * @throws WakeupException  *                 Thrown, if the {@link #wakeupProducer()} method is called while blocking for  *                 the Handover to be empty.  * @throws ClosedException  *                 Thrown if the Handover was closed or concurrently being closed.  */ public void produce(final ConsumerRecords<byte[], byte[]> element) throws InterruptedException, WakeupException, ClosedException {     checkNotNull(element).     synchronized (lock) {         while (next != null && !wakeupProducer) {             lock.wait().         }         wakeupProducer = false.         // if there is still an element, we must have been woken up         if (next != null) {             throw new WakeupException().         } else // if there is no error, then this is open and can accept this element         if (error == null) {             next = element.             lock.notifyAll().         } else // an error marks this as closed for the producer         {             throw new ClosedException().         }     } }
true;public;1;12;/**  * Reports an exception. The consumer will throw the given exception immediately, if  * it is currently blocked in the {@link #pollNext()} method, or the next time it  * calls that method.  *  * <p>After this method has been called, no call to either {@link #produce(ConsumerRecords)}  * or {@link #pollNext()} will ever return regularly any more, but will always return  * exceptionally.  *  * <p>If another exception was already reported, this method does nothing.  *  * <p>For the producer, the Handover will appear as if it was {@link #close() closed}.  *  * @param t The exception to report.  */ ;/**  * Reports an exception. The consumer will throw the given exception immediately, if  * it is currently blocked in the {@link #pollNext()} method, or the next time it  * calls that method.  *  * <p>After this method has been called, no call to either {@link #produce(ConsumerRecords)}  * or {@link #pollNext()} will ever return regularly any more, but will always return  * exceptionally.  *  * <p>If another exception was already reported, this method does nothing.  *  * <p>For the producer, the Handover will appear as if it was {@link #close() closed}.  *  * @param t The exception to report.  */ public void reportError(Throwable t) {     checkNotNull(t).     synchronized (lock) {         // do not override the initial exception         if (error == null) {             error = t.         }         next = null.         lock.notifyAll().     } }
true;public;0;12;/**  * Closes the handover. Both the {@link #produce(ConsumerRecords)} method and the  * {@link #pollNext()} will throw a {@link ClosedException} on any currently blocking and  * future invocations.  *  * <p>If an exception was previously reported via the {@link #reportError(Throwable)} method,  * that exception will not be overridden. The consumer thread will throw that exception upon  * calling {@link #pollNext()}, rather than the {@code ClosedException}.  */ ;/**  * Closes the handover. Both the {@link #produce(ConsumerRecords)} method and the  * {@link #pollNext()} will throw a {@link ClosedException} on any currently blocking and  * future invocations.  *  * <p>If an exception was previously reported via the {@link #reportError(Throwable)} method,  * that exception will not be overridden. The consumer thread will throw that exception upon  * calling {@link #pollNext()}, rather than the {@code ClosedException}.  */ @Override public void close() {     synchronized (lock) {         next = null.         wakeupProducer = false.         if (error == null) {             error = new ClosedException().         }         lock.notifyAll().     } }
true;public;0;6;/**  * Wakes the producer thread up. If the producer thread is currently blocked in  * the {@link #produce(ConsumerRecords)} method, it will exit the method throwing  * a {@link WakeupException}.  */ ;/**  * Wakes the producer thread up. If the producer thread is currently blocked in  * the {@link #produce(ConsumerRecords)} method, it will exit the method throwing  * a {@link WakeupException}.  */ public void wakeupProducer() {     synchronized (lock) {         wakeupProducer = true.         lock.notifyAll().     } }
