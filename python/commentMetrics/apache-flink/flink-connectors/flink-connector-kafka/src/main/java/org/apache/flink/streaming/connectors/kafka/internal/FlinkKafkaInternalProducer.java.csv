commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// -------------------------------- Simple proxy method calls -------------------------------- @Override public void initTransactions() {     kafkaProducer.initTransactions(). }
false;public;0;4;;@Override public void beginTransaction() throws ProducerFencedException {     kafkaProducer.beginTransaction(). }
false;public;0;4;;@Override public void commitTransaction() throws ProducerFencedException {     kafkaProducer.commitTransaction(). }
false;public;0;4;;@Override public void abortTransaction() throws ProducerFencedException {     kafkaProducer.abortTransaction(). }
false;public;2;4;;@Override public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets, String consumerGroupId) throws ProducerFencedException {     kafkaProducer.sendOffsetsToTransaction(offsets, consumerGroupId). }
false;public;1;4;;@Override public Future<RecordMetadata> send(ProducerRecord<K, V> record) {     return kafkaProducer.send(record). }
false;public;2;4;;@Override public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {     return kafkaProducer.send(record, callback). }
false;public;1;4;;@Override public List<PartitionInfo> partitionsFor(String topic) {     return kafkaProducer.partitionsFor(topic). }
false;public;0;4;;@Override public Map<MetricName, ? extends Metric> metrics() {     return kafkaProducer.metrics(). }
false;public;0;4;;@Override public void close() {     kafkaProducer.close(). }
false;public;2;4;;@Override public void close(long timeout, TimeUnit unit) {     kafkaProducer.close(timeout, unit). }
false;public;0;7;;// -------------------------------- New methods or methods with changed behaviour -------------------------------- @Override public void flush() {     kafkaProducer.flush().     if (transactionalId != null) {         flushNewPartitions().     } }
true;public;2;21;/**  * Instead of obtaining producerId and epoch from the transaction coordinator, re-use previously obtained ones,  * so that we can resume transaction after a restart. Implementation of this method is based on  * {@link KafkaProducer#initTransactions}.  * https://github.com/apache/kafka/commit/5d2422258cb975a137a42a4e08f03573c49a387e#diff-f4ef1afd8792cd2a2e9069cd7ddea630  */ ;/**  * Instead of obtaining producerId and epoch from the transaction coordinator, re-use previously obtained ones,  * so that we can resume transaction after a restart. Implementation of this method is based on  * {@link KafkaProducer#initTransactions}.  * https://github.com/apache/kafka/commit/5d2422258cb975a137a42a4e08f03573c49a387e#diff-f4ef1afd8792cd2a2e9069cd7ddea630  */ public void resumeTransaction(long producerId, short epoch) {     Preconditions.checkState(producerId >= 0 && epoch >= 0, "Incorrect values for producerId {} and epoch {}", producerId, epoch).     LOG.info("Attempting to resume transaction {} with producerId {} and epoch {}", transactionalId, producerId, epoch).     Object transactionManager = getValue(kafkaProducer, "transactionManager").     synchronized (transactionManager) {         Object nextSequence = getValue(transactionManager, "nextSequence").         invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.INITIALIZING")).         invoke(nextSequence, "clear").         Object producerIdAndEpoch = getValue(transactionManager, "producerIdAndEpoch").         setValue(producerIdAndEpoch, "producerId", producerId).         setValue(producerIdAndEpoch, "epoch", epoch).         invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.READY")).         invoke(transactionManager, "transitionTo", getEnum("org.apache.kafka.clients.producer.internals.TransactionManager$State.IN_TRANSACTION")).         setValue(transactionManager, "transactionStarted", true).     } }
false;public;0;3;;public String getTransactionalId() {     return transactionalId. }
false;public;0;5;;public long getProducerId() {     Object transactionManager = getValue(kafkaProducer, "transactionManager").     Object producerIdAndEpoch = getValue(transactionManager, "producerIdAndEpoch").     return (long) getValue(producerIdAndEpoch, "producerId"). }
false;public;0;5;;public short getEpoch() {     Object transactionManager = getValue(kafkaProducer, "transactionManager").     Object producerIdAndEpoch = getValue(transactionManager, "producerIdAndEpoch").     return (short) getValue(producerIdAndEpoch, "epoch"). }
false;public;0;6;;@VisibleForTesting public int getTransactionCoordinatorId() {     Object transactionManager = getValue(kafkaProducer, "transactionManager").     Node node = (Node) invoke(transactionManager, "coordinator", FindCoordinatorRequest.CoordinatorType.TRANSACTION).     return node.id(). }
true;private;0;7;/**  * Besides committing {@link org.apache.kafka.clients.producer.KafkaProducer#commitTransaction} is also adding new  * partitions to the transaction. flushNewPartitions method is moving this logic to pre-commit/flush, to make  * resumeTransaction simpler. Otherwise resumeTransaction would require to restore state of the not yet added/"in-flight"  * partitions.  */ ;/**  * Besides committing {@link org.apache.kafka.clients.producer.KafkaProducer#commitTransaction} is also adding new  * partitions to the transaction. flushNewPartitions method is moving this logic to pre-commit/flush, to make  * resumeTransaction simpler. Otherwise resumeTransaction would require to restore state of the not yet added/"in-flight"  * partitions.  */ private void flushNewPartitions() {     LOG.info("Flushing new partitions").     TransactionalRequestResult result = enqueueNewPartitions().     Object sender = getValue(kafkaProducer, "sender").     invoke(sender, "wakeup").     result.await(). }
false;private;0;9;;private TransactionalRequestResult enqueueNewPartitions() {     Object transactionManager = getValue(kafkaProducer, "transactionManager").     synchronized (transactionManager) {         Object txnRequestHandler = invoke(transactionManager, "addPartitionsToTransactionHandler").         invoke(transactionManager, "enqueueRequest", new Class[] { txnRequestHandler.getClass().getSuperclass() }, new Object[] { txnRequestHandler }).         TransactionalRequestResult result = (TransactionalRequestResult) getValue(txnRequestHandler, txnRequestHandler.getClass().getSuperclass(), "result").         return result.     } }
false;protected,static;1;14;;protected static Enum<?> getEnum(String enumFullName) {     String[] x = enumFullName.split("\\.(?=[^\\.]+$)").     if (x.length == 2) {         String enumClassName = x[0].         String enumName = x[1].         try {             Class<Enum> cl = (Class<Enum>) Class.forName(enumClassName).             return Enum.valueOf(cl, enumName).         } catch (ClassNotFoundException e) {             throw new RuntimeException("Incompatible KafkaProducer version", e).         }     }     return null. }
false;protected,static;3;7;;protected static Object invoke(Object object, String methodName, Object... args) {     Class<?>[] argTypes = new Class[args.length].     for (int i = 0. i < args.length. i++) {         argTypes[i] = args[i].getClass().     }     return invoke(object, methodName, argTypes, args). }
false;private,static;4;9;;private static Object invoke(Object object, String methodName, Class<?>[] argTypes, Object[] args) {     try {         Method method = object.getClass().getDeclaredMethod(methodName, argTypes).         method.setAccessible(true).         return method.invoke(object, args).     } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {         throw new RuntimeException("Incompatible KafkaProducer version", e).     } }
false;protected,static;2;3;;protected static Object getValue(Object object, String fieldName) {     return getValue(object, object.getClass(), fieldName). }
false;private,static;3;9;;private static Object getValue(Object object, Class<?> clazz, String fieldName) {     try {         Field field = clazz.getDeclaredField(fieldName).         field.setAccessible(true).         return field.get(object).     } catch (NoSuchFieldException | IllegalAccessException e) {         throw new RuntimeException("Incompatible KafkaProducer version", e).     } }
false;protected,static;3;9;;protected static void setValue(Object object, String fieldName, Object value) {     try {         Field field = object.getClass().getDeclaredField(fieldName).         field.setAccessible(true).         field.set(object, value).     } catch (NoSuchFieldException | IllegalAccessException e) {         throw new RuntimeException("Incompatible KafkaProducer version", e).     } }
