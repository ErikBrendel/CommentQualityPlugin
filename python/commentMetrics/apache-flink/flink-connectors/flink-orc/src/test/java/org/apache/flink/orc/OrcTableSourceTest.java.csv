commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;@Test public void testGetReturnType() throws Exception {     OrcTableSource orc = OrcTableSource.builder().path(getPath(TEST_FILE_NESTED)).forOrcSchema(TEST_SCHEMA_NESTED).build().     TypeInformation<Row> returnType = orc.getReturnType().     assertNotNull(returnType).     assertTrue(returnType instanceof RowTypeInfo).     RowTypeInfo rowType = (RowTypeInfo) returnType.     TypeInformation<Row> expected = Types.ROW_NAMED(getNestedFieldNames(), getNestedFieldTypes()).     assertEquals(expected, rowType). }
false;public;0;13;;@Test public void testGetTableSchema() throws Exception {     OrcTableSource orc = OrcTableSource.builder().path(getPath(TEST_FILE_NESTED)).forOrcSchema(TEST_SCHEMA_NESTED).build().     TableSchema schema = orc.getTableSchema().     assertNotNull(schema).     assertArrayEquals(getNestedFieldNames(), schema.getFieldNames()).     assertArrayEquals(getNestedFieldTypes(), schema.getFieldTypes()). }
false;public;0;35;;@Test @SuppressWarnings("unchecked") public void testProjectFields() throws Exception {     OrcTableSource orc = OrcTableSource.builder().path(getPath(TEST_FILE_NESTED)).forOrcSchema(TEST_SCHEMA_NESTED).build().     OrcTableSource projected = (OrcTableSource) orc.projectFields(new int[] { 3, 5, 1, 0 }).     // ensure copy is returned     assertTrue(orc != projected).     // ensure table schema is identical     assertEquals(orc.getTableSchema(), projected.getTableSchema()).     // ensure return type was adapted     String[] fieldNames = getNestedFieldNames().     TypeInformation[] fieldTypes = getNestedFieldTypes().     assertEquals(Types.ROW_NAMED(new String[] { fieldNames[3], fieldNames[5], fieldNames[1], fieldNames[0] }, new TypeInformation[] { fieldTypes[3], fieldTypes[5], fieldTypes[1], fieldTypes[0] }), projected.getReturnType()).     // ensure IF is configured with selected fields     OrcTableSource spyTS = spy(projected).     OrcRowInputFormat mockIF = mock(OrcRowInputFormat.class).     doReturn(mockIF).when(spyTS).buildOrcInputFormat().     ExecutionEnvironment env = mock(ExecutionEnvironment.class).     when(env.createInput(any(InputFormat.class))).thenReturn(mock(DataSource.class)).     spyTS.getDataSet(env).     verify(mockIF).selectFields(eq(3), eq(5), eq(1), eq(0)). }
false;public;0;75;;@Test @SuppressWarnings("unchecked") public void testApplyPredicate() throws Exception {     OrcTableSource orc = OrcTableSource.builder().path(getPath(TEST_FILE_NESTED)).forOrcSchema(TEST_SCHEMA_NESTED).build().     // expressions for supported predicates     Expression pred1 = new GreaterThan(new ResolvedFieldReference("int1", Types.INT), new Literal(100, Types.INT)).     Expression pred2 = new EqualTo(new ResolvedFieldReference("string1", Types.STRING), new Literal("hello", Types.STRING)).     // unsupported predicate     Expression unsupportedPred = new EqualTo(new GetCompositeField(new ItemAt(new ResolvedFieldReference("list", ObjectArrayTypeInfo.getInfoFor(Types.ROW_NAMED(new String[] { "int1", "string1" }, Types.INT, Types.STRING))), new Literal(1, Types.INT)), "int1"), new Literal(1, Types.INT)).     // invalid predicate     Expression invalidPred = new EqualTo(new ResolvedFieldReference("long1", Types.LONG), // some invalid, non-serializable literal (here an object of this test class)     new Literal(new OrcTableSourceTest(), Types.LONG)).     ArrayList<Expression> preds = new ArrayList<>().     preds.add(pred1).     preds.add(pred2).     preds.add(unsupportedPred).     preds.add(invalidPred).     // apply predicates on TableSource     OrcTableSource projected = (OrcTableSource) orc.applyPredicate(preds).     // ensure copy is returned     assertTrue(orc != projected).     // ensure table schema is identical     assertEquals(orc.getTableSchema(), projected.getTableSchema()).     // ensure return type is identical     assertEquals(Types.ROW_NAMED(getNestedFieldNames(), getNestedFieldTypes()), projected.getReturnType()).     // ensure IF is configured with valid/supported predicates     OrcTableSource spyTS = spy(projected).     OrcRowInputFormat mockIF = mock(OrcRowInputFormat.class).     doReturn(mockIF).when(spyTS).buildOrcInputFormat().     ExecutionEnvironment environment = mock(ExecutionEnvironment.class).     when(environment.createInput(any(InputFormat.class))).thenReturn(mock(DataSource.class)).     spyTS.getDataSet(environment).     ArgumentCaptor<OrcRowInputFormat.Predicate> arguments = ArgumentCaptor.forClass(OrcRowInputFormat.Predicate.class).     verify(mockIF, times(2)).addPredicate(arguments.capture()).     List<String> values = arguments.getAllValues().stream().map(Object::toString).collect(Collectors.toList()).     assertTrue(values.contains(new OrcRowInputFormat.Not(new OrcRowInputFormat.LessThanEquals("int1", PredicateLeaf.Type.LONG, 100)).toString())).     assertTrue(values.contains(new OrcRowInputFormat.Equals("string1", PredicateLeaf.Type.STRING, "hello").toString())).     // ensure filter pushdown is correct     assertTrue(spyTS.isFilterPushedDown()).     assertFalse(orc.isFilterPushedDown()). }
false;public;0;49;;@Test public void testBuilder() throws Exception {     // validate path, schema, and recursive enumeration default (enabled)     OrcTableSource orc1 = OrcTableSource.builder().path(getPath(TEST_FILE_NESTED)).forOrcSchema(TEST_SCHEMA_NESTED).build().     DataSet<Row> rows1 = orc1.getDataSet(ExecutionEnvironment.createLocalEnvironment()).     OrcRowInputFormat orcIF1 = (OrcRowInputFormat) ((DataSource) rows1).getInputFormat().     assertEquals(true, orcIF1.getNestedFileEnumeration()).     assertEquals(getPath(TEST_FILE_NESTED), orcIF1.getFilePath().toString()).     assertEquals(TEST_SCHEMA_NESTED, orcIF1.getSchema()).     // validate recursive enumeration disabled     OrcTableSource orc2 = OrcTableSource.builder().path(getPath(TEST_FILE_NESTED), false).forOrcSchema(TEST_SCHEMA_NESTED).build().     DataSet<Row> rows2 = orc2.getDataSet(ExecutionEnvironment.createLocalEnvironment()).     OrcRowInputFormat orcIF2 = (OrcRowInputFormat) ((DataSource) rows2).getInputFormat().     assertEquals(false, orcIF2.getNestedFileEnumeration()).     // validate Hadoop configuration     Configuration conf = new Configuration().     conf.set("testKey", "testValue").     OrcTableSource orc3 = OrcTableSource.builder().path(getPath(TEST_FILE_NESTED)).forOrcSchema(TEST_SCHEMA_NESTED).withConfiguration(conf).build().     DataSet<Row> rows3 = orc3.getDataSet(ExecutionEnvironment.createLocalEnvironment()).     OrcRowInputFormat orcIF3 = (OrcRowInputFormat) ((DataSource) rows3).getInputFormat().     assertEquals(conf, orcIF3.getConfiguration()).     // validate batch size     OrcTableSource orc4 = OrcTableSource.builder().path(getPath(TEST_FILE_NESTED)).forOrcSchema(TEST_SCHEMA_NESTED).withBatchSize(987).build().     DataSet<Row> rows4 = orc4.getDataSet(ExecutionEnvironment.createLocalEnvironment()).     OrcRowInputFormat orcIF4 = (OrcRowInputFormat) ((DataSource) rows4).getInputFormat().     assertEquals(987, orcIF4.getBatchSize()). }
false;private;1;3;;private String getPath(String fileName) {     return getClass().getClassLoader().getResource(fileName).getPath(). }
false;private;0;5;;private String[] getNestedFieldNames() {     return new String[] { "boolean1", "byte1", "short1", "int1", "long1", "float1", "double1", "bytes1", "string1", "middle", "list", "map" }. }
false;private;0;28;;private TypeInformation[] getNestedFieldTypes() {     return new TypeInformation[] { Types.BOOLEAN, Types.BYTE, Types.SHORT, Types.INT, Types.LONG, Types.FLOAT, Types.DOUBLE, PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO, Types.STRING, Types.ROW_NAMED(new String[] { "list" }, ObjectArrayTypeInfo.getInfoFor(Types.ROW_NAMED(new String[] { "int1", "string1" }, Types.INT, Types.STRING))), ObjectArrayTypeInfo.getInfoFor(Types.ROW_NAMED(new String[] { "int1", "string1" }, Types.INT, Types.STRING)), new MapTypeInfo<>(Types.STRING, Types.ROW_NAMED(new String[] { "int1", "string1" }, Types.INT, Types.STRING)) }. }
