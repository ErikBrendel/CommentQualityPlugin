commented;modifiers;parameterAmount;loc;comment;code
false;public;1;14;;@Override public DataSet<Row> getDataSet(ExecutionEnvironment execEnv) {     OrcRowInputFormat orcIF = buildOrcInputFormat().     orcIF.setNestedFileEnumeration(recursiveEnumeration).     if (selectedFields != null) {         orcIF.selectFields(selectedFields).     }     if (predicates != null) {         for (OrcRowInputFormat.Predicate pred : predicates) {             orcIF.addPredicate(pred).         }     }     return execEnv.createInput(orcIF).name(explainSource()). }
false;protected;0;4;;@VisibleForTesting protected OrcRowInputFormat buildOrcInputFormat() {     return new OrcRowInputFormat(path, orcSchema, orcConfig, batchSize). }
false;public;0;4;;@Override public TypeInformation<Row> getReturnType() {     return typeInfo. }
false;public;0;4;;@Override public TableSchema getTableSchema() {     return this.tableSchema. }
false;public;1;5;;@Override public TableSource<Row> projectFields(int[] selectedFields) {     // create a copy of the OrcTableSouce with new selected fields     return new OrcTableSource(path, orcSchema, orcConfig, batchSize, recursiveEnumeration, selectedFields, predicates). }
false;public;1;17;;@Override public TableSource<Row> applyPredicate(List<Expression> predicates) {     ArrayList<Predicate> orcPredicates = new ArrayList<>().     // we do not remove any predicates from the list because ORC does not fully apply predicates     for (Expression pred : predicates) {         Predicate orcPred = toOrcPredicate(pred).         if (orcPred != null) {             LOG.info("Predicate [{}] converted into OrcPredicate [{}] and pushed into OrcTableSource for path {}.", pred, orcPred, path).             orcPredicates.add(orcPred).         } else {             LOG.info("Predicate [{}] could not be pushed into OrcTableSource for path {}.", pred, path).         }     }     return new OrcTableSource(path, orcSchema, orcConfig, batchSize, recursiveEnumeration, selectedFields, orcPredicates.toArray(new Predicate[] {})). }
false;public;0;4;;@Override public boolean isFilterPushedDown() {     return this.predicates != null. }
false;public;0;4;;@Override public String explainSource() {     return "OrcFile[path=" + path + ", schema=" + orcSchema + ", filter=" + predicateString() + "]". }
false;private;0;7;;private String predicateString() {     if (predicates != null) {         return "AND(" + Arrays.toString(predicates) + ")".     } else {         return "TRUE".     } }
false;private;1;120;;// Predicate conversion for filter push-down. private Predicate toOrcPredicate(Expression pred) {     if (pred instanceof Or) {         Predicate c1 = toOrcPredicate(((Or) pred).left()).         Predicate c2 = toOrcPredicate(((Or) pred).right()).         if (c1 == null || c2 == null) {             return null.         } else {             return new OrcRowInputFormat.Or(c1, c2).         }     } else if (pred instanceof Not) {         Predicate c = toOrcPredicate(((Not) pred).child()).         if (c == null) {             return null.         } else {             return new OrcRowInputFormat.Not(c).         }     } else if (pred instanceof BinaryComparison) {         BinaryComparison binComp = (BinaryComparison) pred.         if (!isValid(binComp)) {             // not a valid predicate             LOG.debug("Unsupported predicate [{}] cannot be pushed into OrcTableSource.", pred).             return null.         }         PredicateLeaf.Type litType = getLiteralType(binComp).         if (litType == null) {             // unsupported literal type             LOG.debug("Unsupported predicate [{}] cannot be pushed into OrcTableSource.", pred).             return null.         }         boolean literalOnRight = literalOnRight(binComp).         String colName = getColumnName(binComp).         // fetch literal and ensure it is serializable         Object literalObj = getLiteral(binComp).         Serializable literal.         // validate that literal is serializable         if (literalObj instanceof Serializable) {             literal = (Serializable) literalObj.         } else {             LOG.warn("Encountered a non-serializable literal of type {}. " + "Cannot push predicate [{}] into OrcTableSource. " + "This is a bug and should be reported.", literalObj.getClass().getCanonicalName(), pred).             return null.         }         if (pred instanceof EqualTo) {             return new OrcRowInputFormat.Equals(colName, litType, literal).         } else if (pred instanceof NotEqualTo) {             return new OrcRowInputFormat.Not(new OrcRowInputFormat.Equals(colName, litType, literal)).         } else if (pred instanceof GreaterThan) {             if (literalOnRight) {                 return new OrcRowInputFormat.Not(new OrcRowInputFormat.LessThanEquals(colName, litType, literal)).             } else {                 return new OrcRowInputFormat.LessThan(colName, litType, literal).             }         } else if (pred instanceof GreaterThanOrEqual) {             if (literalOnRight) {                 return new OrcRowInputFormat.Not(new OrcRowInputFormat.LessThan(colName, litType, literal)).             } else {                 return new OrcRowInputFormat.LessThanEquals(colName, litType, literal).             }         } else if (pred instanceof LessThan) {             if (literalOnRight) {                 return new OrcRowInputFormat.LessThan(colName, litType, literal).             } else {                 return new OrcRowInputFormat.Not(new OrcRowInputFormat.LessThanEquals(colName, litType, literal)).             }         } else if (pred instanceof LessThanOrEqual) {             if (literalOnRight) {                 return new OrcRowInputFormat.LessThanEquals(colName, litType, literal).             } else {                 return new OrcRowInputFormat.Not(new OrcRowInputFormat.LessThan(colName, litType, literal)).             }         } else {             // unsupported predicate             LOG.debug("Unsupported predicate [{}] cannot be pushed into OrcTableSource.", pred).             return null.         }     } else if (pred instanceof UnaryExpression) {         UnaryExpression unary = (UnaryExpression) pred.         if (!isValid(unary)) {             // not a valid predicate             LOG.debug("Unsupported predicate [{}] cannot be pushed into OrcTableSource.", pred).             return null.         }         PredicateLeaf.Type colType = toOrcType(((UnaryExpression) pred).child().resultType()).         if (colType == null) {             // unsupported type             LOG.debug("Unsupported predicate [{}] cannot be pushed into OrcTableSource.", pred).             return null.         }         String colName = getColumnName(unary).         if (pred instanceof IsNull) {             return new OrcRowInputFormat.IsNull(colName, colType).         } else if (pred instanceof IsNotNull) {             return new OrcRowInputFormat.Not(new OrcRowInputFormat.IsNull(colName, colType)).         } else {             // unsupported predicate             LOG.debug("Unsupported predicate [{}] cannot be pushed into OrcTableSource.", pred).             return null.         }     } else {         // unsupported predicate         LOG.debug("Unsupported predicate [{}] cannot be pushed into OrcTableSource.", pred).         return null.     } }
false;private;1;3;;private boolean isValid(UnaryExpression unary) {     return unary.child() instanceof Attribute. }
false;private;1;4;;private boolean isValid(BinaryComparison comp) {     return (comp.left() instanceof Literal && comp.right() instanceof Attribute) || (comp.left() instanceof Attribute && comp.right() instanceof Literal). }
false;private;1;9;;private boolean literalOnRight(BinaryComparison comp) {     if (comp.left() instanceof Literal && comp.right() instanceof Attribute) {         return false.     } else if (comp.left() instanceof Attribute && comp.right() instanceof Literal) {         return true.     } else {         throw new RuntimeException("Invalid binary comparison.").     } }
false;private;1;3;;private String getColumnName(UnaryExpression unary) {     return ((Attribute) unary.child()).name(). }
false;private;1;7;;private String getColumnName(BinaryComparison comp) {     if (literalOnRight(comp)) {         return ((Attribute) comp.left()).name().     } else {         return ((Attribute) comp.right()).name().     } }
false;private;1;7;;private PredicateLeaf.Type getLiteralType(BinaryComparison comp) {     if (literalOnRight(comp)) {         return toOrcType(((Literal) comp.right()).resultType()).     } else {         return toOrcType(((Literal) comp.left()).resultType()).     } }
false;private;1;7;;private Object getLiteral(BinaryComparison comp) {     if (literalOnRight(comp)) {         return ((Literal) comp.right()).value().     } else {         return ((Literal) comp.left()).value().     } }
false;private;1;24;;private PredicateLeaf.Type toOrcType(TypeInformation<?> type) {     if (type == BasicTypeInfo.BYTE_TYPE_INFO || type == BasicTypeInfo.SHORT_TYPE_INFO || type == BasicTypeInfo.INT_TYPE_INFO || type == BasicTypeInfo.LONG_TYPE_INFO) {         return PredicateLeaf.Type.LONG.     } else if (type == BasicTypeInfo.FLOAT_TYPE_INFO || type == BasicTypeInfo.DOUBLE_TYPE_INFO) {         return PredicateLeaf.Type.FLOAT.     } else if (type == BasicTypeInfo.BOOLEAN_TYPE_INFO) {         return PredicateLeaf.Type.BOOLEAN.     } else if (type == BasicTypeInfo.STRING_TYPE_INFO) {         return PredicateLeaf.Type.STRING.     } else if (type == SqlTimeTypeInfo.TIMESTAMP) {         return PredicateLeaf.Type.TIMESTAMP.     } else if (type == SqlTimeTypeInfo.DATE) {         return PredicateLeaf.Type.DATE.     } else if (type == BasicTypeInfo.BIG_DEC_TYPE_INFO) {         return PredicateLeaf.Type.DECIMAL.     } else {         // unsupported type         return null.     } }
false;public,static;0;3;;// Builder public static Builder builder() {     return new Builder(). }
true;public;1;6;/**  * Sets the path of the ORC file(s).  * If the path specifies a directory, it will be recursively enumerated.  *  * @param path The path of the ORC file(s).  * @return The builder.  */ ;/**  * Sets the path of the ORC file(s).  * If the path specifies a directory, it will be recursively enumerated.  *  * @param path The path of the ORC file(s).  * @return The builder.  */ public Builder path(String path) {     Preconditions.checkNotNull(path, "Path must not be null.").     Preconditions.checkArgument(!path.isEmpty(), "Path must not be empty.").     this.path = path.     return this. }
true;public;2;7;/**  * Sets the path of the ORC file(s).  *  * @param path The path of the ORC file(s).  * @param recursive Flag whether the to enumerate  * @return The builder.  */ ;/**  * Sets the path of the ORC file(s).  *  * @param path The path of the ORC file(s).  * @param recursive Flag whether the to enumerate  * @return The builder.  */ public Builder path(String path, boolean recursive) {     Preconditions.checkNotNull(path, "Path must not be null.").     Preconditions.checkArgument(!path.isEmpty(), "Path must not be empty.").     this.path = path.     this.recursive = recursive.     return this. }
true;public;1;5;/**  * Sets the ORC schema of the files to read as a String.  *  * @param orcSchema The ORC schema of the files to read as a String.  * @return The builder.  */ ;/**  * Sets the ORC schema of the files to read as a String.  *  * @param orcSchema The ORC schema of the files to read as a String.  * @return The builder.  */ public Builder forOrcSchema(String orcSchema) {     Preconditions.checkNotNull(orcSchema, "ORC schema must not be null.").     this.schema = TypeDescription.fromString(orcSchema).     return this. }
true;public;1;5;/**  * Sets the ORC schema of the files to read as a {@link TypeDescription}.  *  * @param orcSchema The ORC schema of the files to read as a String.  * @return The builder.  */ ;/**  * Sets the ORC schema of the files to read as a {@link TypeDescription}.  *  * @param orcSchema The ORC schema of the files to read as a String.  * @return The builder.  */ public Builder forOrcSchema(TypeDescription orcSchema) {     Preconditions.checkNotNull(orcSchema, "ORC Schema must not be null.").     this.schema = orcSchema.     return this. }
true;public;1;5;/**  * Sets a Hadoop {@link Configuration} for the ORC reader. If no configuration is configured,  * an empty configuration is used.  *  * @param config The Hadoop Configuration for the ORC reader.  * @return The builder.  */ ;/**  * Sets a Hadoop {@link Configuration} for the ORC reader. If no configuration is configured,  * an empty configuration is used.  *  * @param config The Hadoop Configuration for the ORC reader.  * @return The builder.  */ public Builder withConfiguration(Configuration config) {     Preconditions.checkNotNull(config, "Configuration must not be null.").     this.config = config.     return this. }
true;public;1;5;/**  * Sets the number of rows that are read in a batch. If not configured, the ORC files are  * read with a batch size of 1000.  *  * @param batchSize The number of rows that are read in a batch.  * @return The builder.  */ ;/**  * Sets the number of rows that are read in a batch. If not configured, the ORC files are  * read with a batch size of 1000.  *  * @param batchSize The number of rows that are read in a batch.  * @return The builder.  */ public Builder withBatchSize(int batchSize) {     Preconditions.checkArgument(batchSize > 0, "Batch size must be greater than zero.").     this.batchSize = batchSize.     return this. }
true;public;0;12;/**  * Builds the OrcTableSource for this builder.  *  * @return The OrcTableSource for this builder.  */ ;/**  * Builds the OrcTableSource for this builder.  *  * @return The OrcTableSource for this builder.  */ public OrcTableSource build() {     Preconditions.checkNotNull(this.path, "Path must not be null.").     Preconditions.checkNotNull(this.schema, "ORC schema must not be null.").     if (this.config == null) {         this.config = new Configuration().     }     if (this.batchSize == 0) {         // set default batch size         this.batchSize = DEFAULT_BATCH_SIZE.     }     return new OrcTableSource(this.path, this.schema, this.config, this.batchSize, this.recursive). }
