commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// ------------------------------------------------------------------------ // test produce / consumer // ------------------------------------------------------------------------ @Test public void testWithVariableProducer() throws Exception {     runProducerConsumerTest(500, 2, 0). }
false;public;0;4;;@Test public void testWithVariableConsumer() throws Exception {     runProducerConsumerTest(500, 0, 2). }
false;public;0;4;;@Test public void testWithVariableBoth() throws Exception {     runProducerConsumerTest(500, 2, 2). }
false;public;0;15;;// ------------------------------------------------------------------------ // test error propagation // ------------------------------------------------------------------------ @Test public void testPublishErrorOnEmptyHandover() throws Exception {     final Handover handover = new Handover().     Exception error = new Exception().     handover.reportError(error).     try {         handover.pollNext().         fail("should throw an exception").     } catch (Exception e) {         assertEquals(error, e).     } }
false;public;0;16;;@Test public void testPublishErrorOnFullHandover() throws Exception {     final Handover handover = new Handover().     handover.produce(createTestRecords()).     IOException error = new IOException().     handover.reportError(error).     try {         handover.pollNext().         fail("should throw an exception").     } catch (Exception e) {         assertEquals(error, e).     } }
false;public;0;15;;@Test public void testExceptionMarksClosedOnEmpty() throws Exception {     final Handover handover = new Handover().     IllegalStateException error = new IllegalStateException().     handover.reportError(error).     try {         handover.produce(createTestRecords()).         fail("should throw an exception").     } catch (Handover.ClosedException e) {     // expected     } }
false;public;0;16;;@Test public void testExceptionMarksClosedOnFull() throws Exception {     final Handover handover = new Handover().     handover.produce(createTestRecords()).     LinkageError error = new LinkageError().     handover.reportError(error).     try {         handover.produce(createTestRecords()).         fail("should throw an exception").     } catch (Handover.ClosedException e) {     // expected     } }
false;public;0;13;;// ------------------------------------------------------------------------ // test closing behavior // ------------------------------------------------------------------------ @Test public void testCloseEmptyForConsumer() throws Exception {     final Handover handover = new Handover().     handover.close().     try {         handover.pollNext().         fail("should throw an exception").     } catch (Handover.ClosedException e) {     // expected     } }
false;public;0;14;;@Test public void testCloseFullForConsumer() throws Exception {     final Handover handover = new Handover().     handover.produce(createTestRecords()).     handover.close().     try {         handover.pollNext().         fail("should throw an exception").     } catch (Handover.ClosedException e) {     // expected     } }
false;public;0;13;;@Test public void testCloseEmptyForProducer() throws Exception {     final Handover handover = new Handover().     handover.close().     try {         handover.produce(createTestRecords()).         fail("should throw an exception").     } catch (Handover.ClosedException e) {     // expected     } }
false;public;0;14;;@Test public void testCloseFullForProducer() throws Exception {     final Handover handover = new Handover().     handover.produce(createTestRecords()).     handover.close().     try {         handover.produce(createTestRecords()).         fail("should throw an exception").     } catch (Handover.ClosedException e) {     // expected     } }
false;public;0;35;;// ------------------------------------------------------------------------ // test wake up behavior // ------------------------------------------------------------------------ @Test public void testWakeupDoesNotWakeWhenEmpty() throws Exception {     Handover handover = new Handover().     handover.wakeupProducer().     // produce into a woken but empty handover     try {         handover.produce(createTestRecords()).     } catch (Handover.WakeupException e) {         fail().     }     // handover now has records, next time we wakeup and produce it needs     // to throw an exception     handover.wakeupProducer().     try {         handover.produce(createTestRecords()).         fail("should throw an exception").     } catch (Handover.WakeupException e) {     // expected     }     // empty the handover     assertNotNull(handover.pollNext()).     // producing into an empty handover should work     try {         handover.produce(createTestRecords()).     } catch (Handover.WakeupException e) {         fail().     } }
false;public;0;4;;@Override public void go() throws Exception {     handover.produce(createTestRecords()). }
false;public;0;30;;@Test public void testWakeupWakesOnlyOnce() throws Exception {     // create a full handover     final Handover handover = new Handover().     handover.produce(createTestRecords()).     handover.wakeupProducer().     try {         handover.produce(createTestRecords()).         fail().     } catch (WakeupException e) {     // expected     }     CheckedThread producer = new CheckedThread() {          @Override         public void go() throws Exception {             handover.produce(createTestRecords()).         }     }.     producer.start().     // the producer must go blocking     producer.waitUntilThreadHoldsLock(10000).     // release the thread by consuming something     assertNotNull(handover.pollNext()).     producer.sync(). }
false;private;3;20;;// ------------------------------------------------------------------------ // utilities // ------------------------------------------------------------------------ private void runProducerConsumerTest(int numRecords, int maxProducerDelay, int maxConsumerDelay) throws Exception {     // generate test data     @SuppressWarnings({ "unchecked", "rawtypes" })     final ConsumerRecords<byte[], byte[]>[] data = new ConsumerRecords[numRecords].     for (int i = 0. i < numRecords. i++) {         data[i] = createTestRecords().     }     final Handover handover = new Handover().     ProducerThread producer = new ProducerThread(handover, data, maxProducerDelay).     ConsumerThread consumer = new ConsumerThread(handover, data, maxConsumerDelay).     consumer.start().     producer.start().     // sync first on the consumer, so it propagates assertion errors     consumer.sync().     producer.sync(). }
false;private,static;0;4;;@SuppressWarnings("unchecked") private static ConsumerRecords<byte[], byte[]> createTestRecords() {     return mock(ConsumerRecords.class). }
false;public,abstract;0;1;;public abstract void go() throws Exception.
false;public;0;9;;@Override public void run() {     try {         go().     } catch (Throwable t) {         error = t.     } }
false;public;0;6;;public void sync() throws Exception {     join().     if (error != null) {         ExceptionUtils.rethrowException(error, error.getMessage()).     } }
false;public;1;11;;public void waitUntilThreadHoldsLock(long timeoutMillis) throws InterruptedException, TimeoutException {     final long deadline = System.nanoTime() + timeoutMillis * 1_000_000.     while (!isBlockedOrWaiting() && (System.nanoTime() < deadline)) {         Thread.sleep(1).     }     if (!isBlockedOrWaiting()) {         throw new TimeoutException().     } }
false;private;0;4;;private boolean isBlockedOrWaiting() {     State state = getState().     return state == State.BLOCKED || state == State.WAITING || state == State.TIMED_WAITING. }
false;public;0;11;;@Override public void go() throws Exception {     for (ConsumerRecords<byte[], byte[]> rec : data) {         handover.produce(rec).         if (maxDelay > 0) {             int delay = rnd.nextInt(maxDelay).             Thread.sleep(delay).         }     } }
false;public;0;13;;@Override public void go() throws Exception {     for (ConsumerRecords<byte[], byte[]> rec : data) {         ConsumerRecords<byte[], byte[]> next = handover.pollNext().         assertEquals(rec, next).         if (maxDelay > 0) {             int delay = rnd.nextInt(maxDelay).             Thread.sleep(delay).         }     } }
