commented;modifiers;parameterAmount;loc;comment;code
false;public;1;18;;@Override public void configure(Configuration parameters) {     LOG.info("Initializing HBase configuration.").     connectToTable().     if (table != null) {         scan = getScanner().     }     // prepare output rows     this.resultRow = new Row(families.length).     this.familyRows = new Row[families.length].     for (int f = 0. f < families.length. f++) {         this.familyRows[f] = new Row(qualifiers[f].length).         this.resultRow.setField(f, this.familyRows[f]).     }     this.stringCharset = Charset.forName(schema.getStringCharset()). }
false;protected;0;12;;@Override protected Scan getScanner() {     Scan scan = new Scan().     for (int f = 0. f < families.length. f++) {         byte[] family = families[f].         for (int q = 0. q < qualifiers[f].length. q++) {             byte[] quantifier = qualifiers[f][q].             scan.addColumn(family, quantifier).         }     }     return scan. }
false;public;0;4;;@Override public String getTableName() {     return tableName. }
false;protected;1;23;;@Override protected Row mapResultToOutType(Result res) {     for (int f = 0. f < this.families.length. f++) {         // get family key         byte[] familyKey = families[f].         Row familyRow = familyRows[f].         for (int q = 0. q < this.qualifiers[f].length. q++) {             // get quantifier key             byte[] qualifier = qualifiers[f][q].             // get quantifier type idx             int typeIdx = types[f][q].             // read value             byte[] value = res.getValue(familyKey, qualifier).             if (value != null) {                 familyRow.setField(q, deserialize(value, typeIdx)).             } else {                 familyRow.setField(q, null).             }         }         resultRow.setField(f, familyRow).     }     return resultRow. }
false;private;0;17;;private void connectToTable() {     if (this.conf == null) {         this.conf = HBaseConfiguration.create().     }     try {         Connection conn = ConnectionFactory.createConnection(conf).         super.table = (HTable) conn.getTable(TableName.valueOf(tableName)).     } catch (TableNotFoundException tnfe) {         LOG.error("The table " + tableName + " not found ", tnfe).         throw new RuntimeException("HBase table '" + tableName + "' not found.", tnfe).     } catch (IOException ioe) {         LOG.error("Exception while creating connection to HBase.", ioe).         throw new RuntimeException("Cannot create connection to HBase.", ioe).     } }
false;public;0;12;;@Override public TypeInformation<Row> getProducedType() {     // split the fieldNames     String[] famNames = schema.getFamilyNames().     TypeInformation<?>[] typeInfos = new TypeInformation[famNames.length].     int i = 0.     for (String family : famNames) {         typeInfos[i] = new RowTypeInfo(schema.getQualifierTypes(family), schema.getQualifierNames(family)).         i++.     }     return new RowTypeInfo(typeInfos, famNames). }
false;private;2;35;;private Object deserialize(byte[] value, int typeIdx) {     switch(typeIdx) {         case // byte[]         0:             return value.         case 1:             return new String(value, stringCharset).         case // byte         2:             return value[0].         case 3:             return Bytes.toShort(value).         case 4:             return Bytes.toInt(value).         case 5:             return Bytes.toLong(value).         case 6:             return Bytes.toFloat(value).         case 7:             return Bytes.toDouble(value).         case 8:             return Bytes.toBoolean(value).         case // sql.Timestamp encoded as long         9:             return new Timestamp(Bytes.toLong(value)).         case // sql.Date encoded as long         10:             return new Date(Bytes.toLong(value)).         case // sql.Time encoded as long         11:             return new Time(Bytes.toLong(value)).         case 12:             return Bytes.toBigDecimal(value).         case 13:             return new BigInteger(value).         default:             throw new IllegalArgumentException("Unknown type index " + typeIdx).     } }
false;private,static;1;33;;private static int getTypeIndex(Class<?> clazz) {     if (byte[].class.equals(clazz)) {         return 0.     } else if (String.class.equals(clazz)) {         return 1.     } else if (Byte.class.equals(clazz)) {         return 2.     } else if (Short.class.equals(clazz)) {         return 3.     } else if (Integer.class.equals(clazz)) {         return 4.     } else if (Long.class.equals(clazz)) {         return 5.     } else if (Float.class.equals(clazz)) {         return 6.     } else if (Double.class.equals(clazz)) {         return 7.     } else if (Boolean.class.equals(clazz)) {         return 8.     } else if (Timestamp.class.equals(clazz)) {         return 9.     } else if (Date.class.equals(clazz)) {         return 10.     } else if (Time.class.equals(clazz)) {         return 11.     } else if (BigDecimal.class.equals(clazz)) {         return 12.     } else if (BigInteger.class.equals(clazz)) {         return 13.     } else {         return -1.     } }
false;static;1;3;;static boolean isSupportedType(Class<?> clazz) {     return getTypeIndex(clazz) != -1. }
