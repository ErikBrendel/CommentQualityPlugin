commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;6;;@BeforeClass public static void activateHBaseCluster() throws IOException {     registerHBaseMiniClusterInClasspath().     prepareTable().     LimitNetworkBuffersTestEnvironment.setAsContext(). }
false;public,static;0;4;;@AfterClass public static void resetExecutionEnvironmentFactory() {     LimitNetworkBuffersTestEnvironment.unsetAsContext(). }
false;private,static;0;31;;private static void prepareTable() throws IOException {     // create a table     TableName tableName = TableName.valueOf(TEST_TABLE).     // column families     byte[][] families = new byte[][] { Bytes.toBytes(FAMILY1), Bytes.toBytes(FAMILY2), Bytes.toBytes(FAMILY3) }.     // split keys     byte[][] splitKeys = new byte[][] { Bytes.toBytes(4) }.     createTable(tableName, families, splitKeys).     // get the HTable instance     HTable table = openTable(tableName).     List<Put> puts = new ArrayList<>().     // add some data     puts.add(putRow(1, 10, "Hello-1", 100L, 1.01, false, "Welt-1")).     puts.add(putRow(2, 20, "Hello-2", 200L, 2.02, true, "Welt-2")).     puts.add(putRow(3, 30, "Hello-3", 300L, 3.03, false, "Welt-3")).     puts.add(putRow(4, 40, null, 400L, 4.04, true, "Welt-4")).     puts.add(putRow(5, 50, "Hello-5", 500L, 5.05, false, "Welt-5")).     puts.add(putRow(6, 60, "Hello-6", 600L, 6.06, true, "Welt-6")).     puts.add(putRow(7, 70, "Hello-7", 700L, 7.07, false, "Welt-7")).     puts.add(putRow(8, 80, null, 800L, 8.08, true, "Welt-8")).     // append rows to table     table.put(puts).     table.close(). }
false;private,static;7;16;;private static Put putRow(int rowKey, int f1c1, String f2c1, long f2c2, double f3c1, boolean f3c2, String f3c3) {     Put put = new Put(Bytes.toBytes(rowKey)).     // family 1     put.addColumn(Bytes.toBytes(FAMILY1), Bytes.toBytes(F1COL1), Bytes.toBytes(f1c1)).     // family 2     if (f2c1 != null) {         put.addColumn(Bytes.toBytes(FAMILY2), Bytes.toBytes(F2COL1), Bytes.toBytes(f2c1)).     }     put.addColumn(Bytes.toBytes(FAMILY2), Bytes.toBytes(F2COL2), Bytes.toBytes(f2c2)).     // family 3     put.addColumn(Bytes.toBytes(FAMILY3), Bytes.toBytes(F3COL1), Bytes.toBytes(f3c1)).     put.addColumn(Bytes.toBytes(FAMILY3), Bytes.toBytes(F3COL2), Bytes.toBytes(f3c2)).     put.addColumn(Bytes.toBytes(FAMILY3), Bytes.toBytes(F3COL3), Bytes.toBytes(f3c3)).     return put. }
false;public;0;40;;// ######## HBaseTableSource tests ############ @Test public void testTableSourceFullScan() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     BatchTableEnvironment tableEnv = BatchTableEnvironment.create(env, new TableConfig()).     HBaseTableSource hbaseTable = new HBaseTableSource(getConf(), TEST_TABLE).     hbaseTable.addColumn(FAMILY1, F1COL1, Integer.class).     hbaseTable.addColumn(FAMILY2, F2COL1, String.class).     hbaseTable.addColumn(FAMILY2, F2COL2, Long.class).     hbaseTable.addColumn(FAMILY3, F3COL1, Double.class).     hbaseTable.addColumn(FAMILY3, F3COL2, Boolean.class).     hbaseTable.addColumn(FAMILY3, F3COL3, String.class).     tableEnv.registerTableSource("hTable", hbaseTable).     Table result = tableEnv.sqlQuery("SELECT " + "  h.family1.col1, " + "  h.family2.col1, " + "  h.family2.col2, " + "  h.family3.col1, " + "  h.family3.col2, " + "  h.family3.col3 " + "FROM hTable AS h").     DataSet<Row> resultSet = tableEnv.toDataSet(result, Row.class).     List<Row> results = resultSet.collect().     String expected = "10,Hello-1,100,1.01,false,Welt-1\n" + "20,Hello-2,200,2.02,true,Welt-2\n" + "30,Hello-3,300,3.03,false,Welt-3\n" + "40,null,400,4.04,true,Welt-4\n" + "50,Hello-5,500,5.05,false,Welt-5\n" + "60,Hello-6,600,6.06,true,Welt-6\n" + "70,Hello-7,700,7.07,false,Welt-7\n" + "80,null,800,8.08,true,Welt-8\n".     TestBaseUtils.compareResultAsText(results, expected). }
false;public;0;38;;@Test public void testTableSourceProjection() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     BatchTableEnvironment tableEnv = BatchTableEnvironment.create(env, new TableConfig()).     HBaseTableSource hbaseTable = new HBaseTableSource(getConf(), TEST_TABLE).     hbaseTable.addColumn(FAMILY1, F1COL1, Integer.class).     hbaseTable.addColumn(FAMILY2, F2COL1, String.class).     hbaseTable.addColumn(FAMILY2, F2COL2, Long.class).     hbaseTable.addColumn(FAMILY3, F3COL1, Double.class).     hbaseTable.addColumn(FAMILY3, F3COL2, Boolean.class).     hbaseTable.addColumn(FAMILY3, F3COL3, String.class).     tableEnv.registerTableSource("hTable", hbaseTable).     Table result = tableEnv.sqlQuery("SELECT " + "  h.family1.col1, " + "  h.family3.col1, " + "  h.family3.col2, " + "  h.family3.col3 " + "FROM hTable AS h").     DataSet<Row> resultSet = tableEnv.toDataSet(result, Row.class).     List<Row> results = resultSet.collect().     String expected = "10,1.01,false,Welt-1\n" + "20,2.02,true,Welt-2\n" + "30,3.03,false,Welt-3\n" + "40,4.04,true,Welt-4\n" + "50,5.05,false,Welt-5\n" + "60,6.06,true,Welt-6\n" + "70,7.07,false,Welt-7\n" + "80,8.08,true,Welt-8\n".     TestBaseUtils.compareResultAsText(results, expected). }
false;public;0;34;;@Test public void testTableSourceFieldOrder() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     BatchTableEnvironment tableEnv = BatchTableEnvironment.create(env, new TableConfig()).     HBaseTableSource hbaseTable = new HBaseTableSource(getConf(), TEST_TABLE).     // shuffle order of column registration     hbaseTable.addColumn(FAMILY2, F2COL1, String.class).     hbaseTable.addColumn(FAMILY3, F3COL1, Double.class).     hbaseTable.addColumn(FAMILY1, F1COL1, Integer.class).     hbaseTable.addColumn(FAMILY2, F2COL2, Long.class).     hbaseTable.addColumn(FAMILY3, F3COL2, Boolean.class).     hbaseTable.addColumn(FAMILY3, F3COL3, String.class).     tableEnv.registerTableSource("hTable", hbaseTable).     Table result = tableEnv.sqlQuery("SELECT * FROM hTable AS h").     DataSet<Row> resultSet = tableEnv.toDataSet(result, Row.class).     List<Row> results = resultSet.collect().     String expected = "Hello-1,100,1.01,false,Welt-1,10\n" + "Hello-2,200,2.02,true,Welt-2,20\n" + "Hello-3,300,3.03,false,Welt-3,30\n" + "null,400,4.04,true,Welt-4,40\n" + "Hello-5,500,5.05,false,Welt-5,50\n" + "Hello-6,600,6.06,true,Welt-6,60\n" + "Hello-7,700,7.07,false,Welt-7,70\n" + "null,800,8.08,true,Welt-8,80\n".     TestBaseUtils.compareResultAsText(results, expected). }
false;public;0;36;;@Test public void testTableSourceReadAsByteArray() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     BatchTableEnvironment tableEnv = BatchTableEnvironment.create(env, new TableConfig()).     // fetch row2 from the table till the end     HBaseTableSource hbaseTable = new HBaseTableSource(getConf(), TEST_TABLE).     hbaseTable.addColumn(FAMILY2, F2COL1, byte[].class).     hbaseTable.addColumn(FAMILY2, F2COL2, byte[].class).     tableEnv.registerTableSource("hTable", hbaseTable).     tableEnv.registerFunction("toUTF8", new ToUTF8()).     tableEnv.registerFunction("toLong", new ToLong()).     Table result = tableEnv.sqlQuery("SELECT " + "  toUTF8(h.family2.col1), " + "  toLong(h.family2.col2) " + "FROM hTable AS h").     DataSet<Row> resultSet = tableEnv.toDataSet(result, Row.class).     List<Row> results = resultSet.collect().     String expected = "Hello-1,100\n" + "Hello-2,200\n" + "Hello-3,300\n" + "null,400\n" + "Hello-5,500\n" + "Hello-6,600\n" + "Hello-7,700\n" + "null,800\n".     TestBaseUtils.compareResultAsText(results, expected). }
false;public;1;3;;public String eval(byte[] bytes) {     return Bytes.toString(bytes). }
false;public;1;3;;public long eval(byte[] bytes) {     return Bytes.toLong(bytes). }
false;protected;0;4;;@Override protected Scan getScanner() {     return new Scan(). }
false;protected;0;4;;@Override protected String getTableName() {     return TEST_TABLE. }
false;protected;1;4;;@Override protected Tuple1<Integer> mapResultToTuple(Result r) {     return new Tuple1<>(Bytes.toInt(r.getValue(Bytes.toBytes(FAMILY1), Bytes.toBytes(F1COL1)))). }
false;public;2;4;;@Override public Tuple1<Integer> reduce(Tuple1<Integer> v1, Tuple1<Integer> v2) throws Exception {     return Tuple1.of(v1.f0 + v2.f0). }
false;public;0;20;;@Test public void testTableInputFormat() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     DataSet<Tuple1<Integer>> result = env.createInput(new InputFormatForTestTable()).reduce(new ReduceFunction<Tuple1<Integer>>() {          @Override         public Tuple1<Integer> reduce(Tuple1<Integer> v1, Tuple1<Integer> v2) throws Exception {             return Tuple1.of(v1.f0 + v2.f0).         }     }).     List<Tuple1<Integer>> resultSet = result.collect().     assertEquals(1, resultSet.size()).     assertEquals(360, (int) resultSet.get(0).f0). }
false;public;0;4;;@Override public ExecutionEnvironment createExecutionEnvironment() {     return le. }
false;public,static;0;13;;public static void setAsContext() {     Configuration config = new Configuration().     // the default network buffers size (10% of heap max =~ 150MB) seems to much for this test case     // 80 MB     config.setString(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX, String.valueOf(80L << 20)).     final LocalEnvironment le = new LocalEnvironment(config).     initializeContextEnvironment(new ExecutionEnvironmentFactory() {          @Override         public ExecutionEnvironment createExecutionEnvironment() {             return le.         }     }). }
false;public,static;0;3;;public static void unsetAsContext() {     resetContextEnvironment(). }
