commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;22;;private static Configuration getClusterConfiguration() {     Configuration config = new Configuration().     try {         File logDir = File.createTempFile("TestBaseUtils-logdir", null).         assertTrue("Unable to delete temp file", logDir.delete()).         assertTrue("Unable to create temp directory", logDir.mkdir()).         File logFile = new File(logDir, "jobmanager.log").         File outFile = new File(logDir, "jobmanager.out").         Files.createFile(logFile.toPath()).         Files.createFile(outFile.toPath()).         config.setString(WebOptions.LOG_PATH, logFile.getAbsolutePath()).         config.setString(ConfigConstants.TASK_MANAGER_LOG_PATH_KEY, logFile.getAbsolutePath()).     } catch (Exception e) {         throw new AssertionError("Could not setup test.", e).     }     config.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, "12m").     config.setBoolean(ConfigConstants.LOCAL_START_WEBSERVER, true).     return config. }
false;public;0;4;;@After public void tearDown() {     BlockingInvokable.reset(). }
false;public;0;11;;@Test public void getFrontPage() {     try {         String fromHTTP = TestBaseUtils.getFromHTTP("http://localhost:" + getRestPort() + "/index.html").         String text = "Apache Flink Dashboard".         assertTrue("Startpage should contain " + text, fromHTTP.contains(text)).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;private;0;3;;private int getRestPort() {     return CLUSTER.getRestAddres().getPort(). }
false;public;0;31;;@Test public void testResponseHeaders() throws Exception {     // check headers for successful json response     URL taskManagersUrl = new URL("http://localhost:" + getRestPort() + "/taskmanagers").     HttpURLConnection taskManagerConnection = (HttpURLConnection) taskManagersUrl.openConnection().     taskManagerConnection.setConnectTimeout(100000).     taskManagerConnection.connect().     if (taskManagerConnection.getResponseCode() >= 400) {         // error!         InputStream is = taskManagerConnection.getErrorStream().         String errorMessage = IOUtils.toString(is, ConfigConstants.DEFAULT_CHARSET).         throw new RuntimeException(errorMessage).     }     // we don't set the content-encoding header     Assert.assertNull(taskManagerConnection.getContentEncoding()).     Assert.assertEquals("application/json. charset=UTF-8", taskManagerConnection.getContentType()).     // check headers in case of an error     URL notFoundJobUrl = new URL("http://localhost:" + getRestPort() + "/jobs/dontexist").     HttpURLConnection notFoundJobConnection = (HttpURLConnection) notFoundJobUrl.openConnection().     notFoundJobConnection.setConnectTimeout(100000).     notFoundJobConnection.connect().     if (notFoundJobConnection.getResponseCode() >= 400) {         // we don't set the content-encoding header         Assert.assertNull(notFoundJobConnection.getContentEncoding()).         Assert.assertEquals("application/json. charset=UTF-8", notFoundJobConnection.getContentType()).     } else {         throw new RuntimeException("Request for non-existing job did not return an error.").     } }
false;public;0;16;;@Test public void getNumberOfTaskManagers() {     try {         String json = TestBaseUtils.getFromHTTP("http://localhost:" + getRestPort() + "/taskmanagers/").         ObjectMapper mapper = new ObjectMapper().         JsonNode response = mapper.readTree(json).         ArrayNode taskManagers = (ArrayNode) response.get("taskmanagers").         assertNotNull(taskManagers).         assertEquals(NUM_TASK_MANAGERS, taskManagers.size()).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;16;;@Test public void getTaskmanagers() throws Exception {     String json = TestBaseUtils.getFromHTTP("http://localhost:" + getRestPort() + "/taskmanagers/").     ObjectMapper mapper = new ObjectMapper().     JsonNode parsed = mapper.readTree(json).     ArrayNode taskManagers = (ArrayNode) parsed.get("taskmanagers").     assertNotNull(taskManagers).     assertEquals(NUM_TASK_MANAGERS, taskManagers.size()).     JsonNode taskManager = taskManagers.get(0).     assertNotNull(taskManager).     assertEquals(NUM_SLOTS, taskManager.get("slotsNumber").asInt()).     assertTrue(taskManager.get("freeSlots").asInt() <= NUM_SLOTS). }
false;public;0;12;;@Test public void getLogAndStdoutFiles() throws Exception {     WebMonitorUtils.LogFileLocation logFiles = WebMonitorUtils.LogFileLocation.find(CLUSTER_CONFIGURATION).     FileUtils.writeStringToFile(logFiles.logFile, "job manager log").     String logs = TestBaseUtils.getFromHTTP("http://localhost:" + getRestPort() + "/jobmanager/log").     assertTrue(logs.contains("job manager log")).     FileUtils.writeStringToFile(logFiles.stdOutFile, "job manager out").     logs = TestBaseUtils.getFromHTTP("http://localhost:" + getRestPort() + "/jobmanager/stdout").     assertTrue(logs.contains("job manager out")). }
false;public;0;26;;@Test public void getTaskManagerLogAndStdoutFiles() {     try {         String json = TestBaseUtils.getFromHTTP("http://localhost:" + getRestPort() + "/taskmanagers/").         ObjectMapper mapper = new ObjectMapper().         JsonNode parsed = mapper.readTree(json).         ArrayNode taskManagers = (ArrayNode) parsed.get("taskmanagers").         JsonNode taskManager = taskManagers.get(0).         String id = taskManager.get("id").asText().         WebMonitorUtils.LogFileLocation logFiles = WebMonitorUtils.LogFileLocation.find(CLUSTER_CONFIGURATION).         // we check for job manager log files, since no separate taskmanager logs exist         FileUtils.writeStringToFile(logFiles.logFile, "job manager log").         String logs = TestBaseUtils.getFromHTTP("http://localhost:" + getRestPort() + "/taskmanagers/" + id + "/log").         assertTrue(logs.contains("job manager log")).         FileUtils.writeStringToFile(logFiles.stdOutFile, "job manager out").         logs = TestBaseUtils.getFromHTTP("http://localhost:" + getRestPort() + "/taskmanagers/" + id + "/stdout").         assertTrue(logs.contains("job manager out")).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;14;;@Test public void getConfiguration() {     try {         String config = TestBaseUtils.getFromHTTP("http://localhost:" + getRestPort() + "/jobmanager/config").         Map<String, String> conf = WebMonitorUtils.fromKeyValueJsonArray(config).         assertEquals(CLUSTER_CONFIGURATION.getString(ConfigConstants.LOCAL_START_WEBSERVER, null), conf.get(ConfigConstants.LOCAL_START_WEBSERVER)).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;58;;@Test public void testStop() throws Exception {     // this only works if there is no active job at this point     assertTrue(getRunningJobs(CLUSTER.getClusterClient()).isEmpty()).     // Create a task     final JobVertex sender = new JobVertex("Sender").     sender.setParallelism(2).     sender.setInvokableClass(BlockingInvokable.class).     final JobGraph jobGraph = new JobGraph("Stoppable streaming test job", sender).     final JobID jid = jobGraph.getJobID().     ClusterClient<?> clusterClient = CLUSTER.getClusterClient().     clusterClient.setDetached(true).     clusterClient.submitJob(jobGraph, WebFrontendITCase.class.getClassLoader()).     // wait for job to show up     while (getRunningJobs(CLUSTER.getClusterClient()).isEmpty()) {         Thread.sleep(10).     }     // wait for tasks to be properly running     BlockingInvokable.latch.await().     final FiniteDuration testTimeout = new FiniteDuration(2, TimeUnit.MINUTES).     final Deadline deadline = testTimeout.fromNow().     try (HttpTestClient client = new HttpTestClient("localhost", getRestPort())) {         // stop the job         client.sendPatchRequest("/jobs/" + jid + "/?mode=stop", deadline.timeLeft()).         HttpTestClient.SimpleHttpResponse response = client.getNextResponse(deadline.timeLeft()).         assertEquals(HttpResponseStatus.ACCEPTED, response.getStatus()).         assertEquals("application/json. charset=UTF-8", response.getType()).         assertEquals("{}", response.getContent()).     }     // wait for cancellation to finish     while (!getRunningJobs(CLUSTER.getClusterClient()).isEmpty()) {         Thread.sleep(20).     }     // ensure we can access job details when its finished (FLINK-4011)     try (HttpTestClient client = new HttpTestClient("localhost", getRestPort())) {         FiniteDuration timeout = new FiniteDuration(30, TimeUnit.SECONDS).         client.sendGetRequest("/jobs/" + jid + "/config", timeout).         HttpTestClient.SimpleHttpResponse response = client.getNextResponse(timeout).         assertEquals(HttpResponseStatus.OK, response.getStatus()).         assertEquals("application/json. charset=UTF-8", response.getType()).         assertEquals("{\"jid\":\"" + jid + "\",\"name\":\"Stoppable streaming test job\"," + "\"execution-config\":{\"execution-mode\":\"PIPELINED\",\"restart-strategy\":\"Cluster level default restart strategy\"," + "\"job-parallelism\":-1,\"object-reuse-mode\":false,\"user-config\":{}}}", response.getContent()).     }     BlockingInvokable.reset(). }
false;public;0;47;;@Test public void testStopYarn() throws Exception {     // this only works if there is no active job at this point     assertTrue(getRunningJobs(CLUSTER.getClusterClient()).isEmpty()).     // Create a task     final JobVertex sender = new JobVertex("Sender").     sender.setParallelism(2).     sender.setInvokableClass(BlockingInvokable.class).     final JobGraph jobGraph = new JobGraph("Stoppable streaming test job", sender).     final JobID jid = jobGraph.getJobID().     ClusterClient<?> clusterClient = CLUSTER.getClusterClient().     clusterClient.setDetached(true).     clusterClient.submitJob(jobGraph, WebFrontendITCase.class.getClassLoader()).     // wait for job to show up     while (getRunningJobs(CLUSTER.getClusterClient()).isEmpty()) {         Thread.sleep(10).     }     // wait for tasks to be properly running     BlockingInvokable.latch.await().     final FiniteDuration testTimeout = new FiniteDuration(2, TimeUnit.MINUTES).     final Deadline deadline = testTimeout.fromNow().     try (HttpTestClient client = new HttpTestClient("localhost", getRestPort())) {         // Request the file from the web server         client.sendGetRequest("/jobs/" + jid + "/yarn-stop", deadline.timeLeft()).         HttpTestClient.SimpleHttpResponse response = client.getNextResponse(deadline.timeLeft()).         assertEquals(HttpResponseStatus.ACCEPTED, response.getStatus()).         assertEquals("application/json. charset=UTF-8", response.getType()).         assertEquals("{}", response.getContent()).     }     // wait for cancellation to finish     while (!getRunningJobs(CLUSTER.getClusterClient()).isEmpty()) {         Thread.sleep(20).     }     BlockingInvokable.reset(). }
false;private,static;1;7;;private static List<JobID> getRunningJobs(ClusterClient<?> client) throws Exception {     Collection<JobStatusMessage> statusMessages = client.listJobs().get().     return statusMessages.stream().filter(status -> !status.getJobState().isGloballyTerminalState()).map(JobStatusMessage::getJobId).collect(Collectors.toList()). }
false;public;0;7;;@Override public void invoke() throws Exception {     latch.countDown().     while (isRunning) {         Thread.sleep(100).     } }
false;public;0;4;;@Override public void stop() {     this.isRunning = false. }
false;public,static;0;3;;public static void reset() {     latch = new CountDownLatch(2). }
