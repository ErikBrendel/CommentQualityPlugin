commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;7;;@Override protected void initChannel(SocketChannel ch) throws Exception {     ChannelPipeline p = ch.pipeline().     p.addLast(new HttpClientCodec()).     p.addLast(new HttpContentDecompressor()).     p.addLast(new ClientHandler(responses)). }
true;public;2;16;/**  * Sends a request to to the server.  *  * <pre>  * HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/overview").  * request.headers().set(HttpHeaders.Names.HOST, host).  * request.headers().set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE).  *  * sendRequest(request).  * </pre>  *  * @param request The {@link HttpRequest} to send to the server  */ ;/**  * Sends a request to to the server.  *  * <pre>  * HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/overview").  * request.headers().set(HttpHeaders.Names.HOST, host).  * request.headers().set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE).  *  * sendRequest(request).  * </pre>  *  * @param request The {@link HttpRequest} to send to the server  */ public void sendRequest(HttpRequest request, FiniteDuration timeout) throws InterruptedException, TimeoutException {     LOG.debug("Writing {}.", request).     // Make the connection attempt.     ChannelFuture connect = bootstrap.connect(host, port).     Channel channel.     if (connect.await(timeout.toMillis(), TimeUnit.MILLISECONDS)) {         channel = connect.channel().     } else {         throw new TimeoutException("Connection failed").     }     channel.writeAndFlush(request). }
true;public;2;12;/**  * Sends a simple GET request to the given path. You only specify the $path part of  * http://$host:$host/$path.  *  * @param path The $path to GET (http://$host:$host/$path)  */ ;/**  * Sends a simple GET request to the given path. You only specify the $path part of  * http://$host:$host/$path.  *  * @param path The $path to GET (http://$host:$host/$path)  */ public void sendGetRequest(String path, FiniteDuration timeout) throws TimeoutException, InterruptedException {     if (!path.startsWith("/")) {         path = "/" + path.     }     HttpRequest getRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path).     getRequest.headers().set(HttpHeaders.Names.HOST, host).     getRequest.headers().set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE).     sendRequest(getRequest, timeout). }
true;public;2;12;/**  * Sends a simple DELETE request to the given path. You only specify the $path part of  * http://$host:$host/$path.  *  * @param path The $path to DELETE (http://$host:$host/$path)  */ ;/**  * Sends a simple DELETE request to the given path. You only specify the $path part of  * http://$host:$host/$path.  *  * @param path The $path to DELETE (http://$host:$host/$path)  */ public void sendDeleteRequest(String path, FiniteDuration timeout) throws TimeoutException, InterruptedException {     if (!path.startsWith("/")) {         path = "/" + path.     }     HttpRequest getRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.DELETE, path).     getRequest.headers().set(HttpHeaders.Names.HOST, host).     getRequest.headers().set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE).     sendRequest(getRequest, timeout). }
true;public;2;12;/**  * Sends a simple PATCH request to the given path. You only specify the $path part of  * http://$host:$host/$path.  *  * @param path The $path to PATCH (http://$host:$host/$path)  */ ;/**  * Sends a simple PATCH request to the given path. You only specify the $path part of  * http://$host:$host/$path.  *  * @param path The $path to PATCH (http://$host:$host/$path)  */ public void sendPatchRequest(String path, FiniteDuration timeout) throws TimeoutException, InterruptedException {     if (!path.startsWith("/")) {         path = "/" + path.     }     HttpRequest getRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PATCH, path).     getRequest.headers().set(HttpHeaders.Names.HOST, host).     getRequest.headers().set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE).     sendRequest(getRequest, timeout). }
true;public;0;3;/**  * Returns the next available HTTP response. A call to this method blocks until a response  * becomes available.  *  * @return The next available {@link SimpleHttpResponse}  */ ;/**  * Returns the next available HTTP response. A call to this method blocks until a response  * becomes available.  *  * @return The next available {@link SimpleHttpResponse}  */ public SimpleHttpResponse getNextResponse() throws InterruptedException {     return responses.take(). }
true;public;1;12;/**  * Returns the next available HTTP response . A call to this method blocks until a response  * becomes available or throws an Exception if the timeout fires.  *  * @param timeout Timeout in milliseconds for the next response to become available  * @return The next available {@link SimpleHttpResponse}  */ ;/**  * Returns the next available HTTP response . A call to this method blocks until a response  * becomes available or throws an Exception if the timeout fires.  *  * @param timeout Timeout in milliseconds for the next response to become available  * @return The next available {@link SimpleHttpResponse}  */ public SimpleHttpResponse getNextResponse(FiniteDuration timeout) throws InterruptedException, TimeoutException {     SimpleHttpResponse response = responses.poll(timeout.toMillis(), TimeUnit.MILLISECONDS).     if (response == null) {         throw new TimeoutException("No response within timeout of " + timeout + " ms").     } else {         return response.     } }
true;public;0;8;/**  * Closes the client.  */ ;/**  * Closes the client.  */ @Override public void close() throws InterruptedException {     if (group != null) {         group.shutdownGracefully().     }     LOG.debug("Closed"). }
false;public;0;3;;public HttpResponseStatus getStatus() {     return status. }
false;public;0;3;;public String getType() {     return type. }
false;public,final;0;3;;public final String getLocation() {     return location. }
false;public;0;3;;public String getContent() {     return content. }
false;public;0;5;;@Override public String toString() {     return "HttpResponse(status=" + status + ", type='" + type + "'" + ", content='" + content + ", location = " + location + "')". }
false;protected;2;36;;@Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {     LOG.debug("Received {}", msg).     if (msg instanceof HttpResponse) {         HttpResponse response = (HttpResponse) msg.         currentStatus = response.getStatus().         currentType = response.headers().get(HttpHeaders.Names.CONTENT_TYPE).         currentLocation = response.headers().get(HttpHeaders.Names.LOCATION).         if (HttpHeaders.isTransferEncodingChunked(response)) {             LOG.debug("Content is chunked").         }     }     if (msg instanceof HttpContent) {         HttpContent content = (HttpContent) msg.         // Add the content         currentContent += content.content().toString(CharsetUtil.UTF_8).         // Finished with this         if (content instanceof LastHttpContent) {             responses.add(new SimpleHttpResponse(currentStatus, currentType, currentContent, currentLocation)).             currentStatus = null.             currentType = null.             currentLocation = null.             currentContent = "".             ctx.close().         }     } }
