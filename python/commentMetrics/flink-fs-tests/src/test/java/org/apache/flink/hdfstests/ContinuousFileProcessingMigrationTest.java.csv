# id;timestamp;commentText;codeText;commentWords;codeWords
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1496852938;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1498894422;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1503598628;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1517943539;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1517943539;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1519567828;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1534233755;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1534779482;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1545142841;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1547026204;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1547725934;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeMonitoringSourceSnapshot() throws Exception;1547725946;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeMonitoringSourceSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		long fileModTime = Long.MIN_VALUE__		for (int i = 0_ i < 1_ i++) {_			Tuple2<File, String> file = createFileAndFillWithData(testFolder, "file", i, "This is test line.")__			fileModTime = file.f0.lastModified()__		}__		TextInputFormat format = new TextInputFormat(new Path(testFolder.getAbsolutePath()))___		final ContinuousFileMonitoringFunction<String> monitoringFunction =_			new ContinuousFileMonitoringFunction<>(format, FileProcessingMode.PROCESS_CONTINUOUSLY, 1, INTERVAL)___		StreamSource<TimestampedFileInputSplit, ContinuousFileMonitoringFunction<String>> src =_			new StreamSource<>(monitoringFunction)___		final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness =_				new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0)___		testHarness.open()___		final Throwable[] error = new Throwable[1]___		final OneShotLatch latch = new OneShotLatch()___		_		Thread runner = new Thread() {_			@Override_			public void run() {_				try {_					monitoringFunction.run(new DummySourceContext() {_						@Override_						public void collect(TimestampedFileInputSplit element) {_							latch.trigger()__						}__						@Override_						public void markAsTemporarilyIdle() {__						}_					})__				}_				catch (Throwable t) {_					t.printStackTrace()__					error[0] = t__				}_			}_		}__		runner.start()___		if (!latch.isTriggered()) {_			latch.await()__		}__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(_				snapshot,_				"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink" + flinkGenerateSavepointVersion + "-snapshot")___		monitoringFunction.cancel()__		runner.join()___		testHarness.close()__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,monitoring,source,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,long,file,mod,time,long,for,int,i,0,i,1,i,tuple2,file,string,file,create,file,and,fill,with,data,test,folder,file,i,this,is,test,line,file,mod,time,file,f0,last,modified,text,input,format,format,new,text,input,format,new,path,test,folder,get,absolute,path,final,continuous,file,monitoring,function,string,monitoring,function,new,continuous,file,monitoring,function,format,file,processing,mode,1,interval,stream,source,timestamped,file,input,split,continuous,file,monitoring,function,string,src,new,stream,source,monitoring,function,final,abstract,stream,operator,test,harness,timestamped,file,input,split,test,harness,new,abstract,stream,operator,test,harness,src,1,1,0,test,harness,open,final,throwable,error,new,throwable,1,final,one,shot,latch,latch,new,one,shot,latch,thread,runner,new,thread,override,public,void,run,try,monitoring,function,run,new,dummy,source,context,override,public,void,collect,timestamped,file,input,split,element,latch,trigger,override,public,void,mark,as,temporarily,idle,catch,throwable,t,t,print,stack,trace,error,0,t,runner,start,if,latch,is,triggered,latch,await,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,monitoring,function,migration,test,file,mod,time,flink,flink,generate,savepoint,version,snapshot,monitoring,function,cancel,runner,join,test,harness,close
ContinuousFileProcessingMigrationTest -> private Tuple2<org.apache.hadoop.fs.Path, String> createFileAndFillWithData( 		String base, String fileName, int fileIdx, String sampleLine) throws IOException;1482246154;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<org.apache.hadoop.fs.Path, String> createFileAndFillWithData(_		String base, String fileName, int fileIdx, String sampleLine) throws IOException {__		assert (hdfs != null)___		org.apache.hadoop.fs.Path file = new org.apache.hadoop.fs.Path(base + "/" + fileName + fileIdx)__		Assert.assertFalse(hdfs.exists(file))___		org.apache.hadoop.fs.Path tmp = new org.apache.hadoop.fs.Path(base + "/." + fileName + fileIdx)__		FSDataOutputStream stream = hdfs.create(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx +": "+ sampleLine + " " + i +"\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		hdfs.rename(tmp, file)___		Assert.assertTrue("No result file present", hdfs.exists(file))__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,org,apache,hadoop,fs,path,string,create,file,and,fill,with,data,string,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,assert,hdfs,null,org,apache,hadoop,fs,path,file,new,org,apache,hadoop,fs,path,base,file,name,file,idx,assert,assert,false,hdfs,exists,file,org,apache,hadoop,fs,path,tmp,new,org,apache,hadoop,fs,path,base,file,name,file,idx,fsdata,output,stream,stream,hdfs,create,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,hdfs,rename,tmp,file,assert,assert,true,no,result,file,present,hdfs,exists,file,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<org.apache.hadoop.fs.Path, String> createFileAndFillWithData( 		String base, String fileName, int fileIdx, String sampleLine) throws IOException;1485250954;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<org.apache.hadoop.fs.Path, String> createFileAndFillWithData(_		String base, String fileName, int fileIdx, String sampleLine) throws IOException {__		assert (hdfs != null)___		org.apache.hadoop.fs.Path file = new org.apache.hadoop.fs.Path(base + "/" + fileName + fileIdx)__		Assert.assertFalse(hdfs.exists(file))___		org.apache.hadoop.fs.Path tmp = new org.apache.hadoop.fs.Path(base + "/." + fileName + fileIdx)__		FSDataOutputStream stream = hdfs.create(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx +": "+ sampleLine + " " + i +"\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		hdfs.rename(tmp, file)___		Assert.assertTrue("No result file present", hdfs.exists(file))__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,org,apache,hadoop,fs,path,string,create,file,and,fill,with,data,string,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,assert,hdfs,null,org,apache,hadoop,fs,path,file,new,org,apache,hadoop,fs,path,base,file,name,file,idx,assert,assert,false,hdfs,exists,file,org,apache,hadoop,fs,path,tmp,new,org,apache,hadoop,fs,path,base,file,name,file,idx,fsdata,output,stream,stream,hdfs,create,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,hdfs,rename,tmp,file,assert,assert,true,no,result,file,present,hdfs,exists,file,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<org.apache.hadoop.fs.Path, String> createFileAndFillWithData( 		String base, String fileName, int fileIdx, String sampleLine) throws IOException;1489060855;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<org.apache.hadoop.fs.Path, String> createFileAndFillWithData(_		String base, String fileName, int fileIdx, String sampleLine) throws IOException {__		assert (hdfs != null)___		org.apache.hadoop.fs.Path file = new org.apache.hadoop.fs.Path(base + "/" + fileName + fileIdx)__		Assert.assertFalse(hdfs.exists(file))___		org.apache.hadoop.fs.Path tmp = new org.apache.hadoop.fs.Path(base + "/." + fileName + fileIdx)__		FSDataOutputStream stream = hdfs.create(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx +": "+ sampleLine + " " + i +"\n"__			str.append(line)__			stream.write(line.getBytes(ConfigConstants.DEFAULT_CHARSET))__		}_		stream.close()___		hdfs.rename(tmp, file)___		Assert.assertTrue("No result file present", hdfs.exists(file))__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,org,apache,hadoop,fs,path,string,create,file,and,fill,with,data,string,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,assert,hdfs,null,org,apache,hadoop,fs,path,file,new,org,apache,hadoop,fs,path,base,file,name,file,idx,assert,assert,false,hdfs,exists,file,org,apache,hadoop,fs,path,tmp,new,org,apache,hadoop,fs,path,base,file,name,file,idx,fsdata,output,stream,stream,hdfs,create,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,config,constants,stream,close,hdfs,rename,tmp,file,assert,assert,true,no,result,file,present,hdfs,exists,file,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1496852938;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1498894422;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1503598628;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1517943539;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1517943539;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1519567828;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1534233755;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1534779482;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1545142841;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1547026204;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1547725934;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> private Tuple2<File, String> createFileAndFillWithData( 		File base, String fileName, int fileIdx, String sampleLine) throws IOException;1547725946;Create a file with pre-determined String format of the form:_{@code fileIdx +": "+ sampleLine +" "+ lineNo}.;private Tuple2<File, String> createFileAndFillWithData(_		File base, String fileName, int fileIdx, String sampleLine) throws IOException {__		File file = new File(base, fileName + fileIdx)__		Assert.assertFalse(file.exists())___		File tmp = new File(base, "." + fileName + fileIdx)__		FileOutputStream stream = new FileOutputStream(tmp)__		StringBuilder str = new StringBuilder()__		for (int i = 0_ i < LINES_PER_FILE_ i++) {_			String line = fileIdx + ": " + sampleLine + " " + i + "\n"__			str.append(line)__			stream.write(line.getBytes())__		}_		stream.close()___		FileUtils.moveFile(tmp, file)___		Assert.assertTrue("No result file present", file.exists())__		return new Tuple2<>(file, str.toString())__	};create,a,file,with,pre,determined,string,format,of,the,form,code,file,idx,sample,line,line,no;private,tuple2,file,string,create,file,and,fill,with,data,file,base,string,file,name,int,file,idx,string,sample,line,throws,ioexception,file,file,new,file,base,file,name,file,idx,assert,assert,false,file,exists,file,tmp,new,file,base,file,name,file,idx,file,output,stream,stream,new,file,output,stream,tmp,string,builder,str,new,string,builder,for,int,i,0,i,i,string,line,file,idx,sample,line,i,n,str,append,line,stream,write,line,get,bytes,stream,close,file,utils,move,file,tmp,file,assert,assert,true,no,result,file,present,file,exists,return,new,tuple2,file,str,to,string
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1496852938;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1498894422;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1503598628;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1517943539;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1517943539;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorStateHandles snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,state,handles,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1519567828;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1534233755;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1534779482;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1545142841;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1547026204;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1547725934;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
ContinuousFileProcessingMigrationTest -> @Ignore 	@Test 	public void writeReaderSnapshot() throws Exception;1547725946;Manually run this to write binary snapshot data. Remove @Ignore to run.;@Ignore_	@Test_	public void writeReaderSnapshot() throws Exception {__		File testFolder = tempFolder.newFolder()___		TimestampedFileInputSplit split1 =_				new TimestampedFileInputSplit(0, 3, new Path("test/test1"), 0, 100, null)___		TimestampedFileInputSplit split2 =_				new TimestampedFileInputSplit(10, 2, new Path("test/test2"), 101, 200, null)___		TimestampedFileInputSplit split3 =_				new TimestampedFileInputSplit(10, 1, new Path("test/test2"), 0, 100, null)___		TimestampedFileInputSplit split4 =_				new TimestampedFileInputSplit(11, 0, new Path("test/test3"), 0, 100, null)___		_		_		final OneShotLatch blockingLatch = new OneShotLatch()__		BlockingFileInputFormat format = new BlockingFileInputFormat(blockingLatch, new Path(testFolder.getAbsolutePath()))___		TypeInformation<FileInputSplit> typeInfo = TypeExtractor.getInputFormatTypes(format)__		ContinuousFileReaderOperator<FileInputSplit> initReader = new ContinuousFileReaderOperator<>(_				format)__		initReader.setOutputType(typeInfo, new ExecutionConfig())__		OneInputStreamOperatorTestHarness<TimestampedFileInputSplit, FileInputSplit> testHarness =_				new OneInputStreamOperatorTestHarness<>(initReader)__		testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime)__		testHarness.open()__		_		testHarness.processElement(new StreamRecord<>(split1))__		testHarness.processElement(new StreamRecord<>(split2))__		testHarness.processElement(new StreamRecord<>(split3))__		testHarness.processElement(new StreamRecord<>(split4))__		_		_		__		final OperatorSubtaskState snapshot__		synchronized (testHarness.getCheckpointLock()) {_			snapshot = testHarness.snapshot(0L, 0L)__		}__		OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/reader-migration-test-flink" + flinkGenerateSavepointVersion + "-snapshot")__	};manually,run,this,to,write,binary,snapshot,data,remove,ignore,to,run;ignore,test,public,void,write,reader,snapshot,throws,exception,file,test,folder,temp,folder,new,folder,timestamped,file,input,split,split1,new,timestamped,file,input,split,0,3,new,path,test,test1,0,100,null,timestamped,file,input,split,split2,new,timestamped,file,input,split,10,2,new,path,test,test2,101,200,null,timestamped,file,input,split,split3,new,timestamped,file,input,split,10,1,new,path,test,test2,0,100,null,timestamped,file,input,split,split4,new,timestamped,file,input,split,11,0,new,path,test,test3,0,100,null,final,one,shot,latch,blocking,latch,new,one,shot,latch,blocking,file,input,format,format,new,blocking,file,input,format,blocking,latch,new,path,test,folder,get,absolute,path,type,information,file,input,split,type,info,type,extractor,get,input,format,types,format,continuous,file,reader,operator,file,input,split,init,reader,new,continuous,file,reader,operator,format,init,reader,set,output,type,type,info,new,execution,config,one,input,stream,operator,test,harness,timestamped,file,input,split,file,input,split,test,harness,new,one,input,stream,operator,test,harness,init,reader,test,harness,set,time,characteristic,time,characteristic,event,time,test,harness,open,test,harness,process,element,new,stream,record,split1,test,harness,process,element,new,stream,record,split2,test,harness,process,element,new,stream,record,split3,test,harness,process,element,new,stream,record,split4,final,operator,subtask,state,snapshot,synchronized,test,harness,get,checkpoint,lock,snapshot,test,harness,snapshot,0l,0l,operator,snapshot,util,write,state,handle,snapshot,src,test,resources,reader,migration,test,flink,flink,generate,savepoint,version,snapshot
