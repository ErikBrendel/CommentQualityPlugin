# id;timestamp;commentText;codeText;commentWords;codeWords
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1405024514;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1405090423;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1408359504;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1411473593;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1415031057;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1415302606;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1415617196;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1416482279;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1417108705;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1420731347;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1420731347;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1420731728;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1422034750;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1422959656;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1423847366;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1424860683;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1427824467;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1431371277;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1445264257;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1446112342;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1450111459;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1450713543;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1451152602;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1452178883;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1455632624;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1467707997;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1479853012;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1481633610;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1481715812;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1481715812;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1485255695;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1485698310;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1487082763;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1487548884;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1487548884;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1507223685;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1507223685;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1507281370;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1507304713;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1507752419;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1508481109;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1510933709;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1511520068;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1511520068;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1512410190;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1515600855;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1531689536;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract boolean rename(Path src, Path dst) throws IOException_;1531689536;Renames the file/directory src to dst.__@param src_the file/directory to rename_@param dst_the new name of the file/directory_@return <code>true</code> if the renaming was successful, <code>false</code> otherwise_@throws IOException;public abstract boolean rename(Path src, Path dst) throws IOException_;renames,the,file,directory,src,to,dst,param,src,the,file,directory,to,rename,param,dst,the,new,name,of,the,file,directory,return,code,true,code,if,the,renaming,was,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,rename,path,src,path,dst,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1405024514;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1405090423;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1408359504;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1411473593;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1415031057;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1415302606;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1415617196;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1416482279;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1417108705;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1420731347;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1420731347;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1420731728;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1422034750;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1422959656;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1423847366;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1424860683;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1427824467;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1431371277;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1445264257;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1446112342;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1450111459;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1450713543;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1451152602;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1452178883;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1455632624;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1467707997;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1479853012;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1481633610;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1481715812;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1481715812;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1485255695;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1485698310;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1487082763;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1487548884;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1487548884;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1507223685;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1507223685;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1507281370;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1507304713;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1507752419;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1508481109;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1510933709;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1511520068;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1511520068;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1512410190;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1515600855;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1531689536;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f) throws IOException_;1531689536;Opens an FSDataInputStream at the indicated Path.__@param f_the file to open;public abstract FSDataInputStream open(Path f) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,to,open;public,abstract,fsdata,input,stream,open,path,f,throws,ioexception
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1405024514;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(this.isDistributedFS()) {_			return false__		}_		_		FileStatus status = null__		try {_			status = getFileStatus(outPath)__		}_		catch (FileNotFoundException e) {_			_		}_		_		_		if (status != null) {_			_			switch (writeMode) {_			case NO_OVERWRITE:_				if (status.isDir() && createDirectory) {_					return true__				} else {_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__				}__			case OVERWRITE:_				if (status.isDir()) {_					if (createDirectory) {_						_						return true__					} else {_						_						try {_							this.delete(outPath, true)__						} catch(IOException ioe) {_							_							_							_						}_					}_				} else {_					_					try {_						this.delete(outPath, false)__					} catch(IOException ioe) {_						_						_						_					}_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_	_			_			try {_				FileStatus check = getFileStatus(outPath)__				return check.isDir()__			} catch (FileNotFoundException e) {_				return false__			}_		} else {_			_			return !this.exists(outPath)__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,ioe,else,try,this,delete,out,path,false,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,try,file,status,check,get,file,status,out,path,return,check,is,dir,catch,file,not,found,exception,e,return,false,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1405090423;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(this.isDistributedFS()) {_			return false__		}_		_		FileStatus status = null__		try {_			status = getFileStatus(outPath)__		}_		catch (FileNotFoundException e) {_			_		}_		_		_		if (status != null) {_			_			switch (writeMode) {_			case NO_OVERWRITE:_				if (status.isDir() && createDirectory) {_					return true__				} else {_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__				}__			case OVERWRITE:_				if (status.isDir()) {_					if (createDirectory) {_						_						return true__					} else {_						_						try {_							this.delete(outPath, true)__						} catch(IOException ioe) {_							_							_							_						}_					}_				} else {_					_					try {_						this.delete(outPath, false)__					} catch(IOException ioe) {_						_						_						_					}_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_	_			_			try {_				FileStatus check = getFileStatus(outPath)__				return check.isDir()__			} catch (FileNotFoundException e) {_				return false__			}_		} else {_			_			return !this.exists(outPath)__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,ioe,else,try,this,delete,out,path,false,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,try,file,status,check,get,file,status,out,path,return,check,is,dir,catch,file,not,found,exception,e,return,false,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1408359504;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(this.isDistributedFS()) {_			return false__		}_		_		FileStatus status = null__		try {_			status = getFileStatus(outPath)__		}_		catch (FileNotFoundException e) {_			_		}_		_		_		if (status != null) {_			_			switch (writeMode) {_			case NO_OVERWRITE:_				if (status.isDir() && createDirectory) {_					return true__				} else {_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__				}__			case OVERWRITE:_				if (status.isDir()) {_					if (createDirectory) {_						_						return true__					} else {_						_						try {_							this.delete(outPath, true)__						} catch(IOException ioe) {_							_							_							_						}_					}_				} else {_					_					try {_						this.delete(outPath, false)__					} catch(IOException ioe) {_						_						_						_					}_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_	_			_			try {_				FileStatus check = getFileStatus(outPath)__				return check.isDir()__			} catch (FileNotFoundException e) {_				return false__			}_		} else {_			_			return !this.exists(outPath)__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,ioe,else,try,this,delete,out,path,false,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,try,file,status,check,get,file,status,out,path,return,check,is,dir,catch,file,not,found,exception,e,return,false,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1411473593;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(this.isDistributedFS()) {_			return false__		}_		_		FileStatus status = null__		try {_			status = getFileStatus(outPath)__		}_		catch (FileNotFoundException e) {_			_		}_		_		_		if (status != null) {_			_			switch (writeMode) {_			case NO_OVERWRITE:_				if (status.isDir() && createDirectory) {_					return true__				} else {_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__				}__			case OVERWRITE:_				if (status.isDir()) {_					if (createDirectory) {_						_						return true__					} else {_						_						try {_							this.delete(outPath, true)__						} catch(IOException ioe) {_							_							_							_						}_					}_				} else {_					_					try {_						this.delete(outPath, false)__					} catch(IOException ioe) {_						_						_						_					}_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_	_			_			try {_				FileStatus check = getFileStatus(outPath)__				return check.isDir()__			} catch (FileNotFoundException e) {_				return false__			}_		} else {_			_			return !this.exists(outPath)__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,ioe,else,try,this,delete,out,path,false,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,try,file,status,check,get,file,status,out,path,return,check,is,dir,catch,file,not,found,exception,e,return,false,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1415031057;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(this.isDistributedFS()) {_			return false__		}_		_		FileStatus status = null__		try {_			status = getFileStatus(outPath)__		}_		catch (FileNotFoundException e) {_			_		}_		_		_		if (status != null) {_			_			switch (writeMode) {_			case NO_OVERWRITE:_				if (status.isDir() && createDirectory) {_					return true__				} else {_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__				}__			case OVERWRITE:_				if (status.isDir()) {_					if (createDirectory) {_						_						return true__					} else {_						_						try {_							this.delete(outPath, true)__						} catch(IOException ioe) {_							_							_							_						}_					}_				} else {_					_					try {_						this.delete(outPath, false)__					} catch(IOException ioe) {_						_						_						_					}_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_	_			_			try {_				FileStatus check = getFileStatus(outPath)__				return check.isDir()__			} catch (FileNotFoundException e) {_				return false__			}_		} else {_			_			return !this.exists(outPath)__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,ioe,else,try,this,delete,out,path,false,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,try,file,status,check,get,file,status,out,path,return,check,is,dir,catch,file,not,found,exception,e,return,false,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1415302606;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(this.isDistributedFS()) {_			return false__		}_		_		FileStatus status = null__		try {_			status = getFileStatus(outPath)__		}_		catch (FileNotFoundException e) {_			_		}_		_		_		if (status != null) {_			_			switch (writeMode) {_			case NO_OVERWRITE:_				if (status.isDir() && createDirectory) {_					return true__				} else {_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__				}__			case OVERWRITE:_				if (status.isDir()) {_					if (createDirectory) {_						_						return true__					} else {_						_						try {_							this.delete(outPath, true)__						} catch(IOException ioe) {_							_							_							_						}_					}_				} else {_					_					try {_						this.delete(outPath, false)__					} catch(IOException ioe) {_						_						_						_					}_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			_			_			_			_			_			_			_			long now = System.currentTimeMillis()__			long deadline = now + 30000__			_			do {_				try {_					if(!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException ioe) {_					_					_					_				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						} else {_							throw new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_				_				_				try {_					Thread.sleep(1000)__				} catch (InterruptedException ie) {}_			}_			while (System.currentTimeMillis() < deadline)__			_			return false__		}_		else {_			_			return !this.exists(outPath)__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,ioe,else,try,this,delete,out,path,false,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,long,now,system,current,time,millis,long,deadline,now,30000,do,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,throw,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,try,thread,sleep,1000,catch,interrupted,exception,ie,while,system,current,time,millis,deadline,return,false,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1415617196;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1416482279;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1417108705;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1420731347;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1420731347;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1420731728;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1422034750;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1422959656;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1423847366;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1424860683;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1427824467;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1431371277;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1445264257;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1446112342;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1450111459;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1450713543;Initializes output directories on local file systems according to the given write mode.__WriteMode.CREATE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.CREATE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,create,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,create,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1451152602;Initializes output directories on local file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1452178883;Initializes output directories on local file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}_		_		_		_		_		_		_		_		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000__		_		Exception lastError = null__		_		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}_			_			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _								" mode to overwrite existing files and directories.")__					}_	_				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}_			_			if (createDirectory) {_				_				_				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}_		_				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}_					_			}_			else {_				_				return !this.exists(outPath)__			}_			_			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)__		_		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1455632624;Initializes output directories on local file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000___		Exception lastError = null___		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}__			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				__				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}__				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}__			}_			else {_				_				return !this.exists(outPath)__			}__			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)___		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1467707997;Initializes output directories on local file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000___		Exception lastError = null___		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}__			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				__				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}__				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}__			}_			else {_				_				return !this.exists(outPath)__			}__			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)___		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1479853012;Initializes output directories on local file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000___		Exception lastError = null___		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}__			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				__				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}__				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}__			}_			else {_				_				return !this.exists(outPath)__			}__			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)___		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1481633610;Initializes output directories on local file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000___		Exception lastError = null___		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}__			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				__				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}__				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}__			}_			else {_				_				return !this.exists(outPath)__			}__			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)___		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1481715812;Initializes output directories on local file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory is reused, files contained in the directory are NOT deleted._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory (and all its content) is deleted__Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (this.isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		final long now = System.currentTimeMillis()__		final long deadline = now + 30000___		Exception lastError = null___		do {_			FileStatus status = null__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_			}__			_			if (status != null) {_				_				switch (writeMode) {_				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_								WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							_							try {_								this.delete(outPath, true)__							}_							catch (IOException e) {_								_								_								_								lastError = e__							}_						}_					}_					else {_						_						try {_							this.delete(outPath, false)__						}_						catch (IOException e) {_							_							_							_							lastError = e__						}_					}_					break__				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				__				try {_					if (!this.exists(outPath)) {_						this.mkdirs(outPath)__					}_				}_				catch (IOException e) {_					_					lastError = e__				}__				_				try {_					FileStatus check = getFileStatus(outPath)__					if (check != null) {_						if (check.isDir()) {_							return true__						}_						else {_							lastError = new IOException("FileSystem should create an output directory, but the path points to a file instead.")__						}_					}_					_				}_				catch (FileNotFoundException e) {_					_				}__			}_			else {_				_				return !this.exists(outPath)__			}__			_			try {_				Thread.sleep(10)__			}_			catch (InterruptedException e) {_				throw new IOException("Thread was interrupted")__			}_		}_		while (System.currentTimeMillis() < deadline)___		if (lastError != null) {_			throw new IOException("File system failed to prepare output path " + outPath + " with write mode " + writeMode.name(), lastError)__		} else {_			return false__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,and,all,its,content,is,deleted,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,final,long,now,system,current,time,millis,final,long,deadline,now,30000,exception,last,error,null,do,file,status,status,null,try,status,get,file,status,out,path,catch,file,not,found,exception,e,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,this,delete,out,path,true,catch,ioexception,e,last,error,e,else,try,this,delete,out,path,false,catch,ioexception,e,last,error,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,e,last,error,e,try,file,status,check,get,file,status,out,path,if,check,null,if,check,is,dir,return,true,else,last,error,new,ioexception,file,system,should,create,an,output,directory,but,the,path,points,to,a,file,instead,catch,file,not,found,exception,e,else,return,this,exists,out,path,try,thread,sleep,10,catch,interrupted,exception,e,throw,new,ioexception,thread,was,interrupted,while,system,current,time,millis,deadline,if,last,error,null,throw,new,ioexception,file,system,failed,to,prepare,output,path,out,path,with,write,mode,write,mode,name,last,error,else,return,false
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1481715812;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1485255695;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1485698310;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1487082763;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1487548884;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1487548884;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507223685;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507223685;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507281370;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507304713;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507752419;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1508481109;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1510933709;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " + _								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath + _										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1511520068;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " +_								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath +_										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1511520068;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " +_								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath +_										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1512410190;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " +_								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath +_										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1515600855;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory " + outPath + " already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " +_								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath +_										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,out,path,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1531689536;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory " + outPath + " already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " +_								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath +_										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,out,path,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1531689536;Initializes output directories on local file systems according to the given write mode.__<ul>_<li>WriteMode.NO_OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file raises an exception.</li>_</ul>_</li>__<li>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory raises an exception.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ parallel output:_<ul>_<li>A directory is created if the output path does not exist.</li>_<li>An existing directory is reused, files contained in the directory are NOT deleted.</li>_<li>An existing file is deleted and replaced by a new directory.</li>_</ul>_</li>__<li>WriteMode.OVERWRITE &amp_ NONE parallel output:_<ul>_<li>An existing file or directory (and all its content) is deleted</li>_</ul>_</li>_</ul>__<p>Files contained in an existing directory are not deleted, because multiple instances of a_DataSinkTask might call this function at the same time and hence might perform concurrent_delete operations on the file system (possibly deleting output files of concurrently running tasks)._Since concurrent DataSinkTasks are not aware of each other, coordination of delete and create_operations would be difficult.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false to prepare space for a file.__@return True, if the path was successfully prepared, false otherwise._@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			FileStatus status__			try {_				status = getFileStatus(outPath)__			}_			catch (FileNotFoundException e) {_				_				status = null__			}__			_			if (status != null) {_				_				switch (writeMode) {__				case NO_OVERWRITE:_					if (status.isDir() && createDirectory) {_						return true__					} else {_						_						throw new IOException("File or directory " + outPath + " already exists. Existing files and directories " +_								"are not overwritten in " + WriteMode.NO_OVERWRITE.name() + " mode. Use " +_								WriteMode.OVERWRITE.name() + " mode to overwrite existing files and directories.")__					}__				case OVERWRITE:_					if (status.isDir()) {_						if (createDirectory) {_							_							return true__						} else {_							_							try {_								delete(outPath, true)__							}_							catch (IOException e) {_								throw new IOException("Could not remove existing directory '" + outPath +_										"' to allow overwrite by result file", e)__							}_						}_					}_					else {_						_						try {_							delete(outPath, false)__						}_						catch (IOException e) {_							throw new IOException("Could not remove existing file '" + outPath +_									"' to allow overwrite by result file/directory", e)__						}_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				if (!exists(outPath)) {_					mkdirs(outPath)__				}__				_				try {_					return getFileStatus(outPath).isDir()__				}_				catch (FileNotFoundException e) {_					return false__				}_			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,local,file,systems,according,to,the,given,write,mode,ul,li,write,mode,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,raises,an,exception,li,ul,li,li,write,mode,amp,none,parallel,output,ul,li,an,existing,file,or,directory,raises,an,exception,li,ul,li,li,write,mode,overwrite,amp,parallel,output,ul,li,a,directory,is,created,if,the,output,path,does,not,exist,li,li,an,existing,directory,is,reused,files,contained,in,the,directory,are,not,deleted,li,li,an,existing,file,is,deleted,and,replaced,by,a,new,directory,li,ul,li,li,write,mode,overwrite,amp,none,parallel,output,ul,li,an,existing,file,or,directory,and,all,its,content,is,deleted,li,ul,li,ul,p,files,contained,in,an,existing,directory,are,not,deleted,because,multiple,instances,of,a,data,sink,task,might,call,this,function,at,the,same,time,and,hence,might,perform,concurrent,delete,operations,on,the,file,system,possibly,deleting,output,files,of,concurrently,running,tasks,since,concurrent,data,sink,tasks,are,not,aware,of,each,other,coordination,of,delete,and,create,operations,would,be,difficult,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,to,prepare,space,for,a,file,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,local,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,file,status,status,try,status,get,file,status,out,path,catch,file,not,found,exception,e,status,null,if,status,null,switch,write,mode,case,if,status,is,dir,create,directory,return,true,else,throw,new,ioexception,file,or,directory,out,path,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,if,status,is,dir,if,create,directory,return,true,else,try,delete,out,path,true,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,directory,out,path,to,allow,overwrite,by,result,file,e,else,try,delete,out,path,false,catch,ioexception,e,throw,new,ioexception,could,not,remove,existing,file,out,path,to,allow,overwrite,by,result,file,directory,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,if,exists,out,path,mkdirs,out,path,try,return,get,file,status,out,path,is,dir,catch,file,not,found,exception,e,return,false,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean exists(final Path f) throws IOException;1405024514;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1405090423;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1408359504;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1411473593;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1415031057;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1415302606;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1415617196;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1416482279;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1417108705;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1420731347;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1420731347;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1420731728;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1422034750;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1422959656;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1423847366;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1424860683;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1427824467;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1431371277;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1445264257;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1446112342;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1450111459;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1450713543;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1451152602;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1452178883;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1455632624;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1467707997;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1479853012;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1481633610;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1481715812;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1481715812;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1485255695;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1485698310;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1487082763;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {__		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1487548884;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1487548884;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1507223685;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1507223685;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1507281370;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1507304713;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1507752419;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1508481109;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1510933709;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1511520068;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1511520068;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1512410190;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1515600855;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1531689536;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public boolean exists(final Path f) throws IOException;1531689536;Check if exists.__@param f_source file;public boolean exists(final Path f) throws IOException {_		try {_			return (getFileStatus(f) != null)__		} catch (FileNotFoundException e) {_			return false__		}_	};check,if,exists,param,f,source,file;public,boolean,exists,final,path,f,throws,ioexception,try,return,get,file,status,f,null,catch,file,not,found,exception,e,return,false
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1405024514;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1405090423;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1408359504;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1411473593;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1415031057;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1415302606;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1415617196;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1416482279;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1417108705;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1420731347;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1420731347;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1420731728;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1422034750;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1422959656;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1423847366;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1424860683;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public static FileSystem getLocalFileSystem() throws IOException;1427824467;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() throws IOException {__		URI localUri___		try {_			localUri = OperatingSystem.isWindows() ?  new URI("file:/") : new URI("file:///")__		} catch (URISyntaxException e) {_			throw new IOException("Cannot create URI for local file system")__		}__		return get(localUri)__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,throws,ioexception,uri,local,uri,try,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,catch,urisyntax,exception,e,throw,new,ioexception,cannot,create,uri,for,local,file,system,return,get,local,uri
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1405024514;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1405090423;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1408359504;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1411473593;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1415031057;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1415302606;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1415617196;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1416482279;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1417108705;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1420731347;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1420731347;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1420731728;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1422034750;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1422959656;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1423847366;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1424860683;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1427824467;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1431371277;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1445264257;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1446112342;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1450111459;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1450713543;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1451152602;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1452178883;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1455632624;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1467707997;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1479853012;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1481633610;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1481715812;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1481715812;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1485255695;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1485698310;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1487082763;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1487548884;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1487548884;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1507223685;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1507223685;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1507281370;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1507304713;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given patch_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,patch,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1507752419;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given path_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,path,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1508481109;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given path_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,path,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1510933709;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given path_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,path,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1511520068;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given path_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,path,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1511520068;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given path_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,path,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1512410190;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given path_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,path,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1515600855;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given path_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,path,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1531689536;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given path_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,path,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus[] listStatus(Path f) throws IOException_;1531689536;List the statuses of the files/directories in the given path if the path is_a directory.__@param f_given path_@return the statuses of the files/directories in the given path_@throws IOException;public abstract FileStatus[] listStatus(Path f) throws IOException_;list,the,statuses,of,the,files,directories,in,the,given,path,if,the,path,is,a,directory,param,f,given,path,return,the,statuses,of,the,files,directories,in,the,given,path,throws,ioexception;public,abstract,file,status,list,status,path,f,throws,ioexception
FileSystem -> public abstract boolean isDistributedFS()_;1405024514;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1405090423;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1408359504;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1411473593;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1415031057;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1415302606;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1415617196;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1416482279;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1417108705;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1420731347;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1420731347;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1420731728;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1422034750;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1422959656;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1423847366;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1424860683;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1427824467;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1431371277;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1445264257;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1446112342;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1450111459;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1450713543;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1451152602;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1452178883;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1455632624;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1467707997;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1479853012;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1481633610;Returns true if this is a distributed file system, false otherwise.__@return True if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1481715812;Returns true if this is a distributed file system, false otherwise.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1481715812;Returns true if this is a distributed file system, false otherwise.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1485255695;Returns true if this is a distributed file system, false otherwise.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1485698310;Returns true if this is a distributed file system, false otherwise.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1487082763;Returns true if this is a distributed file system, false otherwise.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,false,otherwise,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1487548884;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1487548884;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1507223685;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1507223685;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1507281370;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1507304713;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1507752419;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1508481109;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1510933709;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1511520068;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1511520068;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1512410190;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1515600855;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1531689536;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> public abstract boolean isDistributedFS()_;1531689536;Returns true if this is a distributed file system. A distributed file system here means_that the file system is shared among all Flink processes that participate in a cluster or_job and that all these processes can see the same files.__@return True, if this is a distributed file system, false otherwise.;public abstract boolean isDistributedFS()_;returns,true,if,this,is,a,distributed,file,system,a,distributed,file,system,here,means,that,the,file,system,is,shared,among,all,flink,processes,that,participate,in,a,cluster,or,job,and,that,all,these,processes,can,see,the,same,files,return,true,if,this,is,a,distributed,file,system,false,otherwise;public,abstract,boolean,is,distributed,fs
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1405024514;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {__					if (this.authority == null && key.authority == null) {_						return true__					}__					return false__				}__				if (!this.authority.equals(key.authority)) {_					return false__				}__				return true__			}__			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,if,this,authority,null,key,authority,null,return,true,return,false,if,this,authority,equals,key,authority,return,false,return,true,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1405090423;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {__					if (this.authority == null && key.authority == null) {_						return true__					}__					return false__				}__				if (!this.authority.equals(key.authority)) {_					return false__				}__				return true__			}__			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,if,this,authority,null,key,authority,null,return,true,return,false,if,this,authority,equals,key,authority,return,false,return,true,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1408359504;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {__					if (this.authority == null && key.authority == null) {_						return true__					}__					return false__				}__				if (!this.authority.equals(key.authority)) {_					return false__				}__				return true__			}__			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,if,this,authority,null,key,authority,null,return,true,return,false,if,this,authority,equals,key,authority,return,false,return,true,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1411473593;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {__					if (this.authority == null && key.authority == null) {_						return true__					}__					return false__				}__				if (!this.authority.equals(key.authority)) {_					return false__				}__				return true__			}__			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,if,this,authority,null,key,authority,null,return,true,return,false,if,this,authority,equals,key,authority,return,false,return,true,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1415031057;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {__					if (this.authority == null && key.authority == null) {_						return true__					}__					return false__				}__				if (!this.authority.equals(key.authority)) {_					return false__				}__				return true__			}__			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,if,this,authority,null,key,authority,null,return,true,return,false,if,this,authority,equals,key,authority,return,false,return,true,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1415302606;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {__					if (this.authority == null && key.authority == null) {_						return true__					}__					return false__				}__				if (!this.authority.equals(key.authority)) {_					return false__				}__				return true__			}__			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,if,this,authority,null,key,authority,null,return,true,return,false,if,this,authority,equals,key,authority,return,false,return,true,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1415617196;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {__					if (this.authority == null && key.authority == null) {_						return true__					}__					return false__				}__				if (!this.authority.equals(key.authority)) {_					return false__				}__				return true__			}__			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,if,this,authority,null,key,authority,null,return,true,return,false,if,this,authority,equals,key,authority,return,false,return,true,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1416482279;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1417108705;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1420731347;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1420731347;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1420731728;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1422034750;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1422959656;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1423847366;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1424860683;{@inheritDoc};@Override_		public boolean equals(final Object obj) {__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1427824467;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1431371277;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1445264257;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1446112342;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1450111459;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1450713543;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1451152602;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1452178883;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1455632624;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1467707997;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1479853012;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> @Override 		public boolean equals(final Object obj);1481633610;{@inheritDoc};@Override_		public boolean equals(final Object obj) {_			if (obj == this) {_				return true__			}__			if (obj instanceof FSKey) {_				final FSKey key = (FSKey) obj___				if (!this.scheme.equals(key.scheme)) {_					return false__				}__				if ((this.authority == null) || (key.authority == null)) {_					return this.authority == null && key.authority == null__				}_				return this.authority.equals(key.authority)__			}_			return false__		};inherit,doc;override,public,boolean,equals,final,object,obj,if,obj,this,return,true,if,obj,instanceof,fskey,final,fskey,key,fskey,obj,if,this,scheme,equals,key,scheme,return,false,if,this,authority,null,key,authority,null,return,this,authority,null,key,authority,null,return,this,authority,equals,key,authority,return,false
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1481715812;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1481715812;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1485255695;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1485698310;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1487082763;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1487548884;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1487548884;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1507223685;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1507223685;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1507281370;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1507304713;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1507752419;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1508481109;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1510933709;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1511520068;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1511520068;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1512410190;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1515600855;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1531689536;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(String scheme, @Nullable String authority);1531689536;Creates a file system key from a given scheme and an authority.__@param scheme     The scheme of the file system_@param authority  The authority of the file system;public FSKey(String scheme, @Nullable String authority) {_			this.scheme = checkNotNull(scheme, "scheme")__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,string,scheme,nullable,string,authority,this,scheme,check,not,null,scheme,scheme,this,authority,authority
FileSystem -> public abstract void initialize(URI name) throws IOException_;1405024514;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1405090423;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1408359504;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1411473593;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1415031057;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1415302606;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1415617196;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1416482279;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1417108705;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1420731347;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1420731347;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1420731728;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1422034750;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1422959656;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1423847366;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1424860683;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1427824467;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1431371277;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1445264257;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1446112342;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1450111459;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1450713543;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1451152602;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1452178883;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1455632624;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1467707997;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1479853012;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1481633610;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1481715812;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1481715812;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1485255695;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1485698310;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1487082763;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1487548884;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1487548884;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1507223685;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> public abstract void initialize(URI name) throws IOException_;1507223685;Called after a new FileSystem instance is constructed.__@param name_a {@link URI} whose authority section names the host, port, etc. for this file system;public abstract void initialize(URI name) throws IOException_;called,after,a,new,file,system,instance,is,constructed,param,name,a,link,uri,whose,authority,section,names,the,host,port,etc,for,this,file,system;public,abstract,void,initialize,uri,name,throws,ioexception
FileSystem -> private static List<FileSystemFactory> loadFileSystems();1511520068;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static List<FileSystemFactory> loadFileSystems() {_		final ArrayList<FileSystemFactory> list = new ArrayList<>()___		_		list.add(new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					list.add(factory)__					LOG.debug("Added file system {}:{}", factory.getScheme(), factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file system via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return Collections.unmodifiableList(list)__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,list,file,system,factory,load,file,systems,final,array,list,file,system,factory,list,new,array,list,list,add,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,list,add,factory,log,debug,added,file,system,factory,get,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,system,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,collections,unmodifiable,list,list
FileSystem -> private static List<FileSystemFactory> loadFileSystems();1512410190;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static List<FileSystemFactory> loadFileSystems() {_		final ArrayList<FileSystemFactory> list = new ArrayList<>()___		_		list.add(new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					list.add(factory)__					LOG.debug("Added file system {}:{}", factory.getScheme(), factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file system via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return Collections.unmodifiableList(list)__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,list,file,system,factory,load,file,systems,final,array,list,file,system,factory,list,new,array,list,list,add,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,list,add,factory,log,debug,added,file,system,factory,get,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,system,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,collections,unmodifiable,list,list
FileSystem -> private static List<FileSystemFactory> loadFileSystems();1515600855;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static List<FileSystemFactory> loadFileSystems() {_		final ArrayList<FileSystemFactory> list = new ArrayList<>()___		_		list.add(new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					list.add(factory)__					LOG.debug("Added file system {}:{}", factory.getScheme(), factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file system via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return Collections.unmodifiableList(list)__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,list,file,system,factory,load,file,systems,final,array,list,file,system,factory,list,new,array,list,list,add,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,list,add,factory,log,debug,added,file,system,factory,get,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,system,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,collections,unmodifiable,list,list
FileSystem -> private static List<FileSystemFactory> loadFileSystems();1531689536;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static List<FileSystemFactory> loadFileSystems() {_		final ArrayList<FileSystemFactory> list = new ArrayList<>()___		_		list.add(new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					list.add(factory)__					LOG.debug("Added file system {}:{}", factory.getScheme(), factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file system via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return Collections.unmodifiableList(list)__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,list,file,system,factory,load,file,systems,final,array,list,file,system,factory,list,new,array,list,list,add,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,list,add,factory,log,debug,added,file,system,factory,get,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,system,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,collections,unmodifiable,list,list
FileSystem -> private static List<FileSystemFactory> loadFileSystems();1531689536;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static List<FileSystemFactory> loadFileSystems() {_		final ArrayList<FileSystemFactory> list = new ArrayList<>()___		_		list.add(new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					list.add(factory)__					LOG.debug("Added file system {}:{}", factory.getScheme(), factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file system via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return Collections.unmodifiableList(list)__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,list,file,system,factory,load,file,systems,final,array,list,file,system,factory,list,new,array,list,list,add,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,list,add,factory,log,debug,added,file,system,factory,get,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,system,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,collections,unmodifiable,list,list
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1405024514;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1405090423;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1408359504;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1411473593;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1415031057;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1415302606;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1415617196;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1416482279;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1417108705;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1420731347;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1420731347;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1420731728;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1422034750;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1422959656;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1423847366;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1424860683;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1427824467;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1431371277;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1445264257;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1446112342;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1450111459;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1450713543;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1451152602;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1452178883;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1455632624;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1467707997;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1479853012;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1481633610;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1481715812;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1481715812;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1485255695;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1485698310;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1487082763;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1487548884;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1487548884;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1507223685;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1507223685;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1507281370;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1507304713;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1507752419;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1508481109;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1510933709;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1511520068;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1511520068;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1512410190;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1515600855;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1531689536;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;1531689536;Opens an FSDataInputStream at the indicated Path.__@param f_the file name to open_@param bufferSize_the size of the buffer to be used.;public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException_;opens,an,fsdata,input,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,buffer,size,the,size,of,the,buffer,to,be,used;public,abstract,fsdata,input,stream,open,path,f,int,buffer,size,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1405024514;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1405090423;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1408359504;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1411473593;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1415031057;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1415302606;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1415617196;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1416482279;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1417108705;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1420731347;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1420731347;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1420731728;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1422034750;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1422959656;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1423847366;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1424860683;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1427824467;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1431371277;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1445264257;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1446112342;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1450111459;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1450713543;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1451152602;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1452178883;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1455632624;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1467707997;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1479853012;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1481633610;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1481715812;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1481715812;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1485255695;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1485698310;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1487082763;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1487548884;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1487548884;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1507223685;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1507223685;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1507281370;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1507304713;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1507752419;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1508481109;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1510933709;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1511520068;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1511520068;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1512410190;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1515600855;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1531689536;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public abstract boolean mkdirs(Path f) throws IOException_;1531689536;Make the given file and all non-existent parents into directories. Has the semantics of Unix 'mkdir -p'._Existence of the directory hierarchy is not an error.__@param f_the directory/directories to be created_@return <code>true</code> if at least one new directory has been created, <code>false</code> otherwise_@throws IOException_thrown if an I/O error occurs while creating the directory;public abstract boolean mkdirs(Path f) throws IOException_;make,the,given,file,and,all,non,existent,parents,into,directories,has,the,semantics,of,unix,mkdir,p,existence,of,the,directory,hierarchy,is,not,an,error,param,f,the,directory,directories,to,be,created,return,code,true,code,if,at,least,one,new,directory,has,been,created,code,false,code,otherwise,throws,ioexception,thrown,if,an,i,o,error,occurs,while,creating,the,directory;public,abstract,boolean,mkdirs,path,f,throws,ioexception
FileSystem -> public static void createFileSystemCloseableRegistryForTask();1479853012;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the beginning of the task's_main thread.;public static void createFileSystemCloseableRegistryForTask() {_		SafetyNetCloseableRegistry oldRegistry = REGISTRIES.get()__		if (null != oldRegistry) {_			IOUtils.closeQuietly(oldRegistry)__			LOG.warn("Found existing SafetyNetCloseableRegistry. Closed and replaced it.")__		}_		SafetyNetCloseableRegistry newRegistry = new SafetyNetCloseableRegistry()__		REGISTRIES.set(newRegistry)__	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,beginning,of,the,task,s,main,thread;public,static,void,create,file,system,closeable,registry,for,task,safety,net,closeable,registry,old,registry,registries,get,if,null,old,registry,ioutils,close,quietly,old,registry,log,warn,found,existing,safety,net,closeable,registry,closed,and,replaced,it,safety,net,closeable,registry,new,registry,new,safety,net,closeable,registry,registries,set,new,registry
FileSystem -> public static void createFileSystemCloseableRegistryForTask();1481633610;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the beginning of the task's_main thread.;public static void createFileSystemCloseableRegistryForTask() {_		SafetyNetCloseableRegistry oldRegistry = REGISTRIES.get()__		if (null != oldRegistry) {_			IOUtils.closeQuietly(oldRegistry)__			LOG.warn("Found existing SafetyNetCloseableRegistry. Closed and replaced it.")__		}_		SafetyNetCloseableRegistry newRegistry = new SafetyNetCloseableRegistry()__		REGISTRIES.set(newRegistry)__	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,beginning,of,the,task,s,main,thread;public,static,void,create,file,system,closeable,registry,for,task,safety,net,closeable,registry,old,registry,registries,get,if,null,old,registry,ioutils,close,quietly,old,registry,log,warn,found,existing,safety,net,closeable,registry,closed,and,replaced,it,safety,net,closeable,registry,new,registry,new,safety,net,closeable,registry,registries,set,new,registry
FileSystem -> public static void createFileSystemCloseableRegistryForTask();1481715812;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the beginning of the task's_main thread.;public static void createFileSystemCloseableRegistryForTask() {_		SafetyNetCloseableRegistry oldRegistry = REGISTRIES.get()__		if (null != oldRegistry) {_			IOUtils.closeQuietly(oldRegistry)__			LOG.warn("Found existing SafetyNetCloseableRegistry. Closed and replaced it.")__		}_		SafetyNetCloseableRegistry newRegistry = new SafetyNetCloseableRegistry()__		REGISTRIES.set(newRegistry)__	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,beginning,of,the,task,s,main,thread;public,static,void,create,file,system,closeable,registry,for,task,safety,net,closeable,registry,old,registry,registries,get,if,null,old,registry,ioutils,close,quietly,old,registry,log,warn,found,existing,safety,net,closeable,registry,closed,and,replaced,it,safety,net,closeable,registry,new,registry,new,safety,net,closeable,registry,registries,set,new,registry
FileSystem -> public static void createFileSystemCloseableRegistryForTask();1481715812;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the beginning of the task's_main thread.;public static void createFileSystemCloseableRegistryForTask() {_		SafetyNetCloseableRegistry oldRegistry = REGISTRIES.get()__		if (null != oldRegistry) {_			IOUtils.closeQuietly(oldRegistry)__			LOG.warn("Found existing SafetyNetCloseableRegistry. Closed and replaced it.")__		}_		SafetyNetCloseableRegistry newRegistry = new SafetyNetCloseableRegistry()__		REGISTRIES.set(newRegistry)__	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,beginning,of,the,task,s,main,thread;public,static,void,create,file,system,closeable,registry,for,task,safety,net,closeable,registry,old,registry,registries,get,if,null,old,registry,ioutils,close,quietly,old,registry,log,warn,found,existing,safety,net,closeable,registry,closed,and,replaced,it,safety,net,closeable,registry,new,registry,new,safety,net,closeable,registry,registries,set,new,registry
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1405024514;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1405090423;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1408359504;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1411473593;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1415031057;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1415302606;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1415617196;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1416482279;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1417108705;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1420731347;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1420731347;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1420731728;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1422034750;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1422959656;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1423847366;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1424860683;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1427824467;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1431371277;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1445264257;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1446112342;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1450111459;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1450713543;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1451152602;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1452178883;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1455632624;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1467707997;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1479853012;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> FSKey -> public FSKey(final String scheme, final String authority);1481633610;Creates a file system key from a given scheme and an_authority.__@param scheme_the scheme of the file system_@param authority_the authority of the file system;public FSKey(final String scheme, final String authority) {_			this.scheme = scheme__			this.authority = authority__		};creates,a,file,system,key,from,a,given,scheme,and,an,authority,param,scheme,the,scheme,of,the,file,system,param,authority,the,authority,of,the,file,system;public,fskey,final,string,scheme,final,string,authority,this,scheme,scheme,this,authority,authority
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1467707997;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1479853012;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1481633610;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1481715812;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1481715812;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1485255695;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1485698310;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1487082763;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1487548884;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1487548884;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> public static boolean isFlinkSupportedScheme(String scheme);1507223685;Returns a boolean indicating whether a scheme has built-in Flink support.__@param scheme_a file system scheme_@return a boolean indicating whether the provided scheme has built-in Flink support;public static boolean isFlinkSupportedScheme(String scheme) {_		return FSDIRECTORY.containsKey(scheme)__	};returns,a,boolean,indicating,whether,a,scheme,has,built,in,flink,support,param,scheme,a,file,system,scheme,return,a,boolean,indicating,whether,the,provided,scheme,has,built,in,flink,support;public,static,boolean,is,flink,supported,scheme,string,scheme,return,fsdirectory,contains,key,scheme
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1507304713;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl).asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " + _					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1507752419;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl).asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " + _					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1508481109;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl).asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " + _					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1510933709;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl).asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " + _					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1511520068;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class_					.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl)_					.asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1511520068;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class_					.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl)_					.asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1512410190;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class_					.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl)_					.asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1515600855;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class_					.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl)_					.asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1531689536;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class_					.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl)_					.asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> private static FileSystemFactory loadHadoopFsFactory();1531689536;Utility loader for the Hadoop file system factory._We treat the Hadoop FS factory in a special way, because we use it as a catch_all for file systems schemes not supported directly in Flink.__<p>This method does a set of eager checks for availability of certain classes, to_be able to give better error messages.;private static FileSystemFactory loadHadoopFsFactory() {_		final ClassLoader cl = FileSystem.class.getClassLoader()___		_		final Class<? extends FileSystemFactory> factoryClass__		try {_			factoryClass = Class_					.forName("org.apache.flink.runtime.fs.hdfs.HadoopFsFactory", false, cl)_					.asSubclass(FileSystemFactory.class)__		}_		catch (ClassNotFoundException e) {_			LOG.info("No Flink runtime dependency present. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Flink runtime classes missing in classpath/dependencies.")__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be loaded", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be loaded", e)__		}__		_		try {_			Class.forName("org.apache.hadoop.conf.Configuration", false, cl)__			Class.forName("org.apache.hadoop.fs.FileSystem", false, cl)__		}_		catch (ClassNotFoundException e) {_			LOG.info("Hadoop is not in the classpath/dependencies. " +_					"The extended set of supported File Systems via Hadoop is not available.")__			return new UnsupportedSchemeFactory("Hadoop is not in the classpath/dependencies.")__		}__		_		try {_			return factoryClass.newInstance()__		}_		catch (Exception | LinkageError e) {_			LOG.warn("Flink's Hadoop file system factory could not be created", e)__			return new UnsupportedSchemeFactory("Flink's Hadoop file system factory could not be created", e)__		}_	};utility,loader,for,the,hadoop,file,system,factory,we,treat,the,hadoop,fs,factory,in,a,special,way,because,we,use,it,as,a,catch,all,for,file,systems,schemes,not,supported,directly,in,flink,p,this,method,does,a,set,of,eager,checks,for,availability,of,certain,classes,to,be,able,to,give,better,error,messages;private,static,file,system,factory,load,hadoop,fs,factory,final,class,loader,cl,file,system,class,get,class,loader,final,class,extends,file,system,factory,factory,class,try,factory,class,class,for,name,org,apache,flink,runtime,fs,hdfs,hadoop,fs,factory,false,cl,as,subclass,file,system,factory,class,catch,class,not,found,exception,e,log,info,no,flink,runtime,dependency,present,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,flink,runtime,classes,missing,in,classpath,dependencies,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,loaded,e,try,class,for,name,org,apache,hadoop,conf,configuration,false,cl,class,for,name,org,apache,hadoop,fs,file,system,false,cl,catch,class,not,found,exception,e,log,info,hadoop,is,not,in,the,classpath,dependencies,the,extended,set,of,supported,file,systems,via,hadoop,is,not,available,return,new,unsupported,scheme,factory,hadoop,is,not,in,the,classpath,dependencies,try,return,factory,class,new,instance,catch,exception,linkage,error,e,log,warn,flink,s,hadoop,file,system,factory,could,not,be,created,e,return,new,unsupported,scheme,factory,flink,s,hadoop,file,system,factory,could,not,be,created,e
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1405024514;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1405090423;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1408359504;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1411473593;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1415031057;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1415302606;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1415617196;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1416482279;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1417108705;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1420731347;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1420731347;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1420731728;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1422034750;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1422959656;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1423847366;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1424860683;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1427824467;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1431371277;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1445264257;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1446112342;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1450111459;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1450713543;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1451152602;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1452178883;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1455632624;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1467707997;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1479853012;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1481633610;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1481715812;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1481715812;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1485255695;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1485698310;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1487082763;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks_@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1487548884;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1487548884;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1507223685;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1507223685;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1507281370;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1507304713;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1507752419;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1508481109;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1510933709;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1511520068;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1511520068;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1512410190;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1515600855;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1531689536;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException;1531689536;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Use {@link #create(Path, WriteMode)} instead.;@Deprecated_	public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {_		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,use,link,create,path,write,mode,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> public long getDefaultBlockSize();1405024514;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1405090423;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1408359504;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1411473593;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1415031057;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1415302606;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1415617196;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1416482279;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1417108705;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1420731347;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1420731347;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1420731728;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1422034750;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1422959656;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1423847366;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1424860683;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1427824467;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1431371277;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1445264257;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1446112342;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1450111459;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1450713543;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1451152602;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1452178883;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1455632624;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1467707997;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1479853012;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1481633610;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1481715812;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1481715812;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1485255695;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1485698310;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1487082763;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1487548884;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public long getDefaultBlockSize();1487548884;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time;public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time;public,long,get,default,block,size,return,32,1024,1024
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1405024514;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1405090423;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1408359504;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1411473593;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1415031057;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1415302606;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1415617196;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1416482279;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1417108705;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1420731347;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1420731347;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1420731728;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1422034750;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1422959656;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1423847366;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1424860683;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1427824467;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1431371277;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1445264257;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1446112342;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1450111459;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1450713543;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1451152602;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1452178883;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1455632624;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1467707997;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1479853012;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1481633610;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1481715812;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1481715812;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1485255695;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1485698310;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1487082763;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1487548884;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1487548884;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1507223685;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1507223685;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1507281370;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1507304713;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1507752419;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1508481109;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1510933709;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1511520068;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1511520068;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1512410190;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1515600855;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1531689536;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FileStatus getFileStatus(Path f) throws IOException_;1531689536;Return a file status object that represents the path.__@param f_The path we want information from_@return a FileStatus object_@throws FileNotFoundException_when the path does not exist__IOException see specific implementation;public abstract FileStatus getFileStatus(Path f) throws IOException_;return,a,file,status,object,that,represents,the,path,param,f,the,path,we,want,information,from,return,a,file,status,object,throws,file,not,found,exception,when,the,path,does,not,exist,ioexception,see,specific,implementation;public,abstract,file,status,get,file,status,path,f,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1487548884;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1487548884;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1507223685;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1507223685;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1507281370;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1507304713;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1507752419;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1508481109;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1510933709;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1511520068;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1511520068;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1512410190;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1515600855;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1531689536;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;1531689536;Opens an FSDataOutputStream to a new file at the given path.__<p>If the file already exists, the behavior depends on the given {@code WriteMode}._If the mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an_exception.__@param f The file path to write to_@param overwriteMode The action to take if a file or directory already exists at the given path._@return The stream to the new file at the target path.__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.;public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException_;opens,an,fsdata,output,stream,to,a,new,file,at,the,given,path,p,if,the,file,already,exists,the,behavior,depends,on,the,given,code,write,mode,if,the,mode,is,set,to,link,write,mode,then,this,method,fails,with,an,exception,param,f,the,file,path,to,write,to,param,overwrite,mode,the,action,to,take,if,a,file,or,directory,already,exists,at,the,given,path,return,the,stream,to,the,new,file,at,the,target,path,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file;public,abstract,fsdata,output,stream,create,path,f,write,mode,overwrite,mode,throws,ioexception
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1507281370;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link ConfigConstants#FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()___			_			for (FileSystemFactory factory : FS_FACTORIES.values()) {_				factory.configure(config)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				DEFAULT_SCHEME = null__			}_			else {_				try {_					DEFAULT_SCHEME = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							ConfigConstants.FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,config,constants,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,for,file,system,factory,factory,values,factory,configure,config,configure,config,final,string,stringified,uri,config,get,string,config,constants,null,if,stringified,uri,null,null,else,try,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,config,constants,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1507304713;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link ConfigConstants#FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()___			_			for (FileSystemFactory factory : FS_FACTORIES.values()) {_				factory.configure(config)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				DEFAULT_SCHEME = null__			}_			else {_				try {_					DEFAULT_SCHEME = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							ConfigConstants.FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,config,constants,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,for,file,system,factory,factory,values,factory,configure,config,configure,config,final,string,stringified,uri,config,get,string,config,constants,null,if,stringified,uri,null,null,else,try,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,config,constants,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1507752419;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link ConfigConstants#FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()___			_			for (FileSystemFactory factory : FS_FACTORIES.values()) {_				factory.configure(config)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				DEFAULT_SCHEME = null__			}_			else {_				try {_					DEFAULT_SCHEME = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							ConfigConstants.FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,config,constants,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,for,file,system,factory,factory,values,factory,configure,config,configure,config,final,string,stringified,uri,config,get,string,config,constants,null,if,stringified,uri,null,null,else,try,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,config,constants,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1508481109;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link ConfigConstants#FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()___			_			for (FileSystemFactory factory : FS_FACTORIES.values()) {_				factory.configure(config)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				DEFAULT_SCHEME = null__			}_			else {_				try {_					DEFAULT_SCHEME = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							ConfigConstants.FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,config,constants,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,for,file,system,factory,factory,values,factory,configure,config,configure,config,final,string,stringified,uri,config,get,string,config,constants,null,if,stringified,uri,null,null,else,try,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,config,constants,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1510933709;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link ConfigConstants#FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()___			_			for (FileSystemFactory factory : FS_FACTORIES.values()) {_				factory.configure(config)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				DEFAULT_SCHEME = null__			}_			else {_				try {_					DEFAULT_SCHEME = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							ConfigConstants.FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,config,constants,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,for,file,system,factory,factory,values,factory,configure,config,configure,config,final,string,stringified,uri,config,get,string,config,constants,null,if,stringified,uri,null,null,else,try,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,config,constants,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1511520068;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link ConfigConstants#FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()___			_			for (FileSystemFactory factory : FS_FACTORIES.values()) {_				factory.configure(config)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				DEFAULT_SCHEME = null__			}_			else {_				try {_					DEFAULT_SCHEME = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							ConfigConstants.FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,config,constants,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,for,file,system,factory,factory,values,factory,configure,config,configure,config,final,string,stringified,uri,config,get,string,config,constants,null,if,stringified,uri,null,null,else,try,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,config,constants,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1511520068;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link CoreOptions#DEFAULT_FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()__			FS_FACTORIES.clear()___			_			for (FileSystemFactory factory : RAW_FACTORIES) {_				factory.configure(config)__				String scheme = factory.getScheme()___				FileSystemFactory fsf = ConnectionLimitingFactory.decorateIfLimited(factory, scheme, config)__				FS_FACTORIES.put(scheme, fsf)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(CoreOptions.DEFAULT_FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				DEFAULT_SCHEME = null__			}_			else {_				try {_					DEFAULT_SCHEME = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							CoreOptions.DEFAULT_FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,core,options,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,clear,for,file,system,factory,factory,factory,configure,config,string,scheme,factory,get,scheme,file,system,factory,fsf,connection,limiting,factory,decorate,if,limited,factory,scheme,config,put,scheme,fsf,configure,config,final,string,stringified,uri,config,get,string,core,options,null,if,stringified,uri,null,null,else,try,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,core,options,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1512410190;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link CoreOptions#DEFAULT_FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()__			FS_FACTORIES.clear()___			_			for (FileSystemFactory factory : RAW_FACTORIES) {_				factory.configure(config)__				String scheme = factory.getScheme()___				FileSystemFactory fsf = ConnectionLimitingFactory.decorateIfLimited(factory, scheme, config)__				FS_FACTORIES.put(scheme, fsf)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(CoreOptions.DEFAULT_FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				DEFAULT_SCHEME = null__			}_			else {_				try {_					DEFAULT_SCHEME = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							CoreOptions.DEFAULT_FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,core,options,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,clear,for,file,system,factory,factory,factory,configure,config,string,scheme,factory,get,scheme,file,system,factory,fsf,connection,limiting,factory,decorate,if,limited,factory,scheme,config,put,scheme,fsf,configure,config,final,string,stringified,uri,config,get,string,core,options,null,if,stringified,uri,null,null,else,try,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,core,options,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1515600855;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link CoreOptions#DEFAULT_FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()__			FS_FACTORIES.clear()___			_			for (FileSystemFactory factory : RAW_FACTORIES) {_				factory.configure(config)__				String scheme = factory.getScheme()___				FileSystemFactory fsf = ConnectionLimitingFactory.decorateIfLimited(factory, scheme, config)__				FS_FACTORIES.put(scheme, fsf)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(CoreOptions.DEFAULT_FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				DEFAULT_SCHEME = null__			}_			else {_				try {_					DEFAULT_SCHEME = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							CoreOptions.DEFAULT_FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,core,options,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,clear,for,file,system,factory,factory,factory,configure,config,string,scheme,factory,get,scheme,file,system,factory,fsf,connection,limiting,factory,decorate,if,limited,factory,scheme,config,put,scheme,fsf,configure,config,final,string,stringified,uri,config,get,string,core,options,null,if,stringified,uri,null,null,else,try,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,core,options,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1531689536;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link CoreOptions#DEFAULT_FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()__			FS_FACTORIES.clear()___			_			for (FileSystemFactory factory : RAW_FACTORIES) {_				factory.configure(config)__				String scheme = factory.getScheme()___				FileSystemFactory fsf = ConnectionLimitingFactory.decorateIfLimited(factory, scheme, config)__				FS_FACTORIES.put(scheme, fsf)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(CoreOptions.DEFAULT_FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				defaultScheme = null__			}_			else {_				try {_					defaultScheme = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							CoreOptions.DEFAULT_FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,core,options,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,clear,for,file,system,factory,factory,factory,configure,config,string,scheme,factory,get,scheme,file,system,factory,fsf,connection,limiting,factory,decorate,if,limited,factory,scheme,config,put,scheme,fsf,configure,config,final,string,stringified,uri,config,get,string,core,options,null,if,stringified,uri,null,default,scheme,null,else,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,core,options,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void initialize(Configuration config) throws IOException, IllegalConfigurationException;1531689536;Initializes the shared file system settings.__<p>The given configuration is passed to each file system factory to initialize the respective_file systems. Because the configuration of file systems may be different subsequent to the call_of this method, this method clears the file system instance cache.__<p>This method also reads the default file system URI from the configuration key_{@link CoreOptions#DEFAULT_FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where_the URI has no scheme will be interpreted as relative to that URI._As an example, assume the default file system URI is set to {@code 'hdfs://localhost:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://localhost:9000/user/USERNAME/in.txt'}.__@param config the configuration from where to fetch the parameter.;public static void initialize(Configuration config) throws IOException, IllegalConfigurationException {_		LOCK.lock()__		try {_			_			CACHE.clear()__			FS_FACTORIES.clear()___			_			for (FileSystemFactory factory : RAW_FACTORIES) {_				factory.configure(config)__				String scheme = factory.getScheme()___				FileSystemFactory fsf = ConnectionLimitingFactory.decorateIfLimited(factory, scheme, config)__				FS_FACTORIES.put(scheme, fsf)__			}__			_			FALLBACK_FACTORY.configure(config)___			_			final String stringifiedUri = config.getString(CoreOptions.DEFAULT_FILESYSTEM_SCHEME, null)__			if (stringifiedUri == null) {_				defaultScheme = null__			}_			else {_				try {_					defaultScheme = new URI(stringifiedUri)__				}_				catch (URISyntaxException e) {_					throw new IllegalConfigurationException("The default file system scheme ('" +_							CoreOptions.DEFAULT_FILESYSTEM_SCHEME + "') is invalid: " + stringifiedUri, e)__				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};initializes,the,shared,file,system,settings,p,the,given,configuration,is,passed,to,each,file,system,factory,to,initialize,the,respective,file,systems,because,the,configuration,of,file,systems,may,be,different,subsequent,to,the,call,of,this,method,this,method,clears,the,file,system,instance,cache,p,this,method,also,reads,the,default,file,system,uri,from,the,configuration,key,link,core,options,all,calls,to,link,file,system,get,uri,where,the,uri,has,no,scheme,will,be,interpreted,as,relative,to,that,uri,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,localhost,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,localhost,9000,user,username,in,txt,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,initialize,configuration,config,throws,ioexception,illegal,configuration,exception,lock,lock,try,cache,clear,clear,for,file,system,factory,factory,factory,configure,config,string,scheme,factory,get,scheme,file,system,factory,fsf,connection,limiting,factory,decorate,if,limited,factory,scheme,config,put,scheme,fsf,configure,config,final,string,stringified,uri,config,get,string,core,options,null,if,stringified,uri,null,default,scheme,null,else,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,illegal,configuration,exception,the,default,file,system,scheme,core,options,is,invalid,stringified,uri,e,finally,lock,unlock
FileSystem -> public static void disposeFileSystemCloseableRegistryForTask();1479853012;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the end of the task's_main thread or when the task should be canceled.;public static void disposeFileSystemCloseableRegistryForTask() {_		SafetyNetCloseableRegistry registry = REGISTRIES.get()__		if (null != registry) {_			LOG.info("Ensuring all FileSystem streams are closed")__			REGISTRIES.remove()__			IOUtils.closeQuietly(registry)__		}_	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,end,of,the,task,s,main,thread,or,when,the,task,should,be,canceled;public,static,void,dispose,file,system,closeable,registry,for,task,safety,net,closeable,registry,registry,registries,get,if,null,registry,log,info,ensuring,all,file,system,streams,are,closed,registries,remove,ioutils,close,quietly,registry
FileSystem -> public static void disposeFileSystemCloseableRegistryForTask();1481633610;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the end of the task's_main thread or when the task should be canceled.;public static void disposeFileSystemCloseableRegistryForTask() {_		SafetyNetCloseableRegistry registry = REGISTRIES.get()__		if (null != registry) {_			LOG.info("Ensuring all FileSystem streams are closed for {}", Thread.currentThread().getName())__			REGISTRIES.remove()__			IOUtils.closeQuietly(registry)__		}_	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,end,of,the,task,s,main,thread,or,when,the,task,should,be,canceled;public,static,void,dispose,file,system,closeable,registry,for,task,safety,net,closeable,registry,registry,registries,get,if,null,registry,log,info,ensuring,all,file,system,streams,are,closed,for,thread,current,thread,get,name,registries,remove,ioutils,close,quietly,registry
FileSystem -> public static void disposeFileSystemCloseableRegistryForTask();1481715812;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the end of the task's_main thread or when the task should be canceled.;public static void disposeFileSystemCloseableRegistryForTask() {_		SafetyNetCloseableRegistry registry = REGISTRIES.get()__		if (null != registry) {_			LOG.info("Ensuring all FileSystem streams are closed for {}", Thread.currentThread().getName())__			REGISTRIES.remove()__			IOUtils.closeQuietly(registry)__		}_	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,end,of,the,task,s,main,thread,or,when,the,task,should,be,canceled;public,static,void,dispose,file,system,closeable,registry,for,task,safety,net,closeable,registry,registry,registries,get,if,null,registry,log,info,ensuring,all,file,system,streams,are,closed,for,thread,current,thread,get,name,registries,remove,ioutils,close,quietly,registry
FileSystem -> public static void disposeFileSystemCloseableRegistryForTask();1481715812;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the end of the task's_main thread or when the task should be canceled.;public static void disposeFileSystemCloseableRegistryForTask() {_		SafetyNetCloseableRegistry registry = REGISTRIES.get()__		if (null != registry) {_			LOG.info("Ensuring all FileSystem streams are closed for {}", Thread.currentThread().getName())__			REGISTRIES.remove()__			IOUtils.closeQuietly(registry)__		}_	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,end,of,the,task,s,main,thread,or,when,the,task,should,be,canceled;public,static,void,dispose,file,system,closeable,registry,for,task,safety,net,closeable,registry,registry,registries,get,if,null,registry,log,info,ensuring,all,file,system,streams,are,closed,for,thread,current,thread,get,name,registries,remove,ioutils,close,quietly,registry
FileSystem -> public abstract FileSystemKind getKind()_;1510933709;Gets a description of the characteristics of this file system.;public abstract FileSystemKind getKind()_;gets,a,description,of,the,characteristics,of,this,file,system;public,abstract,file,system,kind,get,kind
FileSystem -> public abstract FileSystemKind getKind()_;1511520068;Gets a description of the characteristics of this file system.;public abstract FileSystemKind getKind()_;gets,a,description,of,the,characteristics,of,this,file,system;public,abstract,file,system,kind,get,kind
FileSystem -> public abstract FileSystemKind getKind()_;1511520068;Gets a description of the characteristics of this file system.;public abstract FileSystemKind getKind()_;gets,a,description,of,the,characteristics,of,this,file,system;public,abstract,file,system,kind,get,kind
FileSystem -> public abstract FileSystemKind getKind()_;1512410190;Gets a description of the characteristics of this file system.;public abstract FileSystemKind getKind()_;gets,a,description,of,the,characteristics,of,this,file,system;public,abstract,file,system,kind,get,kind
FileSystem -> public abstract FileSystemKind getKind()_;1515600855;Gets a description of the characteristics of this file system.;public abstract FileSystemKind getKind()_;gets,a,description,of,the,characteristics,of,this,file,system;public,abstract,file,system,kind,get,kind
FileSystem -> public abstract FileSystemKind getKind()_;1531689536;Gets a description of the characteristics of this file system.;public abstract FileSystemKind getKind()_;gets,a,description,of,the,characteristics,of,this,file,system;public,abstract,file,system,kind,get,kind
FileSystem -> public abstract FileSystemKind getKind()_;1531689536;Gets a description of the characteristics of this file system.;public abstract FileSystemKind getKind()_;gets,a,description,of,the,characteristics,of,this,file,system;public,abstract,file,system,kind,get,kind
FileSystem -> FSKey -> @Override 		public int hashCode();1405024514;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1405090423;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1408359504;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1411473593;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1415031057;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1415302606;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1415617196;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1416482279;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1417108705;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1420731347;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1420731347;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1420731728;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1422034750;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1422959656;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1423847366;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1424860683;{@inheritDoc};@Override_		public int hashCode() {__			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1427824467;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1431371277;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1445264257;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1446112342;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1450111459;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1450713543;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1451152602;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1452178883;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1455632624;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1467707997;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1479853012;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> FSKey -> @Override 		public int hashCode();1481633610;{@inheritDoc};@Override_		public int hashCode() {_			if (this.scheme != null) {_				return this.scheme.hashCode()__			}__			if (this.authority != null) {_				return this.authority.hashCode()__			}__			return super.hashCode()__		};inherit,doc;override,public,int,hash,code,if,this,scheme,null,return,this,scheme,hash,code,if,this,authority,null,return,this,authority,hash,code,return,super,hash,code
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1405024514;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1405090423;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1408359504;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1411473593;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1415031057;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1415302606;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1415617196;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1416482279;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1417108705;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1420731347;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1420731347;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1420731728;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1422034750;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1422959656;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1423847366;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1424860683;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1427824467;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1431371277;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1445264257;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1446112342;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1450111459;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1450713543;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1451152602;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1452178883;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1455632624;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1467707997;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1479853012;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1481633610;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1481715812;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1481715812;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1485255695;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1485698310;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1487082763;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1487548884;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1487548884;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1507223685;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1507223685;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1507281370;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1507304713;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1507752419;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1508481109;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1510933709;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1511520068;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1511520068;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1512410190;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1515600855;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1531689536;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract boolean delete(Path f, boolean recursive) throws IOException_;1531689536;Delete a file.__@param f_the path to delete_@param recursive_if path is a directory and set to <code>true</code>, the directory is deleted else throws an exception. In_case of a file the recursive can be set to either <code>true</code> or <code>false</code>_@return <code>true</code> if delete is successful, <code>false</code> otherwise_@throws IOException;public abstract boolean delete(Path f, boolean recursive) throws IOException_;delete,a,file,param,f,the,path,to,delete,param,recursive,if,path,is,a,directory,and,set,to,code,true,code,the,directory,is,deleted,else,throws,an,exception,in,case,of,a,file,the,recursive,can,be,set,to,either,code,true,code,or,code,false,code,return,code,true,code,if,delete,is,successful,code,false,code,otherwise,throws,ioexception;public,abstract,boolean,delete,path,f,boolean,recursive,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1405024514;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1405090423;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1408359504;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1411473593;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1415031057;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1415302606;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1415617196;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1416482279;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1417108705;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1420731347;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1420731347;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1420731728;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1422034750;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1422959656;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1423847366;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1424860683;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1427824467;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1431371277;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1445264257;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1446112342;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1450111459;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1450713543;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1451152602;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1452178883;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1455632624;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1467707997;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1479853012;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1481633610;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1481715812;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1481715812;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1485255695;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1485698310;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;1487082763;Opens an FSDataOutputStream at the indicated Path.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@throws IOException;public abstract FSDataOutputStream create(Path f, boolean overwrite) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,throws,ioexception;public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,throws,ioexception
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1507223685;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1507223685;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1507281370;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1507304713;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1507752419;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1508481109;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1510933709;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1511520068;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1511520068;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1512410190;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1515600855;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1531689536;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> @Deprecated 	public FSDataOutputStream create( 			Path f, 			boolean overwrite, 			int bufferSize, 			short replication, 			long blockSize) throws IOException;1531689536;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public FSDataOutputStream create(_			Path f,_			boolean overwrite,_			int bufferSize,_			short replication,_			long blockSize) throws IOException {__		return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE)__	};opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception,return,create,f,overwrite,write,mode,overwrite,write,mode
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1405024514;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1405090423;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1408359504;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1411473593;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1415031057;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1415302606;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1415617196;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1416482279;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1417108705;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1420731347;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1420731347;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1420731728;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1422034750;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1422959656;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1423847366;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1424860683;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1427824467;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1431371277;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1445264257;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1446112342;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1450111459;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1450713543;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1451152602;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1452178883;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1455632624;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1467707997;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1479853012;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1481633610;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1481715812;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1481715812;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1485255695;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1485698310;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1487082763;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1487548884;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1487548884;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1507223685;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1507223685;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1507281370;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1507304713;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1507752419;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1508481109;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1510933709;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1511520068;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1511520068;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1512410190;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1515600855;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1531689536;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;1531689536;Return an array containing hostnames, offset and size of_portions of the given file. For a nonexistent_file or regions, null will be returned._This call is most helpful with DFS, where it returns_hostnames of machines that contain the given file._The FileSystem will simply return an elt containing 'localhost'.;public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException_;return,an,array,containing,hostnames,offset,and,size,of,portions,of,the,given,file,for,a,nonexistent,file,or,regions,null,will,be,returned,this,call,is,most,helpful,with,dfs,where,it,returns,hostnames,of,machines,that,contain,the,given,file,the,file,system,will,simply,return,an,elt,containing,localhost;public,abstract,block,location,get,file,block,locations,file,status,file,long,start,long,len,throws,ioexception
FileSystem -> public static FileSystem getLocalFileSystem();1431371277;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1445264257;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1446112342;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1450111459;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1450713543;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1451152602;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1452178883;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1455632624;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1467707997;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1479853012;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1481633610;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1481715812;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1481715812;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1485255695;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1485698310;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1487082763;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1487548884;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1487548884;Returns a reference to the {@link FileSystem} instance for accessing the_local file system.__@return a reference to the {@link FileSystem} instance for accessing the_local file system.;public static FileSystem getLocalFileSystem() {_		_		try {_			URI localUri = OperatingSystem.isWindows() ? new URI("file:/") : new URI("file:///")__			return get(localUri)__		}_		catch (Exception e) {_			throw new RuntimeException("Cannot create URI for local file system")__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,try,uri,local,uri,operating,system,is,windows,new,uri,file,new,uri,file,return,get,local,uri,catch,exception,e,throw,new,runtime,exception,cannot,create,uri,for,local,file,system
FileSystem -> public static FileSystem getLocalFileSystem();1507223685;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		LOCK.lock()__		try {_			if (LOCAL_FS == null) {_				LOCAL_FS = new LocalFileSystem()__			}_			return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LOCAL_FS)__		} finally {_			LOCK.unlock()__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,lock,lock,try,if,null,new,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,finally,lock,unlock
FileSystem -> public static FileSystem getLocalFileSystem();1507223685;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		LOCK.lock()__		try {_			if (LOCAL_FS == null) {_				LOCAL_FS = new LocalFileSystem()__			}_			return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LOCAL_FS)__		} finally {_			LOCK.unlock()__		}_	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,lock,lock,try,if,null,new,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,finally,lock,unlock
FileSystem -> public static FileSystem getLocalFileSystem();1507281370;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1507304713;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1507752419;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1508481109;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1510933709;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1511520068;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1511520068;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1512410190;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1515600855;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1531689536;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> public static FileSystem getLocalFileSystem();1531689536;Returns a reference to the {@link FileSystem} instance for accessing the local file system.__@return a reference to the {@link FileSystem} instance for accessing the local file system.;public static FileSystem getLocalFileSystem() {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(LocalFileSystem.getSharedInstance())__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,local,file,system;public,static,file,system,get,local,file,system,return,file,system,safety,net,wrap,with,safety,net,when,activated,local,file,system,get,shared,instance
FileSystem -> @Deprecated 	public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1487548884;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> @Deprecated 	public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, 			long blockSize) throws IOException_;1487548884;Opens an FSDataOutputStream at the indicated Path.__<p>This method is deprecated, because most of its parameters are ignored by most file systems._To control for example the replication factor and block size in the Hadoop Distributed File system,_make sure that the respective Hadoop configuration file is either linked from the Flink configuration,_or in the classpath of either Flink or the user code.__@param f_the file name to open_@param overwrite_if a file with this name already exists, then if true,_the file will be overwritten, and if false an error will be thrown._@param bufferSize_the size of the buffer to be used._@param replication_required block replication for the file._@param blockSize_the size of the file blocks__@throws IOException Thrown, if the stream could not be opened because of an I/O, or because_a file already exists at that path and the write mode indicates to not_overwrite the file.__@deprecated Deprecated because not well supported across types of file systems._Control the behavior of specific file systems via configurations instead.;@Deprecated_	public abstract FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication,_			long blockSize) throws IOException_;opens,an,fsdata,output,stream,at,the,indicated,path,p,this,method,is,deprecated,because,most,of,its,parameters,are,ignored,by,most,file,systems,to,control,for,example,the,replication,factor,and,block,size,in,the,hadoop,distributed,file,system,make,sure,that,the,respective,hadoop,configuration,file,is,either,linked,from,the,flink,configuration,or,in,the,classpath,of,either,flink,or,the,user,code,param,f,the,file,name,to,open,param,overwrite,if,a,file,with,this,name,already,exists,then,if,true,the,file,will,be,overwritten,and,if,false,an,error,will,be,thrown,param,buffer,size,the,size,of,the,buffer,to,be,used,param,replication,required,block,replication,for,the,file,param,block,size,the,size,of,the,file,blocks,throws,ioexception,thrown,if,the,stream,could,not,be,opened,because,of,an,i,o,or,because,a,file,already,exists,at,that,path,and,the,write,mode,indicates,to,not,overwrite,the,file,deprecated,deprecated,because,not,well,supported,across,types,of,file,systems,control,the,behavior,of,specific,file,systems,via,configurations,instead;deprecated,public,abstract,fsdata,output,stream,create,path,f,boolean,overwrite,int,buffer,size,short,replication,long,block,size,throws,ioexception
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1405024514;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (int i = 0_ i < files.length_ i++) {__			if (!files[i].isDir()) {_				numberOfBlocks += getNumberOfBlocks(files[i].getLen(), files[i].getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,int,i,0,i,files,length,i,if,files,i,is,dir,number,of,blocks,get,number,of,blocks,files,i,get,len,files,i,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1405090423;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (int i = 0_ i < files.length_ i++) {__			if (!files[i].isDir()) {_				numberOfBlocks += getNumberOfBlocks(files[i].getLen(), files[i].getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,int,i,0,i,files,length,i,if,files,i,is,dir,number,of,blocks,get,number,of,blocks,files,i,get,len,files,i,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1408359504;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (int i = 0_ i < files.length_ i++) {__			if (!files[i].isDir()) {_				numberOfBlocks += getNumberOfBlocks(files[i].getLen(), files[i].getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,int,i,0,i,files,length,i,if,files,i,is,dir,number,of,blocks,get,number,of,blocks,files,i,get,len,files,i,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1411473593;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (int i = 0_ i < files.length_ i++) {__			if (!files[i].isDir()) {_				numberOfBlocks += getNumberOfBlocks(files[i].getLen(), files[i].getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,int,i,0,i,files,length,i,if,files,i,is,dir,number,of,blocks,get,number,of,blocks,files,i,get,len,files,i,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1415031057;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (int i = 0_ i < files.length_ i++) {__			if (!files[i].isDir()) {_				numberOfBlocks += getNumberOfBlocks(files[i].getLen(), files[i].getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,int,i,0,i,files,length,i,if,files,i,is,dir,number,of,blocks,get,number,of,blocks,files,i,get,len,files,i,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1415302606;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (int i = 0_ i < files.length_ i++) {__			if (!files[i].isDir()) {_				numberOfBlocks += getNumberOfBlocks(files[i].getLen(), files[i].getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,int,i,0,i,files,length,i,if,files,i,is,dir,number,of,blocks,get,number,of,blocks,files,i,get,len,files,i,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1415617196;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (int i = 0_ i < files.length_ i++) {__			if (!files[i].isDir()) {_				numberOfBlocks += getNumberOfBlocks(files[i].getLen(), files[i].getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,int,i,0,i,files,length,i,if,files,i,is,dir,number,of,blocks,get,number,of,blocks,files,i,get,len,files,i,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1416482279;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1417108705;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1420731347;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1420731347;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1420731728;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1422034750;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1422959656;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1423847366;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1424860683;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1427824467;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1431371277;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1445264257;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public int getNumberOfBlocks(final FileStatus file) throws IOException;1446112342;Returns the number of blocks this file/directory consists of_assuming the file system's standard block size.__@param file_the file_@return the number of block's the file/directory consists of_@throws IOException;public int getNumberOfBlocks(final FileStatus file) throws IOException {__		int numberOfBlocks = 0___		if (file == null) {_			return 0__		}__		_		if (!file.isDir()) {_			return getNumberOfBlocks(file.getLen(), file.getBlockSize())__		}__		_		final FileStatus[] files = this.listStatus(file.getPath())__		for (FileStatus file1 : files) {_			if (!file1.isDir()) {_				numberOfBlocks += getNumberOfBlocks(file1.getLen(), file1.getBlockSize())__			}_		}__		return numberOfBlocks__	};returns,the,number,of,blocks,this,file,directory,consists,of,assuming,the,file,system,s,standard,block,size,param,file,the,file,return,the,number,of,block,s,the,file,directory,consists,of,throws,ioexception;public,int,get,number,of,blocks,final,file,status,file,throws,ioexception,int,number,of,blocks,0,if,file,null,return,0,if,file,is,dir,return,get,number,of,blocks,file,get,len,file,get,block,size,final,file,status,files,this,list,status,file,get,path,for,file,status,file1,files,if,file1,is,dir,number,of,blocks,get,number,of,blocks,file1,get,len,file1,get,block,size,return,number,of,blocks
FileSystem -> public abstract URI getUri()_;1405024514;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1405090423;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1408359504;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1411473593;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1415031057;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1415302606;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1415617196;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1416482279;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1417108705;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1420731347;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1420731347;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1420731728;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1422034750;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1422959656;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1423847366;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1424860683;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1427824467;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1431371277;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1445264257;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1446112342;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1450111459;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1450713543;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1451152602;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1452178883;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1455632624;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1467707997;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1479853012;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1481633610;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1481715812;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1481715812;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1485255695;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1485698310;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1487082763;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1487548884;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1487548884;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1507223685;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1507223685;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1507281370;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1507304713;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1507752419;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1508481109;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1510933709;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1511520068;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1511520068;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1512410190;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1515600855;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1531689536;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> public abstract URI getUri()_;1531689536;Returns a URI whose scheme and authority identify this file system.__@return a URI whose scheme and authority identify this file system;public abstract URI getUri()_;returns,a,uri,whose,scheme,and,authority,identify,this,file,system,return,a,uri,whose,scheme,and,authority,identify,this,file,system;public,abstract,uri,get,uri
FileSystem -> @Internal 	public static void createAndSetFileSystemCloseableRegistryForThread();1485698310;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the beginning of the task's_main thread.;@Internal_	public static void createAndSetFileSystemCloseableRegistryForThread() {_		SafetyNetCloseableRegistry oldRegistry = REGISTRIES.get()__		Preconditions.checkState(null == oldRegistry,_				"Found old CloseableRegistry " + oldRegistry +_						". This indicates a leak of the InheritableThreadLocal through a ThreadPool!")___		SafetyNetCloseableRegistry newRegistry = new SafetyNetCloseableRegistry()__		REGISTRIES.set(newRegistry)__		LOG.info("Created new CloseableRegistry " + newRegistry + " for {}", Thread.currentThread().getName())__	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,beginning,of,the,task,s,main,thread;internal,public,static,void,create,and,set,file,system,closeable,registry,for,thread,safety,net,closeable,registry,old,registry,registries,get,preconditions,check,state,null,old,registry,found,old,closeable,registry,old,registry,this,indicates,a,leak,of,the,inheritable,thread,local,through,a,thread,pool,safety,net,closeable,registry,new,registry,new,safety,net,closeable,registry,registries,set,new,registry,log,info,created,new,closeable,registry,new,registry,for,thread,current,thread,get,name
FileSystem -> @Internal 	public static void createAndSetFileSystemCloseableRegistryForThread();1487082763;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the beginning of the task's_main thread.;@Internal_	public static void createAndSetFileSystemCloseableRegistryForThread() {_		SafetyNetCloseableRegistry oldRegistry = REGISTRIES.get()__		Preconditions.checkState(null == oldRegistry,_				"Found old CloseableRegistry " + oldRegistry +_						". This indicates a leak of the InheritableThreadLocal through a ThreadPool!")___		SafetyNetCloseableRegistry newRegistry = new SafetyNetCloseableRegistry()__		REGISTRIES.set(newRegistry)__		LOG.info("Created new CloseableRegistry " + newRegistry + " for {}", Thread.currentThread().getName())__	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,beginning,of,the,task,s,main,thread;internal,public,static,void,create,and,set,file,system,closeable,registry,for,thread,safety,net,closeable,registry,old,registry,registries,get,preconditions,check,state,null,old,registry,found,old,closeable,registry,old,registry,this,indicates,a,leak,of,the,inheritable,thread,local,through,a,thread,pool,safety,net,closeable,registry,new,registry,new,safety,net,closeable,registry,registries,set,new,registry,log,info,created,new,closeable,registry,new,registry,for,thread,current,thread,get,name
FileSystem -> @Internal 	public static void createAndSetFileSystemCloseableRegistryForThread();1487548884;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the beginning of the task's_main thread.;@Internal_	public static void createAndSetFileSystemCloseableRegistryForThread() {_		SafetyNetCloseableRegistry oldRegistry = REGISTRIES.get()__		Preconditions.checkState(null == oldRegistry,_				"Found old CloseableRegistry " + oldRegistry +_						". This indicates a leak of the InheritableThreadLocal through a ThreadPool!")___		SafetyNetCloseableRegistry newRegistry = new SafetyNetCloseableRegistry()__		REGISTRIES.set(newRegistry)__		LOG.info("Created new CloseableRegistry " + newRegistry + " for {}", Thread.currentThread().getName())__	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,beginning,of,the,task,s,main,thread;internal,public,static,void,create,and,set,file,system,closeable,registry,for,thread,safety,net,closeable,registry,old,registry,registries,get,preconditions,check,state,null,old,registry,found,old,closeable,registry,old,registry,this,indicates,a,leak,of,the,inheritable,thread,local,through,a,thread,pool,safety,net,closeable,registry,new,registry,new,safety,net,closeable,registry,registries,set,new,registry,log,info,created,new,closeable,registry,new,registry,for,thread,current,thread,get,name
FileSystem -> public static FileSystem get(URI uri) throws IOException;1405024514;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {__		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					_					throw new IOException("FileSystem: Scheme is null. file:// or hdfs:// are example schemes. "_							+ "Failed for " + uri.toString() + ".")__				}_			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			_			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				throw new IOException("No file system found with scheme " + uri.getScheme()_				+ ". Failed for " + uri.toString() + ".")__			}__			Class<? extends FileSystem> fsClass = null__			try {_				fsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()))__			} catch (ClassNotFoundException e1) {_				throw new IOException(StringUtils.stringifyException(e1))__			}__			try {_				fs = fsClass.newInstance()__			}_			catch (InstantiationException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}_			catch (IllegalAccessException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}__			_			fs.initialize(uri)___			_			CACHE.put(key, fs)__		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,throw,new,ioexception,file,system,scheme,is,null,file,or,hdfs,are,example,schemes,failed,for,uri,to,string,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,failed,for,uri,to,string,class,extends,file,system,fs,class,null,try,fs,class,class,utils,get,file,system,by,name,fsdirectory,get,uri,get,scheme,catch,class,not,found,exception,e1,throw,new,ioexception,string,utils,stringify,exception,e1,try,fs,fs,class,new,instance,catch,instantiation,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,catch,illegal,access,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1405090423;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {__		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					_					throw new IOException("FileSystem: Scheme is null. file:// or hdfs:// are example schemes. "_							+ "Failed for " + uri.toString() + ".")__				}_			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			_			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				throw new IOException("No file system found with scheme " + uri.getScheme()_				+ ". Failed for " + uri.toString() + ".")__			}__			Class<? extends FileSystem> fsClass = null__			try {_				fsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()))__			} catch (ClassNotFoundException e1) {_				throw new IOException(StringUtils.stringifyException(e1))__			}__			try {_				fs = fsClass.newInstance()__			}_			catch (InstantiationException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}_			catch (IllegalAccessException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}__			_			fs.initialize(uri)___			_			CACHE.put(key, fs)__		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,throw,new,ioexception,file,system,scheme,is,null,file,or,hdfs,are,example,schemes,failed,for,uri,to,string,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,failed,for,uri,to,string,class,extends,file,system,fs,class,null,try,fs,class,class,utils,get,file,system,by,name,fsdirectory,get,uri,get,scheme,catch,class,not,found,exception,e1,throw,new,ioexception,string,utils,stringify,exception,e1,try,fs,fs,class,new,instance,catch,instantiation,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,catch,illegal,access,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1408359504;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {__		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					_					throw new IOException("FileSystem: Scheme is null. file:// or hdfs:// are example schemes. "_							+ "Failed for " + uri.toString() + ".")__				}_			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			_			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				throw new IOException("No file system found with scheme " + uri.getScheme()_				+ ". Failed for " + uri.toString() + ".")__			}__			Class<? extends FileSystem> fsClass = null__			try {_				fsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()))__			} catch (ClassNotFoundException e1) {_				throw new IOException(StringUtils.stringifyException(e1))__			}__			try {_				fs = fsClass.newInstance()__			}_			catch (InstantiationException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}_			catch (IllegalAccessException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}__			_			fs.initialize(uri)___			_			CACHE.put(key, fs)__		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,throw,new,ioexception,file,system,scheme,is,null,file,or,hdfs,are,example,schemes,failed,for,uri,to,string,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,failed,for,uri,to,string,class,extends,file,system,fs,class,null,try,fs,class,class,utils,get,file,system,by,name,fsdirectory,get,uri,get,scheme,catch,class,not,found,exception,e1,throw,new,ioexception,string,utils,stringify,exception,e1,try,fs,fs,class,new,instance,catch,instantiation,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,catch,illegal,access,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1411473593;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {__		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					_					throw new IOException("FileSystem: Scheme is null. file:// or hdfs:// are example schemes. "_							+ "Failed for " + uri.toString() + ".")__				}_			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			_			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				throw new IOException("No file system found with scheme " + uri.getScheme()_				+ ". Failed for " + uri.toString() + ".")__			}__			Class<? extends FileSystem> fsClass = null__			try {_				fsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()))__			} catch (ClassNotFoundException e1) {_				throw new IOException(StringUtils.stringifyException(e1))__			}__			try {_				fs = fsClass.newInstance()__			}_			catch (InstantiationException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}_			catch (IllegalAccessException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}__			_			fs.initialize(uri)___			_			CACHE.put(key, fs)__		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,throw,new,ioexception,file,system,scheme,is,null,file,or,hdfs,are,example,schemes,failed,for,uri,to,string,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,failed,for,uri,to,string,class,extends,file,system,fs,class,null,try,fs,class,class,utils,get,file,system,by,name,fsdirectory,get,uri,get,scheme,catch,class,not,found,exception,e1,throw,new,ioexception,string,utils,stringify,exception,e1,try,fs,fs,class,new,instance,catch,instantiation,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,catch,illegal,access,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1415031057;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {__		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					_					throw new IOException("The file URI '" + uri.toString() + "' is not valid. "_							+ " File URIs need to specify aboslute file paths.")__				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			_			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				throw new IOException("No file system found with scheme " + uri.getScheme()_						+ ", referenced in file URI '" + uri.toString() + "'.")__			}__			Class<? extends FileSystem> fsClass = null__			try {_				fsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()))__			} catch (ClassNotFoundException e1) {_				throw new IOException(StringUtils.stringifyException(e1))__			}__			try {_				fs = fsClass.newInstance()__			}_			catch (InstantiationException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}_			catch (IllegalAccessException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}__			_			fs.initialize(uri)___			_			CACHE.put(key, fs)__		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,file,uris,need,to,specify,aboslute,file,paths,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,class,extends,file,system,fs,class,null,try,fs,class,class,utils,get,file,system,by,name,fsdirectory,get,uri,get,scheme,catch,class,not,found,exception,e1,throw,new,ioexception,string,utils,stringify,exception,e1,try,fs,fs,class,new,instance,catch,instantiation,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,catch,illegal,access,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1415302606;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {__		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					_					throw new IOException("The file URI '" + uri.toString() + "' is not valid. "_							+ " File URIs need to specify aboslute file paths.")__				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			_			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				throw new IOException("No file system found with scheme " + uri.getScheme()_						+ ", referenced in file URI '" + uri.toString() + "'.")__			}__			Class<? extends FileSystem> fsClass = null__			try {_				fsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()))__			} catch (ClassNotFoundException e1) {_				throw new IOException(StringUtils.stringifyException(e1))__			}__			try {_				fs = fsClass.newInstance()__			}_			catch (InstantiationException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}_			catch (IllegalAccessException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}__			_			fs.initialize(uri)___			_			CACHE.put(key, fs)__		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,file,uris,need,to,specify,aboslute,file,paths,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,class,extends,file,system,fs,class,null,try,fs,class,class,utils,get,file,system,by,name,fsdirectory,get,uri,get,scheme,catch,class,not,found,exception,e1,throw,new,ioexception,string,utils,stringify,exception,e1,try,fs,fs,class,new,instance,catch,instantiation,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,catch,illegal,access,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1415617196;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {__		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					_					throw new IOException("The file URI '" + uri.toString() + "' is not valid. "_							+ " File URIs need to specify aboslute file paths.")__				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			_			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				throw new IOException("No file system found with scheme " + uri.getScheme()_						+ ", referenced in file URI '" + uri.toString() + "'.")__			}__			Class<? extends FileSystem> fsClass = null__			try {_				fsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()))__			} catch (ClassNotFoundException e1) {_				throw new IOException(StringUtils.stringifyException(e1))__			}__			try {_				fs = fsClass.newInstance()__			}_			catch (InstantiationException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}_			catch (IllegalAccessException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}__			_			fs.initialize(uri)___			_			CACHE.put(key, fs)__		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,file,uris,need,to,specify,aboslute,file,paths,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,class,extends,file,system,fs,class,null,try,fs,class,class,utils,get,file,system,by,name,fsdirectory,get,uri,get,scheme,catch,class,not,found,exception,e1,throw,new,ioexception,string,utils,stringify,exception,e1,try,fs,fs,class,new,instance,catch,instantiation,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,catch,illegal,access,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1416482279;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {__		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					_					throw new IOException("The file URI '" + uri.toString() + "' is not valid. "_							+ " File URIs need to specify aboslute file paths.")__				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			_			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				throw new IOException("No file system found with scheme " + uri.getScheme()_						+ ", referenced in file URI '" + uri.toString() + "'.")__			}__			Class<? extends FileSystem> fsClass__			try {_				fsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()))__			} catch (ClassNotFoundException e1) {_				throw new IOException(StringUtils.stringifyException(e1))__			}__			try {_				fs = fsClass.newInstance()__			}_			catch (InstantiationException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}_			catch (IllegalAccessException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}__			_			fs.initialize(uri)___			_			CACHE.put(key, fs)__		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,file,uris,need,to,specify,aboslute,file,paths,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,class,extends,file,system,fs,class,try,fs,class,class,utils,get,file,system,by,name,fsdirectory,get,uri,get,scheme,catch,class,not,found,exception,e1,throw,new,ioexception,string,utils,stringify,exception,e1,try,fs,fs,class,new,instance,catch,instantiation,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,catch,illegal,access,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1417108705;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {__		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			_			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				throw new IOException("No file system found with scheme " + uri.getScheme()_						+ ", referenced in file URI '" + uri.toString() + "'.")__			}__			Class<? extends FileSystem> fsClass__			try {_				fsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()))__			} catch (ClassNotFoundException e1) {_				throw new IOException(StringUtils.stringifyException(e1))__			}__			try {_				fs = fsClass.newInstance()__			}_			catch (InstantiationException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}_			catch (IllegalAccessException e) {_				throw new IOException("Could not instantiate file system class: " + e.getMessage(), e)__			}__			_			fs.initialize(uri)___			_			CACHE.put(key, fs)__		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,class,extends,file,system,fs,class,try,fs,class,class,utils,get,file,system,by,name,fsdirectory,get,uri,get,scheme,catch,class,not,found,exception,e1,throw,new,ioexception,string,utils,stringify,exception,e1,try,fs,fs,class,new,instance,catch,instantiation,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,catch,illegal,access,exception,e,throw,new,ioexception,could,not,instantiate,file,system,class,e,get,message,e,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1420731347;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if(wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					System.out.println("Initializing new instance of wrapper for "+wrapperClass)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				System.out.println("Initializing new instance of native class for "+fsClass)__				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,system,out,println,initializing,new,instance,of,wrapper,for,wrapper,class,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,system,out,println,initializing,new,instance,of,native,class,for,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1420731347;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if(wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					System.out.println("Initializing new instance of wrapper for "+wrapperClass)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				System.out.println("Initializing new instance of native class for "+fsClass)__				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,system,out,println,initializing,new,instance,of,wrapper,for,wrapper,class,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,system,out,println,initializing,new,instance,of,native,class,for,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1420731728;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if(wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					System.out.println("Initializing new instance of wrapper for "+wrapperClass)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,system,out,println,initializing,new,instance,of,wrapper,for,wrapper,class,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1422034750;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if(wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1422959656;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if(wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1423847366;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1424860683;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1427824467;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs = null___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,null,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1431371277;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1445264257;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1446112342;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1450111459;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1450713543;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1451152602;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1452178883;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs___		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					uri = new URI("file", null, uri.getPath(), null)__				}_				catch (URISyntaxException e) {_					try {_						uri = new URI("file", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__					} catch (URISyntaxException ex) {_						_						throw new IOException("The file URI '" + uri.toString() + "' is not valid.")__					}_				}_			}_			_			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()__				_				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_							+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,synchronized,if,uri,get,scheme,null,try,uri,new,uri,file,null,uri,get,path,null,catch,urisyntax,exception,e,try,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,file,uri,uri,to,string,is,not,valid,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1455632624;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs___		URI asked = uri__		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					if (defaultScheme == null) {_						defaultScheme = new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__					}__					uri = new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),_						defaultScheme.getPort(), uri.getPath(), null, null)___				} catch (URISyntaxException e) {_					try {_						if (defaultScheme.getScheme().equals("file")) {_							uri = new URI("file", null,_								new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__						}_					} catch (URISyntaxException ex) {_						_						throw new IOException("The URI '" + uri.toString() + "' is not valid.")__					}_				}_			}__			if(uri.getScheme() == null) {_				throw new IOException("The URI '" + uri + "' is invalid.\n" +_					"The fs.default-scheme = " + defaultScheme + ", the requested URI = " + asked +_					", and the final URI = " + uri + ".")__			}__			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()___				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!FSDIRECTORY.containsKey(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_						+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,uri,asked,uri,synchronized,if,uri,get,scheme,null,try,if,default,scheme,null,default,scheme,new,uri,config,constants,uri,new,uri,default,scheme,get,scheme,null,default,scheme,get,host,default,scheme,get,port,uri,get,path,null,null,catch,urisyntax,exception,e,try,if,default,scheme,get,scheme,equals,file,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,uri,uri,to,string,is,not,valid,if,uri,get,scheme,null,throw,new,ioexception,the,uri,uri,is,invalid,n,the,fs,default,scheme,default,scheme,the,requested,uri,asked,and,the,final,uri,uri,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,fsdirectory,contains,key,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1467707997;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		FileSystem fs___		URI asked = uri__		synchronized (SYNCHRONIZATION_OBJECT) {__			if (uri.getScheme() == null) {_				try {_					if (defaultScheme == null) {_						defaultScheme = new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__					}__					uri = new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),_						defaultScheme.getPort(), uri.getPath(), null, null)___				} catch (URISyntaxException e) {_					try {_						if (defaultScheme.getScheme().equals("file")) {_							uri = new URI("file", null,_								new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null)__						}_					} catch (URISyntaxException ex) {_						_						throw new IOException("The URI '" + uri.toString() + "' is not valid.")__					}_				}_			}__			if(uri.getScheme() == null) {_				throw new IOException("The URI '" + uri + "' is invalid.\n" +_					"The fs.default-scheme = " + defaultScheme + ", the requested URI = " + asked +_					", and the final URI = " + uri + ".")__			}__			if (uri.getScheme().equals("file") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {_				String supposedUri = "file:///" + uri.getAuthority() + uri.getPath()___				throw new IOException("Found local file path with authority '" + uri.getAuthority() + "' in path '"_						+ uri.toString() + "'. Hint: Did you forget a slash? (correct path would be '" + supposedUri + "')")__			}__			final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority())___			_			if (CACHE.containsKey(key)) {_				return CACHE.get(key)__			}__			__			if (!isFlinkSupportedScheme(uri.getScheme())) {_				_				Class<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme())__				if (wrapperClass != null) {_					_					FSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + "+" + uri.getScheme(), uri.getAuthority())__					if (CACHE.containsKey(wrappedKey)) {_						return CACHE.get(wrappedKey)__					}_					__					_					fs = instantiateHadoopFileSystemWrapper(wrapperClass)__					fs.initialize(uri)__					CACHE.put(wrappedKey, fs)___				} else {_					_					throw new IOException("No file system found with scheme " + uri.getScheme()_						+ ", referenced in file URI '" + uri.toString() + "'.")__				}_			} else {_				_				String fsClass = FSDIRECTORY.get(uri.getScheme())__				if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {_					fs = instantiateHadoopFileSystemWrapper(null)__				} else {_					fs = instantiateFileSystem(fsClass)__				}_				_				fs.initialize(uri)___				_				CACHE.put(key, fs)__			}_		}__		return fs__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,file,system,fs,uri,asked,uri,synchronized,if,uri,get,scheme,null,try,if,default,scheme,null,default,scheme,new,uri,config,constants,uri,new,uri,default,scheme,get,scheme,null,default,scheme,get,host,default,scheme,get,port,uri,get,path,null,null,catch,urisyntax,exception,e,try,if,default,scheme,get,scheme,equals,file,uri,new,uri,file,null,new,path,new,file,uri,get,path,get,absolute,path,to,uri,get,path,null,catch,urisyntax,exception,ex,throw,new,ioexception,the,uri,uri,to,string,is,not,valid,if,uri,get,scheme,null,throw,new,ioexception,the,uri,uri,is,invalid,n,the,fs,default,scheme,default,scheme,the,requested,uri,asked,and,the,final,uri,uri,if,uri,get,scheme,equals,file,uri,get,authority,null,uri,get,authority,is,empty,string,supposed,uri,file,uri,get,authority,uri,get,path,throw,new,ioexception,found,local,file,path,with,authority,uri,get,authority,in,path,uri,to,string,hint,did,you,forget,a,slash,correct,path,would,be,supposed,uri,final,fskey,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,key,return,cache,get,key,if,is,flink,supported,scheme,uri,get,scheme,class,wrapper,class,get,hadoop,wrapper,class,name,for,file,system,uri,get,scheme,if,wrapper,class,null,fskey,wrapped,key,new,fskey,uri,get,scheme,uri,get,authority,if,cache,contains,key,wrapped,key,return,cache,get,wrapped,key,fs,instantiate,hadoop,file,system,wrapper,wrapper,class,fs,initialize,uri,cache,put,wrapped,key,fs,else,throw,new,ioexception,no,file,system,found,with,scheme,uri,get,scheme,referenced,in,file,uri,uri,to,string,else,string,fs,class,fsdirectory,get,uri,get,scheme,if,fs,class,equals,fs,instantiate,hadoop,file,system,wrapper,null,else,fs,instantiate,file,system,fs,class,fs,initialize,uri,cache,put,key,fs,return,fs
FileSystem -> public static FileSystem get(URI uri) throws IOException;1479853012;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return wrapWithSafetyNetWhenInTask(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,wrap,with,safety,net,when,in,task,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1481633610;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return wrapWithSafetyNetWhenInTask(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,wrap,with,safety,net,when,in,task,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1481715812;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return wrapWithSafetyNetWhenInTask(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,wrap,with,safety,net,when,in,task,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1481715812;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return wrapWithSafetyNetWhenInTask(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,wrap,with,safety,net,when,in,task,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1485255695;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return wrapWithSafetyNetWhenInTask(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,wrap,with,safety,net,when,in,task,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1485698310;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1487082763;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1487548884;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1487548884;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1507223685;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1507223685;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1507281370;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1507304713;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1507752419;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1508481109;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1510933709;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1511520068;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1511520068;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1512410190;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1515600855;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1531689536;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public static FileSystem get(URI uri) throws IOException;1531689536;Returns a reference to the {@link FileSystem} instance for accessing the_file system identified by the given {@link URI}.__@param uri_the {@link URI} identifying the file system_@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given_{@link URI}._@throws IOException_thrown if a reference to the file system instance could not be obtained;public static FileSystem get(URI uri) throws IOException {_		return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri))__	};returns,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,param,uri,the,link,uri,identifying,the,file,system,return,a,reference,to,the,link,file,system,instance,for,accessing,the,file,system,identified,by,the,given,link,uri,throws,ioexception,thrown,if,a,reference,to,the,file,system,instance,could,not,be,obtained;public,static,file,system,get,uri,uri,throws,ioexception,return,file,system,safety,net,wrap,with,safety,net,when,activated,get,unguarded,file,system,uri
FileSystem -> public abstract Path getWorkingDirectory()_;1405024514;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1405090423;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1408359504;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1411473593;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1415031057;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1415302606;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1415617196;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1416482279;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1417108705;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1420731347;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1420731347;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1420731728;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1422034750;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1422959656;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1423847366;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1424860683;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1427824467;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1431371277;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1445264257;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1446112342;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1450111459;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1450713543;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1451152602;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1452178883;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1455632624;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1467707997;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1479853012;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1481633610;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1481715812;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1481715812;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1485255695;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1485698310;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1487082763;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1487548884;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1487548884;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1507223685;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1507223685;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1507281370;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1507304713;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1507752419;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1508481109;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1510933709;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1511520068;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1511520068;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1512410190;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1515600855;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1531689536;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getWorkingDirectory()_;1531689536;Returns the path of the file system's current working directory.__@return the path of the file system's current working directory;public abstract Path getWorkingDirectory()_;returns,the,path,of,the,file,system,s,current,working,directory,return,the,path,of,the,file,system,s,current,working,directory;public,abstract,path,get,working,directory
FileSystem -> public abstract Path getHomeDirectory()_;1424860683;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1427824467;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1431371277;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1445264257;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1446112342;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1450111459;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1450713543;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1451152602;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1452178883;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1455632624;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1467707997;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1479853012;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1481633610;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1481715812;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1481715812;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1485255695;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1485698310;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1487082763;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1487548884;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1487548884;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1507223685;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1507223685;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1507281370;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1507304713;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1507752419;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1508481109;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1510933709;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1511520068;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1511520068;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1512410190;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1515600855;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1531689536;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public abstract Path getHomeDirectory()_;1531689536;Returns the path of the user's home directory in this file system.__@return the path of the user's home directory in this file system.;public abstract Path getHomeDirectory()_;returns,the,path,of,the,user,s,home,directory,in,this,file,system,return,the,path,of,the,user,s,home,directory,in,this,file,system;public,abstract,path,get,home,directory
FileSystem -> public static URI getDefaultFsUri();1507281370;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return DEFAULT_SCHEME != null ? DEFAULT_SCHEME : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,null,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1507304713;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return DEFAULT_SCHEME != null ? DEFAULT_SCHEME : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,null,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1507752419;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return DEFAULT_SCHEME != null ? DEFAULT_SCHEME : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,null,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1508481109;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return DEFAULT_SCHEME != null ? DEFAULT_SCHEME : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,null,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1510933709;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return DEFAULT_SCHEME != null ? DEFAULT_SCHEME : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,null,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1511520068;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return DEFAULT_SCHEME != null ? DEFAULT_SCHEME : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,null,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1511520068;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return DEFAULT_SCHEME != null ? DEFAULT_SCHEME : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,null,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1512410190;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return DEFAULT_SCHEME != null ? DEFAULT_SCHEME : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,null,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1515600855;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return DEFAULT_SCHEME != null ? DEFAULT_SCHEME : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,null,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1531689536;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return defaultScheme != null ? defaultScheme : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,default,scheme,null,default,scheme,local,file,system,get,local,fs,uri
FileSystem -> public static URI getDefaultFsUri();1531689536;Gets the default file system URI that is used for paths and file systems_that do not specify and explicit scheme.__<p>As an example, assume the default file system URI is set to {@code 'hdfs://someserver:9000/'}._A file path of {@code '/user/USERNAME/in.txt'} is interpreted as_{@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.__@return The default file system URI;public static URI getDefaultFsUri() {_		return defaultScheme != null ? defaultScheme : LocalFileSystem.getLocalFsURI()__	};gets,the,default,file,system,uri,that,is,used,for,paths,and,file,systems,that,do,not,specify,and,explicit,scheme,p,as,an,example,assume,the,default,file,system,uri,is,set,to,code,hdfs,someserver,9000,a,file,path,of,code,user,username,in,txt,is,interpreted,as,code,hdfs,someserver,9000,user,username,in,txt,return,the,default,file,system,uri;public,static,uri,get,default,fs,uri,return,default,scheme,null,default,scheme,local,file,system,get,local,fs,uri
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1455632624;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1467707997;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1479853012;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1481633610;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1481715812;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1481715812;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1485255695;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1485698310;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1487082763;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1487548884;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1487548884;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		synchronized (SYNCHRONIZATION_OBJECT) {_			if (defaultScheme == null) {_				String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME,_					ConfigConstants.DEFAULT_FILESYSTEM_SCHEME)__				try {_					defaultScheme = new URI(stringifiedUri)__				} catch (URISyntaxException e) {_					throw new IOException("The URI used to set the default filesystem " +_						"scheme ('" + stringifiedUri + "') is not valid.")__				}_			}_		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,synchronized,if,default,scheme,null,string,stringified,uri,config,get,string,config,constants,config,constants,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1507223685;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		LOCK.lock()__		try {_			if (defaultScheme == null) {_				final String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME, null)__				if (stringifiedUri == null) {_					defaultScheme = LocalFileSystem.getLocalFsURI()__				}_				else {_					try {_						defaultScheme = new URI(stringifiedUri)__					} catch (URISyntaxException e) {_						throw new IOException("The URI used to set the default filesystem " +_								"scheme ('" + stringifiedUri + "') is not valid.")__					}_				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,lock,lock,try,if,default,scheme,null,final,string,stringified,uri,config,get,string,config,constants,null,if,stringified,uri,null,default,scheme,local,file,system,get,local,fs,uri,else,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid,finally,lock,unlock
FileSystem -> public static void setDefaultScheme(Configuration config) throws IOException;1507223685;<p>_Sets the default filesystem scheme based on the user-specified configuration parameter_<code>fs.default-scheme</code>. By default this is set to <code>file:///</code>_(see {@link ConfigConstants#FILESYSTEM_SCHEME} and_{@link ConfigConstants#DEFAULT_FILESYSTEM_SCHEME}),_and the local filesystem is used._<p>_As an example, if set to <code>hdfs://localhost:9000/</code>, then an HDFS deployment_with the namenode being on the local node and listening to port 9000 is going to be used._In this case, a file path specified as <code>/user/USERNAME/in.txt</code>_is going to be transformed into <code>hdfs://localhost:9000/user/USERNAME/in.txt</code>. By_default this is set to <code>file:///</code> which points to the local filesystem._@param config the configuration from where to fetch the parameter.;public static void setDefaultScheme(Configuration config) throws IOException {_		LOCK.lock()__		try {_			if (defaultScheme == null) {_				final String stringifiedUri = config.getString(ConfigConstants.FILESYSTEM_SCHEME, null)__				if (stringifiedUri == null) {_					defaultScheme = LocalFileSystem.getLocalFsURI()__				}_				else {_					try {_						defaultScheme = new URI(stringifiedUri)__					} catch (URISyntaxException e) {_						throw new IOException("The URI used to set the default filesystem " +_								"scheme ('" + stringifiedUri + "') is not valid.")__					}_				}_			}_		}_		finally {_			LOCK.unlock()__		}_	};p,sets,the,default,filesystem,scheme,based,on,the,user,specified,configuration,parameter,code,fs,default,scheme,code,by,default,this,is,set,to,code,file,code,see,link,config,constants,and,link,config,constants,and,the,local,filesystem,is,used,p,as,an,example,if,set,to,code,hdfs,localhost,9000,code,then,an,hdfs,deployment,with,the,namenode,being,on,the,local,node,and,listening,to,port,9000,is,going,to,be,used,in,this,case,a,file,path,specified,as,code,user,username,in,txt,code,is,going,to,be,transformed,into,code,hdfs,localhost,9000,user,username,in,txt,code,by,default,this,is,set,to,code,file,code,which,points,to,the,local,filesystem,param,config,the,configuration,from,where,to,fetch,the,parameter;public,static,void,set,default,scheme,configuration,config,throws,ioexception,lock,lock,try,if,default,scheme,null,final,string,stringified,uri,config,get,string,config,constants,null,if,stringified,uri,null,default,scheme,local,file,system,get,local,fs,uri,else,try,default,scheme,new,uri,stringified,uri,catch,urisyntax,exception,e,throw,new,ioexception,the,uri,used,to,set,the,default,filesystem,scheme,stringified,uri,is,not,valid,finally,lock,unlock
FileSystem -> private static HashMap<String, FileSystemFactory> loadFileSystems();1507304713;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static HashMap<String, FileSystemFactory> loadFileSystems() {_		final HashMap<String, FileSystemFactory> map = new HashMap<>()___		_		map.put("file", new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					String scheme = factory.getScheme()__					map.put(scheme, factory)__					LOG.debug("Added file system {}:{}", scheme, factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file systems via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return map__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,hash,map,string,file,system,factory,load,file,systems,final,hash,map,string,file,system,factory,map,new,hash,map,map,put,file,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,string,scheme,factory,get,scheme,map,put,scheme,factory,log,debug,added,file,system,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,systems,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,map
FileSystem -> private static HashMap<String, FileSystemFactory> loadFileSystems();1507752419;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static HashMap<String, FileSystemFactory> loadFileSystems() {_		final HashMap<String, FileSystemFactory> map = new HashMap<>()___		_		map.put("file", new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					String scheme = factory.getScheme()__					map.put(scheme, factory)__					LOG.debug("Added file system {}:{}", scheme, factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file systems via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return map__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,hash,map,string,file,system,factory,load,file,systems,final,hash,map,string,file,system,factory,map,new,hash,map,map,put,file,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,string,scheme,factory,get,scheme,map,put,scheme,factory,log,debug,added,file,system,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,systems,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,map
FileSystem -> private static HashMap<String, FileSystemFactory> loadFileSystems();1508481109;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static HashMap<String, FileSystemFactory> loadFileSystems() {_		final HashMap<String, FileSystemFactory> map = new HashMap<>()___		_		map.put("file", new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					String scheme = factory.getScheme()__					map.put(scheme, factory)__					LOG.debug("Added file system {}:{}", scheme, factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file systems via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return map__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,hash,map,string,file,system,factory,load,file,systems,final,hash,map,string,file,system,factory,map,new,hash,map,map,put,file,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,string,scheme,factory,get,scheme,map,put,scheme,factory,log,debug,added,file,system,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,systems,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,map
FileSystem -> private static HashMap<String, FileSystemFactory> loadFileSystems();1510933709;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static HashMap<String, FileSystemFactory> loadFileSystems() {_		final HashMap<String, FileSystemFactory> map = new HashMap<>()___		_		map.put("file", new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					String scheme = factory.getScheme()__					map.put(scheme, factory)__					LOG.debug("Added file system {}:{}", scheme, factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file systems via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return map__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,hash,map,string,file,system,factory,load,file,systems,final,hash,map,string,file,system,factory,map,new,hash,map,map,put,file,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,string,scheme,factory,get,scheme,map,put,scheme,factory,log,debug,added,file,system,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,systems,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,map
FileSystem -> private static HashMap<String, FileSystemFactory> loadFileSystems();1511520068;Loads the factories for the file systems directly supported by Flink._Aside from the {@link LocalFileSystem}, these file systems are loaded_via Java's service framework.__@return A map from the file system scheme to corresponding file system factory.;private static HashMap<String, FileSystemFactory> loadFileSystems() {_		final HashMap<String, FileSystemFactory> map = new HashMap<>()___		_		map.put("file", new LocalFileSystemFactory())___		LOG.debug("Loading extension file systems via services")___		try {_			ServiceLoader<FileSystemFactory> serviceLoader = ServiceLoader.load(FileSystemFactory.class)__			Iterator<FileSystemFactory> iter = serviceLoader.iterator()___			_			__			_			while (iter.hasNext()) {_				try {_					FileSystemFactory factory = iter.next()__					String scheme = factory.getScheme()__					map.put(scheme, factory)__					LOG.debug("Added file system {}:{}", scheme, factory.getClass().getName())__				}_				catch (Throwable t) {_					_					_					ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__					LOG.error("Failed to load a file system via services", t)__				}_			}_		}_		catch (Throwable t) {_			_			_			ExceptionUtils.rethrowIfFatalErrorOrOOM(t)__			LOG.error("Failed to load additional file systems via services", t)__		}__		return map__	};loads,the,factories,for,the,file,systems,directly,supported,by,flink,aside,from,the,link,local,file,system,these,file,systems,are,loaded,via,java,s,service,framework,return,a,map,from,the,file,system,scheme,to,corresponding,file,system,factory;private,static,hash,map,string,file,system,factory,load,file,systems,final,hash,map,string,file,system,factory,map,new,hash,map,map,put,file,new,local,file,system,factory,log,debug,loading,extension,file,systems,via,services,try,service,loader,file,system,factory,service,loader,service,loader,load,file,system,factory,class,iterator,file,system,factory,iter,service,loader,iterator,while,iter,has,next,try,file,system,factory,factory,iter,next,string,scheme,factory,get,scheme,map,put,scheme,factory,log,debug,added,file,system,scheme,factory,get,class,get,name,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,a,file,system,via,services,t,catch,throwable,t,exception,utils,rethrow,if,fatal,error,or,oom,t,log,error,failed,to,load,additional,file,systems,via,services,t,return,map
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1405024514;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1405090423;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1408359504;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1411473593;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1415031057;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1415302606;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1415617196;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1416482279;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1417108705;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1420731347;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1420731347;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1420731728;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1422034750;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1422959656;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if(!this.isDistributedFS()) {_			return false__		}_		_		_		if(this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if(createDirectory) {_			_			try {_				if(!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1423847366;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1424860683;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1427824467;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1431371277;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1445264257;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE & parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE & NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE & parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE & NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1446112342;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1450111459;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1450713543;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.CREATE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.CREATE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,create,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,create,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1451152602;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1452178883;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}_		_		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " + _						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() + _							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}_		_		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}_			_			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {_			_			_			return !this.exists(outPath)__		}_			_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1455632624;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}__		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}__		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}__			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {__			_			return !this.exists(outPath)__		}__	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1467707997;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}__		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}__		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}__			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {__			_			return !this.exists(outPath)__		}__	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1479853012;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}__		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}__		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}__			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {__			_			return !this.exists(outPath)__		}__	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1481633610;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}__		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}__		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}__			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {__			_			return !this.exists(outPath)__		}__	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1481715812;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise._@return True, if the path was successfully prepared, false otherwise._@throws IOException;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!this.isDistributedFS()) {_			return false__		}__		_		if (this.exists(outPath)) {_			_			switch(writeMode) {_			case NO_OVERWRITE:_				_				throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_						WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_							" mode to overwrite existing files and directories.")__			case OVERWRITE:_				_				try {_					this.delete(outPath, true)__				} catch(IOException ioe) {_					_					_					_				}_				break__			default:_				throw new IllegalArgumentException("Invalid write mode: "+writeMode)__			}_		}__		if (createDirectory) {_			_			try {_				if (!this.exists(outPath)) {_					this.mkdirs(outPath)__				}_			} catch(IOException ioe) {_				_				_				_			}__			_			return this.exists(outPath) && this.getFileStatus(outPath).isDir()__		} else {__			_			return !this.exists(outPath)__		}__	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,this,is,distributed,fs,return,false,if,this,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,this,delete,out,path,true,catch,ioexception,ioe,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,this,exists,out,path,this,mkdirs,out,path,catch,ioexception,ioe,return,this,exists,out,path,this,get,file,status,out,path,is,dir,else,return,this,exists,out,path
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1481715812;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1485255695;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1485698310;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1487082763;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1487548884;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1487548884;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507223685;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507223685;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507281370;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507304713;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1507752419;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1508481109;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1510933709;Initializes output directories on distributed file systems according to the given write mode.__WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {_	_				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")__	_				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break__	_				default:_					throw new IllegalArgumentException("Invalid write mode: "+writeMode)__				}_			}_	_			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}_	_				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1511520068;Initializes output directories on distributed file systems according to the given write mode.__<p>WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__<p>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__<p>WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__<p>WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {__				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")___				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}__				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,p,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,p,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,p,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,p,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1511520068;Initializes output directories on distributed file systems according to the given write mode.__<p>WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__<p>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__<p>WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__<p>WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {__				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")___				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}__				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,p,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,p,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,p,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,p,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1512410190;Initializes output directories on distributed file systems according to the given write mode.__<p>WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__<p>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__<p>WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__<p>WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {__				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")___				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}__				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,p,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,p,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,p,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,p,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1515600855;Initializes output directories on distributed file systems according to the given write mode.__<p>WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__<p>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__<p>WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__<p>WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {__				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")___				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}__				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,p,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,p,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,p,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,p,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1531689536;Initializes output directories on distributed file systems according to the given write mode.__<p>WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__<p>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__<p>WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__<p>WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {__				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")___				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}__				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,p,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,p,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,p,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,p,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException;1531689536;Initializes output directories on distributed file systems according to the given write mode.__<p>WriteMode.NO_OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing file or directory raises an exception.__<p>WriteMode.NO_OVERWRITE &amp_ NONE parallel output:_- An existing file or directory raises an exception.__<p>WriteMode.OVERWRITE &amp_ parallel output:_- A directory is created if the output path does not exist._- An existing directory and its content is deleted and a new directory is created._- An existing file is deleted and replaced by a new directory.__<p>WriteMode.OVERWRITE &amp_ NONE parallel output:_- An existing file or directory is deleted and replaced by a new directory.__@param outPath Output path that should be prepared._@param writeMode Write mode to consider._@param createDirectory True, to initialize a directory at the given path, false otherwise.__@return True, if the path was successfully prepared, false otherwise.__@throws IOException Thrown, if any of the file system access operations failed.;public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory) throws IOException {_		if (!isDistributedFS()) {_			return false__		}__		_		_		_		_		__		_		_		try {_			OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly()__		}_		catch (InterruptedException e) {_			_			Thread.currentThread().interrupt()___			_			throw new IOException("The thread was interrupted while trying to initialize the output directory")__		}__		try {_			_			if (exists(outPath)) {_				_				switch(writeMode) {__				case NO_OVERWRITE:_					_					throw new IOException("File or directory already exists. Existing files and directories are not overwritten in " +_							WriteMode.NO_OVERWRITE.name() + " mode. Use " + WriteMode.OVERWRITE.name() +_								" mode to overwrite existing files and directories.")___				case OVERWRITE:_					_					try {_						delete(outPath, true)__					} catch (IOException e) {_						_						_						_					}_					break___				default:_					throw new IllegalArgumentException("Invalid write mode: " + writeMode)__				}_			}__			if (createDirectory) {_				_				try {_					if (!exists(outPath)) {_						mkdirs(outPath)__					}_				} catch (IOException ioe) {_					_					_					_				}__				_				return exists(outPath) && getFileStatus(outPath).isDir()__			}_			else {_				_				_				return !exists(outPath)__			}_		}_		finally {_			OUTPUT_DIRECTORY_INIT_LOCK.unlock()__		}_	};initializes,output,directories,on,distributed,file,systems,according,to,the,given,write,mode,p,write,mode,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,file,or,directory,raises,an,exception,p,write,mode,amp,none,parallel,output,an,existing,file,or,directory,raises,an,exception,p,write,mode,overwrite,amp,parallel,output,a,directory,is,created,if,the,output,path,does,not,exist,an,existing,directory,and,its,content,is,deleted,and,a,new,directory,is,created,an,existing,file,is,deleted,and,replaced,by,a,new,directory,p,write,mode,overwrite,amp,none,parallel,output,an,existing,file,or,directory,is,deleted,and,replaced,by,a,new,directory,param,out,path,output,path,that,should,be,prepared,param,write,mode,write,mode,to,consider,param,create,directory,true,to,initialize,a,directory,at,the,given,path,false,otherwise,return,true,if,the,path,was,successfully,prepared,false,otherwise,throws,ioexception,thrown,if,any,of,the,file,system,access,operations,failed;public,boolean,init,out,path,dist,fs,path,out,path,write,mode,write,mode,boolean,create,directory,throws,ioexception,if,is,distributed,fs,return,false,try,lock,interruptibly,catch,interrupted,exception,e,thread,current,thread,interrupt,throw,new,ioexception,the,thread,was,interrupted,while,trying,to,initialize,the,output,directory,try,if,exists,out,path,switch,write,mode,case,throw,new,ioexception,file,or,directory,already,exists,existing,files,and,directories,are,not,overwritten,in,write,mode,name,mode,use,write,mode,overwrite,name,mode,to,overwrite,existing,files,and,directories,case,overwrite,try,delete,out,path,true,catch,ioexception,e,break,default,throw,new,illegal,argument,exception,invalid,write,mode,write,mode,if,create,directory,try,if,exists,out,path,mkdirs,out,path,catch,ioexception,ioe,return,exists,out,path,get,file,status,out,path,is,dir,else,return,exists,out,path,finally,unlock
FileSystem -> @Internal 	public static void closeAndDisposeFileSystemCloseableRegistryForThread();1485698310;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the end of the task's_main thread or when the task should be canceled.;@Internal_	public static void closeAndDisposeFileSystemCloseableRegistryForThread() {_		SafetyNetCloseableRegistry registry = REGISTRIES.get()__		if (null != registry) {_			LOG.info("Ensuring all FileSystem streams are closed for {}", Thread.currentThread().getName())__			REGISTRIES.remove()__			IOUtils.closeQuietly(registry)__		}_	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,end,of,the,task,s,main,thread,or,when,the,task,should,be,canceled;internal,public,static,void,close,and,dispose,file,system,closeable,registry,for,thread,safety,net,closeable,registry,registry,registries,get,if,null,registry,log,info,ensuring,all,file,system,streams,are,closed,for,thread,current,thread,get,name,registries,remove,ioutils,close,quietly,registry
FileSystem -> @Internal 	public static void closeAndDisposeFileSystemCloseableRegistryForThread();1487082763;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the end of the task's_main thread or when the task should be canceled.;@Internal_	public static void closeAndDisposeFileSystemCloseableRegistryForThread() {_		SafetyNetCloseableRegistry registry = REGISTRIES.get()__		if (null != registry) {_			LOG.info("Ensuring all FileSystem streams are closed for {}", Thread.currentThread().getName())__			REGISTRIES.remove()__			IOUtils.closeQuietly(registry)__		}_	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,end,of,the,task,s,main,thread,or,when,the,task,should,be,canceled;internal,public,static,void,close,and,dispose,file,system,closeable,registry,for,thread,safety,net,closeable,registry,registry,registries,get,if,null,registry,log,info,ensuring,all,file,system,streams,are,closed,for,thread,current,thread,get,name,registries,remove,ioutils,close,quietly,registry
FileSystem -> @Internal 	public static void closeAndDisposeFileSystemCloseableRegistryForThread();1487548884;Create a SafetyNetCloseableRegistry for a Task. This method should be called at the end of the task's_main thread or when the task should be canceled.;@Internal_	public static void closeAndDisposeFileSystemCloseableRegistryForThread() {_		SafetyNetCloseableRegistry registry = REGISTRIES.get()__		if (null != registry) {_			LOG.info("Ensuring all FileSystem streams are closed for {}", Thread.currentThread().getName())__			REGISTRIES.remove()__			IOUtils.closeQuietly(registry)__		}_	};create,a,safety,net,closeable,registry,for,a,task,this,method,should,be,called,at,the,end,of,the,task,s,main,thread,or,when,the,task,should,be,canceled;internal,public,static,void,close,and,dispose,file,system,closeable,registry,for,thread,safety,net,closeable,registry,registry,registries,get,if,null,registry,log,info,ensuring,all,file,system,streams,are,closed,for,thread,current,thread,get,name,registries,remove,ioutils,close,quietly,registry
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1507223685;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1507223685;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1507281370;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1507304713;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1507752419;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1508481109;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1510933709;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1511520068;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1511520068;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1512410190;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1515600855;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1531689536;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
FileSystem -> @Deprecated 	public long getDefaultBlockSize();1531689536;Return the number of bytes that large input files should be optimally be split into to minimize I/O time.__@return the number of bytes that large input files should be optimally be split into to minimize I/O time__@deprecated This value is no longer used and is meaningless.;@Deprecated_	public long getDefaultBlockSize() {_		return 32 * 1024 * 1024_ _	};return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,return,the,number,of,bytes,that,large,input,files,should,be,optimally,be,split,into,to,minimize,i,o,time,deprecated,this,value,is,no,longer,used,and,is,meaningless;deprecated,public,long,get,default,block,size,return,32,1024,1024
